{
  "topic": "Teach me oops in python",
  "toc": [
    "Introduction to Oops Concepts",
    "Class and Objects in Python",
    "Inheritance in Python",
    "Polymorphism in Python",
    "Encapsulation and Abstraction in Python"
  ],
  "resources": [
    "https://docs.oracle.com/javase/tutorial/java/concepts/",
    "https://www.w3schools.com/java/java_oop.asp",
    "https://www.w3schools.com/python/python_inheritance.asp",
    "https://www.geeksforgeeks.org/inheritance-in-python/",
    "https://www.w3schools.com/python/python_polymorphism.asp",
    "https://www.programiz.com/python-programming/polymorphism",
    "https://www.datacamp.com/tutorial/encapsulation-in-python-object-oriented-programming",
    "https://realpython.com/python3-object-oriented-programming/",
    "https://www.w3schools.com/python/python_classes.asp",
    "https://www.geeksforgeeks.org/introduction-of-object-oriented-programming/",
    "https://docs.python.org/3/tutorial/classes.html",
    "https://www.geeksforgeeks.org/polymorphism-in-python/",
    "https://www.geeksforgeeks.org/encapsulation-in-python/",
    "https://docs.python.org/3/reference/datamodel.html",
    "https://realpython.com/inheritance-composition-python/"
  ],
  "documents": "Documentation\n\n\nThe Java\u2122 Tutorials\nObject-Oriented Programming Concepts\nWhat Is an Object?\nWhat Is a Class?\nWhat Is Inheritance?\nWhat Is an Interface?\nWhat Is a Package?\nQuestions and Exercises\nHome Page > Learning the Java Language\n\u00ab\u00a0Previous\u00a0\u2022\u00a0Trail\u00a0\u2022\u00a0Next\u00a0\u00bb\n\nThe Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available.\nSee Dev.java for updated tutorials taking advantage of the latest releases.\nSee Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases.\nSee JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nLesson: Object-Oriented Programming Concepts\n\nIf you've never used an object-oriented programming language before, you'll need to learn a few basic concepts before you can begin writing any code. This lesson will introduce you to objects, classes, inheritance, interfaces, and packages. Each discussion focuses on how these concepts relate to the real world, while simultaneously providing an introduction to the syntax of the Java programming language.\n\nWhat Is an Object?\n\nAn object is a software bundle of related state and behavior. Software objects are often used to model the real-world objects that you find in everyday life. This lesson explains how state and behavior are represented within an object, introduces the concept of data encapsulation, and explains the benefits of designing your software in this manner.\n\nWhat Is a Class?\n\nA class is a blueprint or prototype from which objects are created. This section defines a class that models the state and behavior of a real-world object. It intentionally focuses on the basics, showing how even a simple class can cleanly model state and behavior.\n\nWhat Is Inheritance?\n\nInheritance provides a powerful and natural mechanism for organizing and structuring your software. This section explains how classes inherit state and behavior from their superclasses, and explains how to derive one class from another using the simple syntax provided by the Java programming language.\n\nWhat Is an Interface?\n\nAn interface is a contract between a class and the outside world. When a class implements an interface, it promises to provide the behavior published by that interface. This section defines a simple interface and explains the necessary changes for any class that implements it.\n\nWhat Is a Package?\n\nA package is a namespace for organizing classes and interfaces in a logical manner. Placing your code into packages makes large software projects easier to manage. This section explains why this is useful, and introduces you to the Application Programming Interface (API) provided by the Java platform.\n\nQuestions and Exercises: Object-Oriented Programming Concepts\n\nUse the questions and exercises presented in this section to test your understanding of objects, classes, inheritance, interfaces, and packages.\n\n\u00ab Previous \u2022 Trail \u2022 Next \u00bb\n\nAbout Oracle | Contact Us | Legal Notices | Terms of Use | Your Privacy Rights\n\nCopyright \u00a9 1995, 2024 Oracle and/or its affiliates. All rights reserved.\n\nTutorials \nExercises \nCertificates \nServices \nSearch field\n\ue80b\nLog in\nSign Up\n Get Certified\n For Teachers\n Spaces\n Plus\nHTML CSS JAVASCRIPT SQL PYTHON JAVA PHP HOW TO W3.CSS C C++ C# BOOTSTRAP REACT MYSQL JQUERY EXCEL XML DJANGO NUMPY PANDAS NODEJS DSA TYPESCRIPT ANGULAR GIT POSTGRESQL MONGODB ASP AI R GO KOTLIN SASS VUE GEN AI SCIPY CYBERSECURITY DATA SCIENCE \nJava Tutorial\nJava HOME\nJava Intro\nJava Get Started\nJava Syntax\nJava Output\nJava Comments\nJava Variables\nJava Data Types\nJava Type Casting\nJava Operators\nJava Strings\nJava Math\nJava Booleans\nJava If...Else\nJava Switch\nJava While Loop\nJava For Loop\nJava Break/Continue\nJava Arrays\n\n\nJava Methods\nJava Methods\nJava Method Parameters\nJava Method Overloading\nJava Scope\nJava Recursion\n\n\nJava Classes\nJava OOP\nJava Classes/Objects\nJava Class Attributes\nJava Class Methods\nJava Constructors\nJava Modifiers\nJava Encapsulation\nJava Packages / API\nJava Inheritance\nJava Polymorphism\nJava Inner Classes\nJava Abstraction\nJava Interface\nJava Enums\nJava User Input\nJava Date\n\n\nJava Data Structures\nJava ArrayList\nJava LinkedList\nJava List Sorting\nJava HashMap\nJava HashSet\nJava Iterator\nJava Wrapper Classes\n\n\nJava Advanced\nJava Exceptions\nJava RegEx\nJava Threads\nJava Lambda\nJava Advanced Sorting\n\n\nJava File Handling\nJava Files\nJava Create/Write Files\nJava Read Files\nJava Delete Files\n\n\nJava How To's\nAdd Two Numbers\nCount Words\nReverse a String\nSum of Array Elements\nConvert String to Array\nSort an Array\nFind Array Average\nFind Smallest Element\nArrayList Loop\nHashMap Loop\nLoop Through an Enum\nArea of Rectangle\nEven or Odd Number\nPositive or Negative\nSquare Root\nRandom Number\n\n\nJava Reference\nJava Reference\nJava Keywords\nJava String Methods\nJava Math Methods\nJava Output Methods\nJava Arrays Methods\nJava ArrayList Methods\nJava LinkedList Methods\nJava HashMap Methods\nJava Scanner Methods\nJava Iterator Methods\nJava Errors & Exceptions\n\n\nJava Examples\nJava Examples\nJava Compiler\nJava Exercises\nJava Quiz\nJava Server\nJava Syllabus\nJava Study Plan\nJava Certificate\n\n\n\n\nJava OOP\n\u276e Previous\nNext \u276f\nJava - What is OOP?\n\nOOP stands for Object-Oriented Programming.\n\nProcedural programming is about writing procedures or methods that perform operations on the data, while object-oriented programming is about creating objects that contain both data and methods.\n\nObject-oriented programming has several advantages over procedural programming:\n\nOOP is faster and easier to execute\nOOP provides a clear structure for the programs\nOOP helps to keep the Java code DRY \"Don't Repeat Yourself\", and makes the code easier to maintain, modify and debug\nOOP makes it possible to create full reusable applications with less code and shorter development time\n\nTip: The \"Don't Repeat Yourself\" (DRY) principle is about reducing the repetition of code. You should extract out the codes that are common for the application, and place them at a single place and reuse them instead of repeating it.\n\nJava - What are Classes and Objects?\n\nClasses and objects are the two main aspects of object-oriented programming.\n\nLook at the following illustration to see the difference between class and objects:\n\nclass\n\nFruit\n\nobjects\n\nApple\n\nBanana\n\nMango\n\nAnother example:\n\nclass\n\nCar\n\nobjects\n\nVolvo\n\nAudi\n\nToyota\n\nSo, a class is a template for objects, and an object is an instance of a class.\n\nWhen the individual objects are created, they inherit all the variables and methods from the class.\n\nYou will learn much more about classes and objects in the next chapter.\n\n\u276e Previous\nNext \u276f\n\u00a0\nTrack your progress - it's free!\n\u00a0\nLog in\nSign Up\nCOLOR PICKER\n    \nPLUS\nSPACES\nGET CERTIFIED\nFOR TEACHERS\nFOR BUSINESS\nCONTACT US\nTop Tutorials\nHTML Tutorial\nCSS Tutorial\nJavaScript Tutorial\nHow To Tutorial\nSQL Tutorial\nPython Tutorial\nW3.CSS Tutorial\nBootstrap Tutorial\nPHP Tutorial\nJava Tutorial\nC++ Tutorial\njQuery Tutorial\n\nTop References\nHTML Reference\nCSS Reference\nJavaScript Reference\nSQL Reference\nPython Reference\nW3.CSS Reference\nBootstrap Reference\nPHP Reference\nHTML Colors\nJava Reference\nAngular Reference\njQuery Reference\n\nTop Examples\nHTML Examples\nCSS Examples\nJavaScript Examples\nHow To Examples\nSQL Examples\nPython Examples\nW3.CSS Examples\nBootstrap Examples\nPHP Examples\nJava Examples\nXML Examples\njQuery Examples\n\nGet Certified\nHTML Certificate\nCSS Certificate\nJavaScript Certificate\nFront End Certificate\nSQL Certificate\nPython Certificate\nPHP Certificate\njQuery Certificate\nJava Certificate\nC++ Certificate\nC# Certificate\nXML Certificate\n\n \uf30c \ue807 \ue806 \uf16d FORUM ABOUT ACADEMY\nW3Schools is optimized for learning and training. Examples might be simplified to improve reading and learning. Tutorials, references, and examples are constantly reviewed to avoid errors, but we cannot warrant full correctness of all content. While using W3Schools, you agree to have read and accepted our terms of use, cookie and privacy policy.\n\nCopyright 1999-2025 by Refsnes Data. All Rights Reserved. W3Schools is Powered by W3.CSS.\n\nTutorials \nExercises \nCertificates \nServices \nSearch field\n\ue80b\nLog in\nSign Up\n Get Certified\n For Teachers\n Spaces\n Plus\nHTML CSS JAVASCRIPT SQL PYTHON JAVA PHP HOW TO W3.CSS C C++ C# BOOTSTRAP REACT MYSQL JQUERY EXCEL XML DJANGO NUMPY PANDAS NODEJS DSA TYPESCRIPT ANGULAR GIT POSTGRESQL MONGODB ASP AI R GO KOTLIN SASS VUE GEN AI SCIPY CYBERSECURITY DATA SCIENCE \nPython Tutorial\nPython HOME\nPython Intro\nPython Get Started\nPython Syntax\nPython Comments\nPython Variables\nPython Data Types\nPython Numbers\nPython Casting\nPython Strings\nPython Booleans\nPython Operators\nPython Lists\nPython Tuples\nPython Sets\nPython Dictionaries\nPython If...Else\nPython While Loops\nPython For Loops\nPython Functions\nPython Lambda\nPython Arrays\nPython Classes/Objects\nPython Inheritance\nPython Iterators\nPython Polymorphism\nPython Scope\nPython Modules\nPython Dates\nPython Math\nPython JSON\nPython RegEx\nPython PIP\nPython Try...Except\nPython User Input\nPython String Formatting\n\n\nFile Handling\nPython File Handling\nPython Read Files\nPython Write/Create Files\nPython Delete Files\n\n\nPython Modules\nNumPy Tutorial\nPandas Tutorial\nSciPy Tutorial\nDjango Tutorial\n\n\nPython Matplotlib\nMatplotlib Intro\nMatplotlib Get Started\nMatplotlib Pyplot\nMatplotlib Plotting\nMatplotlib Markers\nMatplotlib Line\nMatplotlib Labels\nMatplotlib Grid\nMatplotlib Subplot\nMatplotlib Scatter\nMatplotlib Bars\nMatplotlib Histograms\nMatplotlib Pie Charts\n\n\nMachine Learning\nGetting Started\nMean Median Mode\nStandard Deviation\nPercentile\nData Distribution\nNormal Data Distribution\nScatter Plot\nLinear Regression\nPolynomial Regression\nMultiple Regression\nScale\nTrain/Test\nDecision Tree\nConfusion Matrix\nHierarchical Clustering\nLogistic Regression\nGrid Search\nCategorical Data\nK-means\nBootstrap Aggregation\nCross Validation\nAUC - ROC Curve\nK-nearest neighbors\n\n\nPython MySQL\nMySQL Get Started\nMySQL Create Database\nMySQL Create Table\nMySQL Insert\nMySQL Select\nMySQL Where\nMySQL Order By\nMySQL Delete\nMySQL Drop Table\nMySQL Update\nMySQL Limit\nMySQL Join\n\n\nPython MongoDB\nMongoDB Get Started\nMongoDB Create DB\nMongoDB Collection\nMongoDB Insert\nMongoDB Find\nMongoDB Query\nMongoDB Sort\nMongoDB Delete\nMongoDB Drop Collection\nMongoDB Update\nMongoDB Limit\n\n\nPython Reference\nPython Overview\nPython Built-in Functions\nPython String Methods\nPython List Methods\nPython Dictionary Methods\nPython Tuple Methods\nPython Set Methods\nPython File Methods\nPython Keywords\nPython Exceptions\nPython Glossary\n\n\nModule Reference\nRandom Module\nRequests Module\nStatistics Module\nMath Module\ncMath Module\n\n\nPython How To\nRemove List Duplicates\nReverse a String\nAdd Two Numbers\n\n\nPython Examples\nPython Examples\nPython Compiler\nPython Exercises\nPython Quiz\nPython Server\nPython Syllabus\nPython Study Plan\nPython Interview Q&A\nPython Bootcamp\nPython Certificate\nPython Training\n\n\n\nPython Inheritance\n\u276e Previous\nNext \u276f\nPython Inheritance\n\nInheritance allows us to define a class that inherits all the methods and properties from another class.\n\nParent class is the class being inherited from, also called base class.\n\nChild class is the class that inherits from another class, also called derived class.\n\nCreate a Parent Class\n\nAny class can be a parent class, so the syntax is the same as creating any other class:\n\nExample\nGet your own Python Server\n\nCreate a class named Person, with firstname and lastname properties, and a printname method:\n\nclass Person:\n\u00a0 def __init__(self, fname, lname):\n\u00a0\u00a0\u00a0 self.firstname = fname\n\u00a0\u00a0\u00a0 self.lastname = lname\n\n\u00a0 def printname(self):\n\u00a0\u00a0\u00a0 print(self.firstname, self.lastname)\n\n#Use the Person class to create an object, and then execute the printname method:\n\nx = Person(\"John\", \"Doe\")\nx.printname()\nTry it Yourself \u00bb\nCreate a Child Class\n\nTo create a class that inherits the functionality from another class, send the parent class as a parameter when creating the child class:\n\nExample\n\nCreate a class named Student, which will inherit the properties and methods from the Person class:\n\nclass Student(Person):\n\u00a0 pass\n\nNote: Use the pass keyword when you do not want to add any other properties or methods to the class.\n\nNow the Student class has the same properties and methods as the Person class.\n\nExample\n\nUse the Student class to create an object, and then execute the printname method:\n\nx = Student(\"Mike\", \"Olsen\")\nx.printname()\nTry it Yourself \u00bb\nAdd the __init__() Function\n\nSo far we have created a child class that inherits the properties and methods from its parent.\n\nWe want to add the __init__() function to the child class (instead of the pass keyword).\n\nNote: The __init__() function is called automatically every time the class is being used to create a new object.\n\nExample\n\nAdd the __init__() function to the Student class:\n\nclass Student(Person):\n\u00a0 def __init__(self, fname, lname):\n\u00a0\u00a0\u00a0 #add properties etc.\n\nWhen you add the __init__() function, the child class will no longer inherit the parent's __init__() function.\n\nNote: The child's __init__() function overrides the inheritance of the parent's __init__() function.\n\nTo keep the inheritance of the parent's __init__() function, add a call to the parent's __init__() function:\n\nExample\nclass Student(Person):\n\u00a0 def __init__(self, fname, lname):\n\u00a0\u00a0\u00a0 Person.__init__(self, fname, lname)\nTry it Yourself \u00bb\n\nNow we have successfully added the __init__() function, and kept the inheritance of the parent class, and we are ready to add functionality in the __init__() function.\n\nUse the super() Function\n\nPython also has a super() function that will make the child class inherit all the methods and properties from its parent:\n\nExample\nclass Student(Person):\n\u00a0 def __init__(self, fname, lname):\n\u00a0\u00a0\u00a0 super().__init__(fname, lname)\nTry it Yourself \u00bb\n\nBy using the super() function, you do not have to use the name of the parent element, it will automatically inherit the methods and properties from its parent.\n\nAdd Properties\nExample\n\nAdd a property called graduationyear to the Student class:\n\nclass Student(Person):\n\u00a0 def __init__(self, fname, lname):\n\u00a0\u00a0\u00a0 super().__init__(fname, lname)\n\u00a0\u00a0\u00a0 self.graduationyear = 2019\nTry it Yourself \u00bb\n\nIn the example below, the year 2019 should be a variable, and passed into the Student class when creating student objects. To do so, add another parameter in the __init__() function:\n\nExample\n\nAdd a year parameter, and pass the correct year when creating objects:\n\nclass Student(Person):\n\u00a0 def __init__(self, fname, lname, year):\n\u00a0\u00a0\u00a0 super().__init__(fname, lname)\n\u00a0\u00a0\u00a0 self.graduationyear = year\n\nx = Student(\"Mike\", \"Olsen\", 2019)\nTry it Yourself \u00bb\nAdd Methods\nExample\n\nAdd a method called welcome to the Student class:\n\nclass Student(Person):\n\u00a0 def __init__(self, fname, lname, year):\n\u00a0\u00a0\u00a0 super().__init__(fname, lname)\n\u00a0\u00a0\u00a0 self.graduationyear = year\n\n\u00a0 def welcome(self):\n\u00a0\u00a0\u00a0 print(\"Welcome\", self.firstname, self.lastname, \"to the class of\", self.graduationyear)\nTry it Yourself \u00bb\n\nIf you add a method in the child class with the same name as a function in the parent class, the inheritance of the parent method will be overridden.\n\n\u276e Previous\nNext \u276f\n\u00a0\nTrack your progress - it's free!\n\u00a0\nLog in\nSign Up\nCOLOR PICKER\n    \nPLUS\nSPACES\nGET CERTIFIED\nFOR TEACHERS\nFOR BUSINESS\nCONTACT US\nTop Tutorials\nHTML Tutorial\nCSS Tutorial\nJavaScript Tutorial\nHow To Tutorial\nSQL Tutorial\nPython Tutorial\nW3.CSS Tutorial\nBootstrap Tutorial\nPHP Tutorial\nJava Tutorial\nC++ Tutorial\njQuery Tutorial\n\nTop References\nHTML Reference\nCSS Reference\nJavaScript Reference\nSQL Reference\nPython Reference\nW3.CSS Reference\nBootstrap Reference\nPHP Reference\nHTML Colors\nJava Reference\nAngular Reference\njQuery Reference\n\nTop Examples\nHTML Examples\nCSS Examples\nJavaScript Examples\nHow To Examples\nSQL Examples\nPython Examples\nW3.CSS Examples\nBootstrap Examples\nPHP Examples\nJava Examples\nXML Examples\njQuery Examples\n\nGet Certified\nHTML Certificate\nCSS Certificate\nJavaScript Certificate\nFront End Certificate\nSQL Certificate\nPython Certificate\nPHP Certificate\njQuery Certificate\nJava Certificate\nC++ Certificate\nC# Certificate\nXML Certificate\n\n \uf30c \ue807 \ue806 \uf16d FORUM ABOUT ACADEMY\nW3Schools is optimized for learning and training. Examples might be simplified to improve reading and learning. Tutorials, references, and examples are constantly reviewed to avoid errors, but we cannot warrant full correctness of all content. While using W3Schools, you agree to have read and accepted our terms of use, cookie and privacy policy.\n\nCopyright 1999-2025 by Refsnes Data. All Rights Reserved. W3Schools is Powered by W3.CSS.\n\nSkip to content\nCourses\nTutorials\nDSA\nData Science\nWeb Tech\nPython Tutorial\nInterview Questions\nPython Quiz\nPython Projects\nPractice Python\nData Science With Python\nPython Web Dev\nDSA with Python\nPython OOPs\nLists\nStrings\nDictionary\nNext Article:\nMethod Overriding in Python\nInheritance in Python\nLast Updated : 26 Feb, 2025\n\nInheritance is a fundamental concept in object-oriented programming (OOP) that allows a class (called a child or derived class) to inherit attributes and methods from another class (called a parent or base class). This promotes code reuse, modularity, and a hierarchical class structure. In this article, we\u2019ll explore inheritance in Python.\n\nBasic Example of Inheritance\n\nInheritance allows us to define a class that inherits all the methods and properties from another class.\n\nPython\n# Parent class\nclass Animal:\n    def __init__(self, name):\n        self.name = name  # Initialize the name attribute\n\n    def speak(self):\n        pass  # Placeholder method to be overridden by child classes\n\n# Child class inheriting from Animal\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} barks!\"  # Override the speak method\n\n# Creating an instance of Dog\ndog = Dog(\"Buddy\")\nprint(dog.speak())  # Output: Buddy says Woof!\n\n\nOutput\nBuddy barks!\n\nExplanation:\nAnimal is the parent class with an __init__ method and a speak method.\nDog is the child class that inherits from Animal.\nThe speak method is overridden in the Dog class to provide specific behavior.\n\nLet\u2019s understand inheritance in detail:\n\nTable of Content\n\nSyntax for Inheritance\nExplanation of Python Inheritance Syntax\nCreating a Parent Class\nCreating a Child Class\n__init__() Function\nsuper() Function\nAdd Properties\nTypes of Python Inheritance\nSyntax for Inheritance\n\nclass ParentClass:\n\n\n\n\n    # Parent class code here\n\n\n\n\n    pass\n\n\n\n\nclass ChildClass(ParentClass):\n\n\n\n\n    # Child class code here\n\n\n\n\n    pass\n\n\n\nExplanation of Python Inheritance Syntax\nParent Class:\nThis is the base class from which other classes inherit.\nIt contains attributes and methods that the child class can reuse.\nChild Class:\nThis is the derived class that inherits from the parent class.\nThe syntax for inheritance is class ChildClass(ParentClass).\nThe child class automatically gets all attributes and methods of the parent class unless overridden.\nCreating a Parent Class\n\nIn object-oriented programming, a parent class (also known as a base class) defines common attributes and methods that can be inherited by other classes. These attributes and methods serve as the foundation for the child classes. By using inheritance, child classes can access and extend the functionality provided by the parent class.\n\nHere\u2019s an example where Person is the parent class:\n\nPython\n# A Python program to demonstrate inheritance\nclass Person(object):\n  \n  # Constructor\n  def __init__(self, name, id):\n    self.name = name\n    self.id = id\n\n  # To check if this person is an employee\n  def Display(self):\n    print(self.name, self.id)\n\n\n# Driver code\nemp = Person(\"Satyam\", 102) # An Object of Person\nemp.Display()\n\n\nOutput\nSatyam 102\n\n\nExplanation:\n\nThe Person class has two attributes: name and id. These are set when an object of the class is created.\nThe display method prints the name and id of the person.\nCreating a Child Class\n\nA child class (also known as a subclass) is a class that inherits properties and methods from its parent class. The child class can also introduce additional attributes and methods, or even override the ones inherited from the parent.\n\nIn this case, Emp is the child class that inherits from the Person class:\n\nPython\nclass Emp(Person):\n  \n  def Print(self):\n    print(\"Emp class called\")\n    \nEmp_details = Emp(\"Mayank\", 103)\n\n# calling parent class function\nEmp_details.Display()\n\n# Calling child class function\nEmp_details.Print()\n\n\nExplanation:\n\nEmp class inherits the name and id attributes and the display method from the Person class.\n__init__ method in Emp calls super().__init__(name, id) to invoke the constructor of the Person class and initialize the inherited attributes.\nEmp introduces an additional attribute, role, and also overrides the display method to print the role in addition to the name and id.\n__init__() Function\n\n__init__() function is a constructor method in Python. It initializes the object\u2019s state when the object is created. If the child class does not define its own __init__() method, it will automatically inherit the one from the parent class.\n\nIn the example above, the __init__() method in the Employee class ensures that both inherited and new attributes are properly initialized.\n\nPython\n# Parent Class: Person\nclass Person:\n    def __init__(self, name, idnumber):\n        self.name = name\n        self.idnumber = idnumber\n\n# Child Class: Employee\nclass Employee(Person):\n    def __init__(self, name, idnumber, salary, post):\n        super().__init__(name, idnumber)  # Calls Person's __init__()\n        self.salary = salary\n        self.post = post\n\n\nExplanation:\n\n__init__() method in Person initializes name and idnumber.\n__init__() method in Employee calls super().__init__(name, idnumber) to initialize the name and idnumber inherited from the Person class and adds salary and post.\nsuper() Function\n\nsuper() function is used to call the parent class\u2019s methods. In particular, it is commonly used in the child class\u2019s __init__() method to initialize inherited attributes. This way, the child class can leverage the functionality of the parent class.\n\nExample:\n\nPython\n# Parent Class: Person\nclass Person:\n    def __init__(self, name, idnumber):\n        self.name = name\n        self.idnumber = idnumber\n\n    def display(self):\n        print(self.name)\n        print(self.idnumber)\n\n# Child Class: Employee\nclass Employee(Person):\n    def __init__(self, name, idnumber, salary, post):\n        super().__init__(name, idnumber)  # Using super() to call Person's __init__()\n        self.salary = salary\n        self.post = post\n\n\nExplanation:\n\nThe super() function is used inside the __init__() method of Employee to call the constructor of Person and initialize the inherited attributes (name and idnumber).\nThis ensures that the parent class functionality is reused without needing to rewrite the code in the child class.\nAdd Properties\n\nOnce inheritance is established, both the parent and child classes can have their own properties. Properties are attributes that belong to a class and are used to store data.\n\nExample:\n\nPython\n# Parent Class: Person\nclass Person:\n    def __init__(self, name, idnumber):\n        self.name = name\n        self.idnumber = idnumber\n\n    def display(self):\n        print(self.name)\n        print(self.idnumber)\n\n# Child Class: Employee\nclass Employee(Person):\n    def __init__(self, name, idnumber, salary, post):\n        super().__init__(name, idnumber)\n        self.salary = salary\n        self.post = post\n\n\nExplanation:\n\nPerson class has properties name and idnumber.\nEmployee class adds properties salary and post.\nThe properties are initialized when an object is created, and they represent the specific data related to the Person and Employee.\nTypes of Python Inheritance\nSingle Inheritance: A child class inherits from one parent class.\nMultiple Inheritance: A child class inherits from more than one parent class.\nMultilevel Inheritance: A class is derived from a class which is also derived from another class.\nHierarchical Inheritance: Multiple classes inherit from a single parent class.\nHybrid Inheritance: A combination of more than one type of inheritance.\n\nExample:\n\nPython\n# 1. Single Inheritance\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\nclass Employee(Person):  # Employee inherits from Person\n    def __init__(self, name, salary):\n        super().__init__(name)\n        self.salary = salary\n\n# 2. Multiple Inheritance\nclass Job:\n    def __init__(self, salary):\n        self.salary = salary\n\nclass EmployeePersonJob(Employee, Job):  # Inherits from both Employee and Job\n    def __init__(self, name, salary):\n        Employee.__init__(self, name, salary)  # Initialize Employee\n        Job.__init__(self, salary)            # Initialize Job\n\n# 3. Multilevel Inheritance\nclass Manager(EmployeePersonJob):  # Inherits from EmployeePersonJob\n    def __init__(self, name, salary, department):\n        EmployeePersonJob.__init__(self, name, salary)  # Explicitly initialize EmployeePersonJob\n        self.department = department\n\n# 4. Hierarchical Inheritance\nclass AssistantManager(EmployeePersonJob):  # Inherits from EmployeePersonJob\n    def __init__(self, name, salary, team_size):\n        EmployeePersonJob.__init__(self, name, salary)  # Explicitly initialize EmployeePersonJob\n        self.team_size = team_size\n\n# 5. Hybrid Inheritance (Multiple + Multilevel)\nclass SeniorManager(Manager, AssistantManager):  # Inherits from both Manager and AssistantManager\n    def __init__(self, name, salary, department, team_size):\n        Manager.__init__(self, name, salary, department)        # Initialize Manager\n        AssistantManager.__init__(self, name, salary, team_size)  # Initialize AssistantManager\n\n# Creating objects to show inheritance\n\n# Single Inheritance\nemp = Employee(\"John\", 40000)\nprint(emp.name, emp.salary)\n\n# Multiple Inheritance\nemp2 = EmployeePersonJob(\"Alice\", 50000)\nprint(emp2.name, emp2.salary)\n\n# Multilevel Inheritance\nmgr = Manager(\"Bob\", 60000, \"HR\")\nprint(mgr.name, mgr.salary, mgr.department)\n\n# Hierarchical Inheritance\nasst_mgr = AssistantManager(\"Charlie\", 45000, 10)\nprint(asst_mgr.name, asst_mgr.salary, asst_mgr.team_size)\n\n# Hybrid Inheritance\nsen_mgr = SeniorManager(\"David\", 70000, \"Finance\", 20)\nprint(sen_mgr.name, sen_mgr.salary, sen_mgr.department, sen_mgr.team_size)\n\n\nOutput\nJohn 40000\nAlice 50000\nBob 60000 HR\nCharlie 45000 10\nDavid 70000 Finance 20\n\n\nExplanation:\n\nSingle Inheritance: Employee inherits from Person, adding a salary attribute.\nMultiple Inheritance: EmployeePersonJob inherits from both Employee and Job, allowing access to both name and salary.\nMultilevel Inheritance: Manager inherits from EmployeePersonJob, which already includes Employee and Job.\nHierarchical Inheritance: AssistantManager also inherits from EmployeePersonJob, demonstrating multiple child classes inheriting from the same parent.\nHybrid Inheritance: SeniorManager inherits from both Manager (multilevel) and AssistantManager (hierarchical), combining two inheritance types.\n\nFor more details please read this article: Types of inheritance in Python\n\n\n\n\n\nComment\nMore info\nAdvertise with us\nNext Article \nMethod Overriding in Python\nSimilar Reads\nPython OOPs Concepts\nObject Oriented Programming is a fundamental concept in Python, empowering developers to build modular, maintainable, and scalable applications. By understanding the core OOP principles (classes, objects, inheritance, encapsulation, polymorphism, and abstraction), programmers can leverage the full p\n11 min read\nPython Classes and Objects\nA class in Python is a user-defined template for creating objects. It bundles data and functions together, making it easier to manage and use them. When we create a new class, we define a new type of object. We can then create multiple instances of this object type. Classes are created using class k\n6 min read\nPython objects\nA class is a user-defined blueprint or prototype from which objects are created. Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to\n2 min read\nClass and Object\nEncapsulation and Access Modifiers\nInheritance\nInheritance in Python\nInheritance is a fundamental concept in object-oriented programming (OOP) that allows a class (called a child or derived class) to inherit attributes and methods from another class (called a parent or base class). This promotes code reuse, modularity, and a hierarchical class structure. In this arti\n7 min read\nMethod Overriding in Python\nMethod overriding is an ability of any object-oriented programming language that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes. When a method in a subclass has the same name, the same parameter\n7 min read\nOperator Overloading in Python\nOperator Overloading means giving extended meaning beyond their predefined operational meaning. For example operator + is used to add two integers as well as join two strings and merge two lists. It is achievable because '+' operator is overloaded by int class and str class. You might have noticed t\n9 min read\nPython super()\nIn Python, the super() function is used to refer to the parent class or superclass. It allows you to call methods defined in the superclass from the subclass, enabling you to extend and customize the functionality inherited from the parent class. Syntax of super() in PythonSyntax: super() Return : R\n8 min read\nMultiple Inheritance in Python\nInheritance is the mechanism to achieve the re-usability of code as one class(child class) can derive the properties of another class(parent class). It also provides transitivity ie. if class C inherits from P then all the sub-classes of C would also inherit from P. Multiple Inheritance When a class\n5 min read\nWhat Is Hybrid Inheritance In Python?\nInheritance is a fundamental concept in object-oriented programming (OOP) where a class can inherit attributes and methods from another class. Hybrid inheritance is a combination of more than one type of inheritance. In this article, we will learn about hybrid inheritance in Python. Hybrid Inheritan\n3 min read\nMultilevel Inheritance in Python\nPython is one of the most popular and widely used Programming Languages. Python is an Object Oriented Programming language which means it has features like Inheritance, Encapsulation, Polymorphism, and Abstraction. In this article, we are going to learn about Multilevel Inheritance in Python. Pre-Re\n3 min read\nMultilevel Inheritance in Python\nPython is one of the most popular and widely used Programming Languages. Python is an Object Oriented Programming language which means it has features like Inheritance, Encapsulation, Polymorphism, and Abstraction. In this article, we are going to learn about Multilevel Inheritance in Python. Pre-Re\n3 min read\nPolymorphism\nAbstraction\nSpecial Methods and Testing\nAdditional Resources\nCorporate & Communications Address:\nA-143, 7th Floor, Sovereign Corporate Tower, Sector- 136, Noida, Uttar Pradesh (201305)\nRegistered Address:\nK 061, Tower K, Gulshan Vivante Apartment, Sector 137, Noida, Gautam Buddh Nagar, Uttar Pradesh, 201305\nAdvertise with us\nCompany\nAbout Us\nLegal\nPrivacy Policy\nIn Media\nContact Us\nAdvertise with us\nGFG Corporate Solution\nPlacement Training Program\nGeeksforGeeks Community\nLanguages\nPython\nJava\nC++\nPHP\nGoLang\nSQL\nR Language\nAndroid Tutorial\nTutorials Archive\nDSA\nData Structures\nAlgorithms\nDSA for Beginners\nBasic DSA Problems\nDSA Roadmap\nTop 100 DSA Interview Problems\nDSA Roadmap by Sandeep Jain\nAll Cheat Sheets\nData Science & ML\nData Science With Python\nData Science For Beginner\nMachine Learning\nML Maths\nData Visualisation\nPandas\nNumPy\nNLP\nDeep Learning\nWeb Technologies\nHTML\nCSS\nJavaScript\nTypeScript\nReactJS\nNextJS\nBootstrap\nWeb Design\nPython Tutorial\nPython Programming Examples\nPython Projects\nPython Tkinter\nWeb Scraping\nOpenCV Tutorial\nPython Interview Question\nDjango\nComputer Science\nOperating Systems\nComputer Network\nDatabase Management System\nSoftware Engineering\nDigital Logic Design\nEngineering Maths\nSoftware Development\nSoftware Testing\nDevOps\nGit\nLinux\nAWS\nDocker\nKubernetes\nAzure\nGCP\nDevOps Roadmap\nSystem Design\nHigh Level Design\nLow Level Design\nUML Diagrams\nInterview Guide\nDesign Patterns\nOOAD\nSystem Design Bootcamp\nInterview Questions\nInteview Preparation\nCompetitive Programming\nTop DS or Algo for CP\nCompany-Wise Recruitment Process\nCompany-Wise Preparation\nAptitude Preparation\nPuzzles\nSchool Subjects\nMathematics\nPhysics\nChemistry\nBiology\nSocial Science\nEnglish Grammar\nCommerce\nWorld GK\nGeeksforGeeks Videos\nDSA\nPython\nJava\nC++\nWeb Development\nData Science\nCS Subjects\n@GeeksforGeeks, Sanchhaya Education Private Limited, All rights reserved\nWe use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy\nGot It !\n\nTutorials \nExercises \nCertificates \nServices \nSearch field\n\ue80b\nLog in\nSign Up\n Get Certified\n For Teachers\n Spaces\n Plus\nHTML CSS JAVASCRIPT SQL PYTHON JAVA PHP HOW TO W3.CSS C C++ C# BOOTSTRAP REACT MYSQL JQUERY EXCEL XML DJANGO NUMPY PANDAS NODEJS DSA TYPESCRIPT ANGULAR GIT POSTGRESQL MONGODB ASP AI R GO KOTLIN SASS VUE GEN AI SCIPY CYBERSECURITY DATA SCIENCE \nPython Tutorial\nPython HOME\nPython Intro\nPython Get Started\nPython Syntax\nPython Comments\nPython Variables\nPython Data Types\nPython Numbers\nPython Casting\nPython Strings\nPython Booleans\nPython Operators\nPython Lists\nPython Tuples\nPython Sets\nPython Dictionaries\nPython If...Else\nPython While Loops\nPython For Loops\nPython Functions\nPython Lambda\nPython Arrays\nPython Classes/Objects\nPython Inheritance\nPython Iterators\nPython Polymorphism\nPython Scope\nPython Modules\nPython Dates\nPython Math\nPython JSON\nPython RegEx\nPython PIP\nPython Try...Except\nPython User Input\nPython String Formatting\n\n\nFile Handling\nPython File Handling\nPython Read Files\nPython Write/Create Files\nPython Delete Files\n\n\nPython Modules\nNumPy Tutorial\nPandas Tutorial\nSciPy Tutorial\nDjango Tutorial\n\n\nPython Matplotlib\nMatplotlib Intro\nMatplotlib Get Started\nMatplotlib Pyplot\nMatplotlib Plotting\nMatplotlib Markers\nMatplotlib Line\nMatplotlib Labels\nMatplotlib Grid\nMatplotlib Subplot\nMatplotlib Scatter\nMatplotlib Bars\nMatplotlib Histograms\nMatplotlib Pie Charts\n\n\nMachine Learning\nGetting Started\nMean Median Mode\nStandard Deviation\nPercentile\nData Distribution\nNormal Data Distribution\nScatter Plot\nLinear Regression\nPolynomial Regression\nMultiple Regression\nScale\nTrain/Test\nDecision Tree\nConfusion Matrix\nHierarchical Clustering\nLogistic Regression\nGrid Search\nCategorical Data\nK-means\nBootstrap Aggregation\nCross Validation\nAUC - ROC Curve\nK-nearest neighbors\n\n\nPython MySQL\nMySQL Get Started\nMySQL Create Database\nMySQL Create Table\nMySQL Insert\nMySQL Select\nMySQL Where\nMySQL Order By\nMySQL Delete\nMySQL Drop Table\nMySQL Update\nMySQL Limit\nMySQL Join\n\n\nPython MongoDB\nMongoDB Get Started\nMongoDB Create DB\nMongoDB Collection\nMongoDB Insert\nMongoDB Find\nMongoDB Query\nMongoDB Sort\nMongoDB Delete\nMongoDB Drop Collection\nMongoDB Update\nMongoDB Limit\n\n\nPython Reference\nPython Overview\nPython Built-in Functions\nPython String Methods\nPython List Methods\nPython Dictionary Methods\nPython Tuple Methods\nPython Set Methods\nPython File Methods\nPython Keywords\nPython Exceptions\nPython Glossary\n\n\nModule Reference\nRandom Module\nRequests Module\nStatistics Module\nMath Module\ncMath Module\n\n\nPython How To\nRemove List Duplicates\nReverse a String\nAdd Two Numbers\n\n\nPython Examples\nPython Examples\nPython Compiler\nPython Exercises\nPython Quiz\nPython Server\nPython Syllabus\nPython Study Plan\nPython Interview Q&A\nPython Bootcamp\nPython Certificate\nPython Training\n\n\n\nPython Polymorphism\n\u276e Previous\nNext \u276f\n\nThe word \"polymorphism\" means \"many forms\", and in programming it refers to methods/functions/operators with the same name that can be executed on many objects or classes.\n\nFunction Polymorphism\n\nAn example of a Python function that can be used on different objects is the len() function.\n\nString\n\nFor strings len() returns the number of characters:\n\nExample\nGet your own Python Server\nx = \"Hello World!\"\n\nprint(len(x))\nTry it Yourself \u00bb\nTuple\n\nFor tuples len() returns the number of items in the tuple:\n\nExample\nmytuple = (\"apple\", \"banana\", \"cherry\")\n\nprint(len(mytuple))\nTry it Yourself \u00bb\nDictionary\n\nFor dictionaries len() returns the number of key/value pairs in the dictionary:\n\nExample\nthisdict = {\n\u00a0\u00a0\"brand\": \"Ford\",\n\u00a0\u00a0\"model\": \"Mustang\",\n\u00a0\u00a0\"year\": 1964\n}\n\nprint(len(thisdict))\nTry it Yourself \u00bb\nClass Polymorphism\n\nPolymorphism is often used in Class methods, where we can have multiple classes with the same method name.\n\nFor example, say we have three classes: Car, Boat, and Plane, and they all have a method called move():\n\nExample\n\nDifferent classes with the same method:\n\nclass Car:\n\u00a0\u00a0def __init__(self, brand, model):\n\u00a0\u00a0\u00a0\u00a0self.brand = brand\n\u00a0\u00a0\u00a0\u00a0self.model = model\n\n\u00a0\u00a0def move(self):\n\u00a0\u00a0\u00a0 print(\"Drive!\")\n\nclass Boat:\n\u00a0\u00a0def __init__(self, brand, model):\n\u00a0\u00a0\u00a0\u00a0self.brand = brand\n\u00a0\u00a0\u00a0\u00a0self.model = model\n\n\u00a0\u00a0def move(self):\n\u00a0\u00a0\u00a0\u00a0print(\"Sail!\")\n\nclass Plane:\n\u00a0\u00a0def __init__(self, brand, model):\n\u00a0\u00a0\u00a0\u00a0self.brand = brand\n\u00a0\u00a0\u00a0\u00a0self.model = model\n\n\u00a0\u00a0def move(self):\n\u00a0\u00a0\u00a0\u00a0print(\"Fly!\")\n\ncar1 = Car(\"Ford\", \"Mustang\") \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#Create a Car object\nboat1 = Boat(\"Ibiza\", \"Touring 20\") #Create a Boat object\nplane1 = Plane(\"Boeing\", \"747\") \u00a0\u00a0\u00a0\u00a0#Create a Plane object\n\nfor x in (car1, boat1, plane1):\n\u00a0\u00a0x.move()\n\nTry it Yourself \u00bb\n\nLook at the for loop at the end. Because of polymorphism we can execute the same method for all three classes.\n\nInheritance Class Polymorphism\n\nWhat about classes with child classes with the same name? Can we use polymorphism there?\n\nYes. If we use the example above and make a parent class called Vehicle, and make Car, Boat, Plane child classes of Vehicle, the child classes inherits the Vehicle methods, but can override them:\n\nExample\n\nCreate a class called Vehicle and make Car, Boat, Plane child classes of Vehicle:\n\nclass Vehicle:\n\u00a0 def __init__(self, brand, model):\n\u00a0\u00a0\u00a0 self.brand = brand\n\u00a0\u00a0\u00a0 self.model = model\n\n\u00a0 def move(self):\n\u00a0\u00a0\u00a0 print(\"Move!\")\n\nclass Car(Vehicle):\n\u00a0 pass\n\nclass Boat(Vehicle):\n\u00a0 def move(self):\n\u00a0\u00a0\u00a0 print(\"Sail!\")\n\nclass Plane(Vehicle):\n\u00a0 def move(self):\n\u00a0\u00a0\u00a0 print(\"Fly!\")\n\ncar1 = Car(\"Ford\", \"Mustang\")\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 #Create a Car object\nboat1 = Boat(\"Ibiza\", \"Touring 20\") #Create a Boat object\nplane1 = Plane(\"Boeing\", \"747\")\u00a0\u00a0\u00a0\u00a0 #Create a Plane object\n\nfor x in (car1, boat1, plane1):\n\u00a0 print(x.brand)\n\u00a0 print(x.model)\n\u00a0 x.move()\n\nTry it Yourself \u00bb\n\nChild classes inherits the properties and methods from the parent class.\n\nIn the example above you can see that the Car class is empty, but it inherits brand, model, and move() from Vehicle.\n\nThe Boat and Plane classes also inherit brand, model, and move() from Vehicle, but they both override the move() method.\n\nBecause of polymorphism we can execute the same method for all classes.\n\n\u276e Previous\nNext \u276f\n\u00a0\nTrack your progress - it's free!\n\u00a0\nLog in\nSign Up\nCOLOR PICKER\n    \nPLUS\nSPACES\nGET CERTIFIED\nFOR TEACHERS\nFOR BUSINESS\nCONTACT US\nTop Tutorials\nHTML Tutorial\nCSS Tutorial\nJavaScript Tutorial\nHow To Tutorial\nSQL Tutorial\nPython Tutorial\nW3.CSS Tutorial\nBootstrap Tutorial\nPHP Tutorial\nJava Tutorial\nC++ Tutorial\njQuery Tutorial\n\nTop References\nHTML Reference\nCSS Reference\nJavaScript Reference\nSQL Reference\nPython Reference\nW3.CSS Reference\nBootstrap Reference\nPHP Reference\nHTML Colors\nJava Reference\nAngular Reference\njQuery Reference\n\nTop Examples\nHTML Examples\nCSS Examples\nJavaScript Examples\nHow To Examples\nSQL Examples\nPython Examples\nW3.CSS Examples\nBootstrap Examples\nPHP Examples\nJava Examples\nXML Examples\njQuery Examples\n\nGet Certified\nHTML Certificate\nCSS Certificate\nJavaScript Certificate\nFront End Certificate\nSQL Certificate\nPython Certificate\nPHP Certificate\njQuery Certificate\nJava Certificate\nC++ Certificate\nC# Certificate\nXML Certificate\n\n \uf30c \ue807 \ue806 \uf16d FORUM ABOUT ACADEMY\nW3Schools is optimized for learning and training. Examples might be simplified to improve reading and learning. Tutorials, references, and examples are constantly reviewed to avoid errors, but we cannot warrant full correctness of all content. While using W3Schools, you agree to have read and accepted our terms of use, cookie and privacy policy.\n\nCopyright 1999-2025 by Refsnes Data. All Rights Reserved. W3Schools is Powered by W3.CSS.\n\nLearn to code solving problems and writing code with our hands-on Python course. Try Programiz PRO today.\nTutorials\nExamples\nCourses\n\nTry\nProgramiz PRO\n\nPython Introduction\nGet Started With Python\nYour First Python Program\nPython Comments\nPython Fundamentals\nPython Variables and Literals\nPython Type Conversion\nPython Basic Input and Output\nPython Operators\nPython Flow Control\nPython if...else Statement\nPython for Loop\nPython while Loop\nPython break and continue\nPython pass Statement\nPython Data types\nPython Numbers and Mathematics\nPython List\nPython Tuple\nPython String\nPython Set\nPython Dictionary\nPython Functions\nPython Functions\nPython Function Arguments\nPython Variable Scope\nPython Global Keyword\nPython Recursion\nPython Modules\nPython Package\nPython Main function\nPython Files\nPython Directory and Files Management\nPython CSV: Read and Write CSV files\nReading CSV files in Python\nWriting CSV files in Python\nPython Exception Handling\nPython Exceptions\nPython Exception Handling\nPython Custom Exceptions\nPython Object & Class\nPython Objects and Classes\nPython Inheritance\nPython Multiple Inheritance\nPolymorphism in Python\nPython Operator Overloading\nPython Advanced Topics\nList comprehension\nPython Lambda/Anonymous Function\nPython Iterators\nPython Generators\nPython Namespace and Scope\nPython Closures\nPython Decorators\nPython @property decorator\nPython RegEx\nPython Date and Time\nPython datetime\nPython strftime()\nPython strptime()\nHow to get current date and time in Python?\nPython Get Current Time\nPython timestamp to datetime and vice-versa\nPython time Module\nPython sleep()\nAdditional Topic\nPrecedence and Associativity of Operators in Python\nPython Keywords and Identifiers\nPython Asserts\nPython Json\nPython pip\nPython *args and **kwargs\nPython Tutorials\nPython Object Oriented Programming\nPython Multiple Inheritance\nPython Classes and Objects\nPython Inheritance\nPython super()\nPython Data Types\nPolymorphism in Python\nWhat is Polymorphism?\n\nThe literal meaning of polymorphism is the condition of occurrence in different forms.\n\nPolymorphism is a very important concept in programming. It refers to the use of a single type entity (method, operator or object) to represent different types in different scenarios.\n\nLet's take an example:\n\nExample 1: Polymorphism in addition operator\n\nWe know that the + operator is used extensively in Python programs. But, it does not have a single usage.\n\nFor integer data types, + operator is used to perform arithmetic addition operation.\n\nnum1 = 1\nnum2 = 2\nprint(num1+num2)\n\nRun Code\n\nHence, the above program outputs 3.\n\nSimilarly, for string data types, + operator is used to perform concatenation.\n\nstr1 = \"Python\"\nstr2 = \"Programming\"\nprint(str1+\" \"+str2)\n\nRun Code\n\nAs a result, the above program outputs Python Programming.\n\nHere, we can see that a single operator + has been used to carry out different operations for distinct data types. This is one of the most simple occurrences of polymorphism in Python.\n\nFunction Polymorphism in Python\n\nThere are some functions in Python which are compatible to run with multiple data types.\n\nOne such function is the len() function. It can run with many data types in Python. Let's look at some example use cases of the function.\n\nExample 2: Polymorphic len() function\nprint(len(\"Programiz\"))\nprint(len([\"Python\", \"Java\", \"C\"]))\nprint(len({\"Name\": \"John\", \"Address\": \"Nepal\"}))\n\nRun Code\n\nOutput\n\n9\n3\n2\n\n\nHere, we can see that many data types such as string, list, tuple, set, and dictionary can work with the len() function. However, we can see that it returns specific information about specific data types.\n\nPolymorphism in len() function in Python\nClass Polymorphism in Python\n\nPolymorphism is a very important concept in Object-Oriented Programming.\n\nTo learn more about OOP in Python, visit: Python Object-Oriented Programming\n\nWe can use the concept of polymorphism while creating class methods as Python allows different classes to have methods with the same name.\n\nWe can then later generalize calling these methods by disregarding the object we are working with. Let's look at an example:\n\nExample 3: Polymorphism in Class Methods\nclass Cat:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def info(self):\n        print(f\"I am a cat. My name is {self.name}. I am {self.age} years old.\")\n\n    def make_sound(self):\n        print(\"Meow\")\n\n\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def info(self):\n        print(f\"I am a dog. My name is {self.name}. I am {self.age} years old.\")\n\n    def make_sound(self):\n        print(\"Bark\")\n\n\ncat1 = Cat(\"Kitty\", 2.5)\ndog1 = Dog(\"Fluffy\", 4)\n\nfor animal in (cat1, dog1):\n    animal.make_sound()\n    animal.info()\n    animal.make_sound()\n\nRun Code\n\nOutput\n\nMeow\nI am a cat. My name is Kitty. I am 2.5 years old.\nMeow\nBark\nI am a dog. My name is Fluffy. I am 4 years old.\nBark\n\n\nHere, we have created two classes Cat and Dog. They share a similar structure and have the same method names info() and make_sound().\n\nHowever, notice that we have not created a common superclass or linked the classes together in any way. Even then, we can pack these two different objects into a tuple and iterate through it using a common animal variable. It is possible due to polymorphism.\n\nPolymorphism and Inheritance\n\nLike in other programming languages, the child classes in Python also inherit methods and attributes from the parent class. We can redefine certain methods and attributes specifically to fit the child class, which is known as Method Overriding.\n\nPolymorphism allows us to access these overridden methods and attributes that have the same name as the parent class.\n\nLet's look at an example:\n\nExample 4: Method Overriding\nfrom math import pi\n\n\nclass Shape:\n    def __init__(self, name):\n        self.name = name\n\n    def area(self):\n        pass\n\n    def fact(self):\n        return \"I am a two-dimensional shape.\"\n\n    def __str__(self):\n        return self.name\n\n\nclass Square(Shape):\n    def __init__(self, length):\n        super().__init__(\"Square\")\n        self.length = length\n\n    def area(self):\n        return self.length**2\n\n    def fact(self):\n        return \"Squares have each angle equal to 90 degrees.\"\n\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        super().__init__(\"Circle\")\n        self.radius = radius\n\n    def area(self):\n        return pi*self.radius**2\n\n\na = Square(4)\nb = Circle(7)\nprint(b)\nprint(b.fact())\nprint(a.fact())\nprint(b.area())\n\nRun Code\n\nOutput\n\nCircle\nI am a two-dimensional shape.\nSquares have each angle equal to 90 degrees.\n153.93804002589985\n\n\nHere, we can see that the methods such as __str__(), which have not been overridden in the child classes, are used from the parent class.\n\nDue to polymorphism, the Python interpreter automatically recognizes that the fact() method for object a(Square class) is overridden. So, it uses the one defined in the child class.\n\nOn the other hand, since the fact() method for object b isn't overridden, it is used from the Parent Shape class.\n\nPolymorphism in parent and child classes in Python\n\nNote: Method Overloading, a way to create multiple methods with the same name but different arguments, is not possible in Python.\n\nAlso Read:\n\nPython Inheritance\nPrevious Tutorial:\nPython Multiple Inheritance\nNext Tutorial:\nPython Operator Overloading\nShare on:\nDid you find this article helpful?\n\nOur premium learning platform, created with over a decade of experience and thousands of feedbacks.\n\nLearn and improve your coding skills like never before.\n\nTry Programiz PRO\n Interactive Courses\n Certificates\n AI Help\n 2000+ Challenges\nRelated Tutorials\n\nPython Tutorial\n\nPython Object Oriented Programming\n\nPython Tutorial\n\nPython Multiple Inheritance\n\nPython Tutorial\n\nPython Inheritance\n\nPython Tutorial\n\nPython Classes and Objects\n\nFree Tutorials\nPython 3 Tutorials\nSQL Tutorials\nR Tutorials\nHTML Tutorials\nCSS Tutorials\nJavaScript Tutorials\nJava Tutorials\nC Tutorials\nC++ Tutorials\nDSA Tutorials\nC# Tutorials\nGolang Tutorials\nKotlin Tutorials\nSwift Tutorials\nRust Tutorials\nPaid Courses\nMaster Python\nLearn SQL\nLearn HTML FREE\nMaster JavaScript\nMaster C\nMaster C++\nMaster Java\nMaster DSA with Python\nOnline Compilers\nPython Compiler\nR Compiler\nSQL Editor\nHTML/CSS Editor\nJavaScript Editor\nJava Compiler\nC Compiler\nC++ Compiler\nC# Compiler\nGo Compiler\nPHP Compiler\nSwift Compiler\nRust Compiler\nMobile Apps\nLearn Python App\nLearn C App\nLearn Java App\nLearn C++ App\nCompany\nAbout\nContact\nBlog\nYoutube\nCareers\nAdvertising\nPrivacy Policy\nTerms & Conditions\n\n\u00a9 Parewa Labs Pvt. Ltd. All rights reserved.\n\nwww.datacamp.com\n\nVerifying you are human. This may take a few seconds.\n\nwww.datacamp.com needs to review the security of your connection before proceeding.\nRay ID: 91ed75a11cf09077\nPerformance & security by Cloudflare\n\nStart\u00a0Here\n Learn Python \nMore \n/\nJoin\nSign\u2011In\n\n\u2014 FREE Email Series \u2014\n\n\ud83d\udc0d Python Tricks \ud83d\udc8c\n\nGet Python Tricks \u00bb\n\n\ud83d\udd12 No spam. Unsubscribe any time.\n\nBrowse Topics \nGuided Learning Paths\n\n Basics \n Intermediate \n Advanced\napi best-practices career community databases data-science data-structures data-viz devops django docker editors flask front-end gamedev gui machine-learning numpy projects python testing tools web-dev web-scraping\n\nTable of Contents\n\nWhat Is Object-Oriented Programming in Python?\nHow Do You Define a Class in Python?\nHow Do You Instantiate a Class in Python?\nHow Do You Inherit From Another Class in Python?\nConclusion\nFrequently Asked Questions\nMark as Completed\nShare\n\n Recommended Video Course\nIntro to Object-Oriented Programming (OOP) in Python\n\nObject-Oriented Programming (OOP) in Python\nby David Amos \n Dec 15, 2024 \n intermediate python\nMark as Completed\nShare\n\nTable of Contents\n\nWhat Is Object-Oriented Programming in Python?\nHow Do You Define a Class in Python?\nClasses vs Instances\nClass Definition\nHow Do You Instantiate a Class in Python?\nClass and Instance Attributes\nInstance Methods\nHow Do You Inherit From Another Class in Python?\nExample: Dog Park\nParent Classes vs Child Classes\nParent Class Functionality Extension\nConclusion\nFrequently Asked Questions\nRemove ads\n\n Watch Now This tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding: Intro to Object-Oriented Programming (OOP) in Python\n\nObject-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build systems that are more reusable and scalable.\n\nBy the end of this tutorial, you\u2019ll understand that:\n\nObject-oriented programming in Python involves creating classes as blueprints for objects. These objects contain data and the methods needed to manipulate that data.\nThe four key concepts of OOP in Python are encapsulation, inheritance, abstraction, and polymorphism.\nYou create an object in Python by instantiating a class, which involves calling the class name followed by parentheses.\nClass inheritance in Python allows a class to inherit attributes and methods from another class, known as the parent class.\nYou use super() in Python to call a method from the parent class, allowing you to extend or modify inherited behavior.\n\nYou\u2019ll explore how to define classes, instantiate classes to create objects, and leverage inheritance to build robust systems in Python.\n\nNote: This tutorial is adapted from the chapter \u201cObject-Oriented Programming (OOP)\u201d in Python Basics: A Practical Introduction to Python 3.\n\nThe book uses Python\u2019s built-in IDLE editor to create and edit Python files and interact with the Python shell, so you\u2019ll see occasional references to IDLE throughout this tutorial. If you don\u2019t use IDLE, you can run the example code from the editor and environment of your choice.\n\nGet Your Code: Click here to download the free sample code that shows you how to do object-oriented programming with classes in Python 3.\n\n Take the Quiz: Test your knowledge with our interactive \u201cObject-Oriented Programming (OOP) in Python\u201d quiz. You\u2019ll receive a score upon completion to help you track your learning progress:\n\nInteractive Quiz\n\nObject-Oriented Programming (OOP) in Python\n\nObject-oriented programming (OOP) is a method of structuring a program by bundling related properties and behaviors into individual objects.\n\nWhat Is Object-Oriented Programming in Python?\n\nObject-oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.\n\nFor example, an object could represent a person with properties like a name, age, and address and behaviors such as walking, talking, breathing, and running. Or it could represent an email with properties like a recipient list, subject, and body and behaviors like adding attachments and sending.\n\nPut another way, object-oriented programming is an approach for modeling concrete, real-world things, like cars, as well as relations between things, like companies and employees or students and teachers. OOP models real-world entities as software objects that have some data associated with them and can perform certain operations.\n\nOOP also exists in other programming languages and is often described to center around the four pillars, or four tenants of OOP:\n\nEncapsulation allows you to bundle data (attributes) and behaviors (methods) within a class to create a cohesive unit. By defining methods to control access to attributes and its modification, encapsulation helps maintain data integrity and promotes modular, secure code.\n\nInheritance enables the creation of hierarchical relationships between classes, allowing a subclass to inherit attributes and methods from a parent class. This promotes code reuse and reduces duplication.\n\nAbstraction focuses on hiding implementation details and exposing only the essential functionality of an object. By enforcing a consistent interface, abstraction simplifies interactions with objects, allowing developers to focus on what an object does rather than how it achieves its functionality.\n\nPolymorphism allows you to treat objects of different types as instances of the same base type, as long as they implement a common interface or behavior. Python\u2019s duck typing make it especially suited for polymorphism, as it allows you to access attributes and methods on objects without needing to worry about their actual class.\n\nIn this tutorial you\u2019ll take a practical approach to understanding OOP in Python. But keeping these four concepts of object-oriented programming in mind may help you to remember the information that you gather.\n\nThe key takeaway is that objects are at the center of object-oriented programming in Python. In other programming paradigms, objects only represent the data. In OOP, they additionally inform the overall structure of the program.\n\nRemove ads\nHow Do You Define a Class in Python?\n\nIn Python, you define a class by using the class keyword followed by a name and a colon. Then you use .__init__() to declare which attributes each instance of the class should have:\n\nPython\nclass Employee:\n    def __init__(self, name, age):\n        self.name =  name\n        self.age = age\n\n\nBut what does all of that mean? And why do you even need classes in the first place? Take a step back and consider using built-in, primitive data structures as an alternative.\n\nPrimitive data structures\u2014like numbers, strings, and lists\u2014are designed to represent straightforward pieces of information, such as the cost of an apple, the name of a poem, or your favorite colors, respectively. What if you want to represent something more complex?\n\nFor example, you might want to track employees in an organization. You need to store some basic information about each employee, such as their name, age, position, and the year they started working.\n\nOne way to do this is to represent each employee as a list:\n\nPython\nkirk = [\"James Kirk\", 34, \"Captain\", 2265]\nspock = [\"Spock\", 35, \"Science Officer\", 2254]\nmccoy = [\"Leonard McCoy\", \"Chief Medical Officer\", 2266]\n\n\nThere are a number of issues with this approach.\n\nFirst, it can make larger code files more difficult to manage. If you reference kirk[0] several lines away from where you declared the kirk list, will you remember that the element with index 0 is the employee\u2019s name?\n\nSecond, it can introduce errors if employees don\u2019t have the same number of elements in their respective lists. In the mccoy list above, the age is missing, so mccoy[1] will return \"Chief Medical Officer\" instead of Dr. McCoy\u2019s age.\n\nA great way to make this type of code more manageable and more maintainable is to use classes.\n\nClasses vs Instances\n\nClasses allow you to create user-defined data structures. Classes define functions called methods, which identify the behaviors and actions that an object created from the class can perform with its data.\n\nIn this tutorial, you\u2019ll create a Dog class that stores some information about the characteristics and behaviors that an individual dog can have.\n\nA class is a blueprint for how to define something. It doesn\u2019t actually contain any data. The Dog class specifies that a name and an age are necessary for defining a dog, but it doesn\u2019t contain the name or age of any specific dog.\n\nWhile the class is the blueprint, an instance is an object that\u2019s built from a class and contains real data. An instance of the Dog class is not a blueprint anymore. It\u2019s an actual dog with a name, like Miles, who\u2019s four years old.\n\nPut another way, a class is like a form or questionnaire. An instance is like a form that you\u2019ve filled out with information. Just like many people can fill out the same form with their own unique information, you can create many instances from a single class.\n\nClass Definition\n\nYou start all class definitions with the class keyword, then add the name of the class and a colon. Python will consider any code that you indent below the class definition as part of the class\u2019s body.\n\nHere\u2019s an example of a Dog class:\n\nPython\ndog.py\nclass Dog:\n    pass\n\n\nThe body of the Dog class consists of a single statement: the pass keyword. Python programmers often use pass as a placeholder indicating where code will eventually go. It allows you to run this code without Python throwing an error.\n\nNote: Python class names are written in CapitalizedWords notation by convention. For example, a class for a specific breed of dog, like the Jack Russell Terrier, would be written as JackRussellTerrier.\n\nThe Dog class isn\u2019t very interesting right now, so you\u2019ll spruce it up a bit by defining some properties that all Dog objects should have. There are several properties that you can choose from, including name, age, coat color, and breed. To keep the example small in scope, you\u2019ll just use name and age.\n\nYou define the properties that all Dog objects must have in a method called .__init__(). Every time you create a new Dog object, .__init__() sets the initial state of the object by assigning the values of the object\u2019s properties. That is, .__init__() initializes each new instance of the class.\n\nYou can give .__init__() any number of parameters, but the first parameter will always be a variable called self. When you create a new class instance, then Python automatically passes the instance to the self parameter in .__init__() so that Python can define the new attributes on the object.\n\nUpdate the Dog class with an .__init__() method that creates .name and .age attributes:\n\nPython\ndog.py\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n\nMake sure that you indent the .__init__() method\u2019s signature by four spaces, and the body of the method by eight spaces. This indentation is vitally important. It tells Python that the .__init__() method belongs to the Dog class.\n\nIn the body of .__init__(), there are two statements using the self variable:\n\nself.name = name creates an attribute called name and assigns the value of the name parameter to it.\nself.age = age creates an attribute called age and assigns the value of the age parameter to it.\n\nAttributes created in .__init__() are called instance attributes. An instance attribute\u2019s value is specific to a particular instance of the class. All Dog objects have a name and an age, but the values for the name and age attributes will vary depending on the Dog instance.\n\nOn the other hand, class attributes are attributes that have the same value for all class instances. You can define a class attribute by assigning a value to a variable name outside of .__init__().\n\nFor example, the following Dog class has a class attribute called species with the value \"Canis familiaris\":\n\nPython\ndog.py\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n\nYou define class attributes directly beneath the first line of the class name and indent them by four spaces. You always need to assign them an initial value. When you create an instance of the class, then Python automatically creates and assigns class attributes to their initial values.\n\nUse class attributes to define properties that should have the same value for every class instance. Use instance attributes for properties that vary from one instance to another.\n\nNow that you have a Dog class, it\u2019s time to create some dogs!\n\nRemove ads\nHow Do You Instantiate a Class in Python?\n\nCreating a new object from a class is called instantiating a class. You can create a new object by typing the name of the class, followed by opening and closing parentheses:\n\nPython\n>>> class Dog:\n...     pass\n...\n>>> Dog()\n<__main__.Dog object at 0x106702d30>\n\n\nYou first create a new Dog class with no attributes or methods, and then you instantiate the Dog class to create a Dog object.\n\nIn the output above, you can see that you now have a new Dog object at 0x106702d30. This funny-looking string of letters and numbers is a memory address that indicates where Python stores the Dog object in your computer\u2019s memory. Note that the address on your screen will be different.\n\nNow instantiate the Dog class a second time to create another Dog object:\n\nPython\n>>> Dog()\n<__main__.Dog object at 0x0004ccc90>\n\n\nThe new Dog instance is located at a different memory address. That\u2019s because it\u2019s an entirely new instance and is completely unique from the first Dog object that you created.\n\nTo see this another way, type the following:\n\nPython\n>>> a = Dog()\n>>> b = Dog()\n>>> a == b\nFalse\n\n\nIn this code, you create two new Dog objects and assign them to the variables a and b. When you compare a and b using the == operator, the result is False. Even though a and b are both instances of the Dog class, they represent two distinct objects in memory.\n\nClass and Instance Attributes\n\nNow create a new Dog class with a class attribute called .species and two instance attributes called .name and .age:\n\nPython\n>>> class Dog:\n...     species = \"Canis familiaris\"\n...     def __init__(self, name, age):\n...         self.name = name\n...         self.age = age\n...\n\n\nTo instantiate this Dog class, you need to provide values for name and age. If you don\u2019t, then Python raises a TypeError:\n\nPython\n>>> Dog()\nTraceback (most recent call last):\n  ...\nTypeError: __init__() missing 2 required positional arguments: 'name' and 'age'\n\n\nTo pass arguments to the name and age parameters, put values into the parentheses after the class name:\n\nPython\n>>> miles = Dog(\"Miles\", 4)\n>>> buddy = Dog(\"Buddy\", 9)\n\n\nThis creates two new Dog instances\u2014one for a four-year-old dog named Miles and one for a nine-year-old dog named Buddy.\n\nThe Dog class\u2019s .__init__() method has three parameters, so why are you only passing two arguments to it in the example?\n\nWhen you instantiate the Dog class, Python creates a new instance of Dog and passes it to the first parameter of .__init__(). This essentially removes the self parameter, so you only need to worry about the name and age parameters.\n\nNote: Behind the scenes, Python both creates and initializes a new object when you use this syntax. If you want to dive deeper, then you can read the dedicated tutorial about the Python class constructor.\n\nAfter you create the Dog instances, you can access their instance attributes using dot notation:\n\nPython\n>>> miles.name\n'Miles'\n>>> miles.age\n4\n\n>>> buddy.name\n'Buddy'\n>>> buddy.age\n9\n\n\nYou can access class attributes the same way:\n\nPython\n>>> buddy.species\n'Canis familiaris'\n\n\nOne of the biggest advantages of using classes to organize data is that instances are guaranteed to have the attributes you expect. All Dog instances have .species, .name, and .age attributes, so you can use those attributes with confidence, knowing that they\u2019ll always return a value.\n\nAlthough the attributes are guaranteed to exist, their values can change dynamically:\n\nPython\n>>> buddy.age = 10\n>>> buddy.age\n10\n\n>>> miles.species = \"Felis silvestris\"\n>>> miles.species\n'Felis silvestris'\n\n\nIn this example, you change the .age attribute of the buddy object to 10. Then you change the .species attribute of the miles object to \"Felis silvestris\", which is a species of cat. That makes Miles a pretty strange dog, but it\u2019s valid Python!\n\nThe key takeaway here is that custom objects are mutable by default. An object is mutable if you can alter it dynamically. For example, lists and dictionaries are mutable, but strings and tuples are immutable.\n\nRemove ads\nInstance Methods\n\nInstance methods are functions that you define inside a class and can only call on an instance of that class. Just like .__init__(), an instance method always takes self as its first parameter.\n\nOpen a new editor window in IDLE and type in the following Dog class:\n\nPython\ndog.py\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    # Instance method\n    def description(self):\n        return f\"{self.name} is {self.age} years old\"\n\n    # Another instance method\n    def speak(self, sound):\n        return f\"{self.name} says {sound}\"\n\n\nThis Dog class has two instance methods:\n\n.description() returns a string displaying the name and age of the dog.\n.speak() has one parameter called sound and returns a string containing the dog\u2019s name and the sound that the dog makes.\n\nSave the modified Dog class to a file called dog.py and press F5 to run the program. Then open the interactive window and type the following to see your instance methods in action:\n\nPython\n>>> miles = Dog(\"Miles\", 4)\n\n>>> miles.description()\n'Miles is 4 years old'\n\n>>> miles.speak(\"Woof Woof\")\n'Miles says Woof Woof'\n\n>>> miles.speak(\"Bow Wow\")\n'Miles says Bow Wow'\n\n\nIn the above Dog class, .description() returns a string containing information about the Dog instance miles. When writing your own classes, it\u2019s a good idea to have a method that returns a string containing useful information about an instance of the class. However, .description() isn\u2019t the most Pythonic way of doing this.\n\nWhen you create a list object, you can use print() to display a string that looks like the list:\n\nPython\n>>> names = [\"Miles\", \"Buddy\", \"Jack\"]\n>>> print(names)\n['Miles', 'Buddy', 'Jack']\n\n\nGo ahead and print the miles object to see what output you get:\n\nPython\n>>> print(miles)\n<__main__.Dog object at 0x00aeff70>\n\n\nWhen you print miles, you get a cryptic-looking message telling you that miles is a Dog object at the memory address 0x00aeff70. This message isn\u2019t very helpful. You can change what gets printed by defining a special instance method called .__str__().\n\nIn the editor window, change the name of the Dog class\u2019s .description() method to .__str__():\n\nPython\ndog.py\nclass Dog:\n    # ...\n\n    def __str__(self):\n        return f\"{self.name} is {self.age} years old\"\n\n\nSave the file and press F5. Now, when you print miles, you get a much friendlier output:\n\nPython\n>>> miles = Dog(\"Miles\", 4)\n>>> print(miles)\n'Miles is 4 years old'\n\n\nMethods like .__init__() and .__str__() are called dunder methods because they begin and end with double underscores. There are many dunder methods that you can use to customize classes in Python. Understanding dunder methods is an important part of mastering object-oriented programming in Python, but for your first exploration of the topic, you\u2019ll stick with these two dunder methods.\n\nNote: Check out When Should You Use .__repr__() vs .__str__() in Python? to learn more about .__str__() and its cousin .__repr__().\n\nIf you want to reinforce your understanding with a practical exercise, then you can click on the block below and work on solving the challenge:\n\nExercise: Create a Car Class\nShow/Hide\n\nWhen you\u2019re done with your own implementation of the challenge, then you can expand the block below to see a possible solution:\n\nSolution: Create a Car Class\nShow/Hide\n\nWhen you\u2019re ready, you can move on to the next section. There, you\u2019ll see how to take your knowledge one step further and create classes from other classes.\n\nRemove ads\nHow Do You Inherit From Another Class in Python?\n\nInheritance is the process by which one class takes on the attributes and methods of another. Newly formed classes are called child classes, and the classes that you derive child classes from are called parent classes.\n\nYou inherit from a parent class by creating a new class and putting the name of the parent class into parentheses:\n\nPython\ninheritance.py\nclass Parent:\n    hair_color = \"brown\"\n\nclass Child(Parent):\n    pass\n\n\nIn this minimal example, the child class Child inherits from the parent class Parent. Because child classes take on the attributes and methods of parent classes, Child.hair_color is also \"brown\" without your explicitly defining that.\n\nNote: This tutorial is adapted from the chapter \u201cObject-Oriented Programming (OOP)\u201d in Python Basics: A Practical Introduction to Python 3. If you enjoy what you\u2019re reading, then be sure to check out the rest of the book and the learning path.\n\nYou can also check out the Python Basics: Building Systems With Classes video course to reinforce the skills that you\u2019ll develop in this section of the tutorial.\n\nChild classes can override or extend the attributes and methods of parent classes. In other words, child classes inherit all of the parent\u2019s attributes and methods but can also specify attributes and methods that are unique to themselves.\n\nAlthough the analogy isn\u2019t perfect, you can think of object inheritance sort of like genetic inheritance.\n\nYou may have inherited your hair color from your parents. It\u2019s an attribute that you were born with. But maybe you decide to color your hair purple. Assuming that your parents don\u2019t have purple hair, you\u2019ve just overridden the hair color attribute that you inherited from your parents:\n\nPython\ninheritance.py\nclass Parent:\n    hair_color = \"brown\"\n\nclass Child(Parent):\n    hair_color = \"purple\"\n\n\nIf you change the code example like this, then Child.hair_color will be \"purple\".\n\nYou also inherit, in a sense, your language from your parents. If your parents speak English, then you\u2019ll also speak English. Now imagine you decide to learn a second language, like German. In this case, you\u2019ve extended your attributes because you\u2019ve added an attribute that your parents don\u2019t have:\n\nPython\ninheritance.py\nclass Parent:\n    speaks = [\"English\"]\n\nclass Child(Parent):\n    def __init__(self):\n        super().__init__()\n        self.speaks.append(\"German\")\n\n\nYou\u2019ll learn more about how the code above works in the sections below. But before you dive deeper into inheritance in Python, you\u2019ll take a walk to a dog park to better understand why you might want to use inheritance in your own code.\n\nExample: Dog Park\n\nPretend for a moment that you\u2019re at a dog park. There are many dogs of different breeds at the park, all engaging in various dog behaviors.\n\nSuppose now that you want to model the dog park with Python classes. The Dog class that you wrote in the previous section can distinguish dogs by name and age but not by breed.\n\nYou could modify the Dog class in the editor window by adding a .breed attribute:\n\nPython\ndog.py\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age, breed):\n        self.name = name\n        self.age = age\n        self.breed = breed\n\n    def __str__(self):\n        return f\"{self.name} is {self.age} years old\"\n\n    def speak(self, sound):\n        return f\"{self.name} says {sound}\"\n\n\nPress F5 to save the file. Now you can model the dog park by creating a bunch of different dogs in the interactive window:\n\nPython\n>>> miles = Dog(\"Miles\", 4, \"Jack Russell Terrier\")\n>>> buddy = Dog(\"Buddy\", 9, \"Dachshund\")\n>>> jack = Dog(\"Jack\", 3, \"Bulldog\")\n>>> jim = Dog(\"Jim\", 5, \"Bulldog\")\n\n\nEach breed of dog has slightly different behaviors. For example, bulldogs have a low bark that sounds like woof, but dachshunds have a higher-pitched bark that sounds more like yap.\n\nUsing just the Dog class, you must supply a string for the sound argument of .speak() every time you call it on a Dog instance:\n\nPython\n>>> buddy.speak(\"Yap\")\n'Buddy says Yap'\n\n>>> jim.speak(\"Woof\")\n'Jim says Woof'\n\n>>> jack.speak(\"Woof\")\n'Jack says Woof'\n\n\nPassing a string to every call to .speak() is repetitive and inconvenient. Moreover, the .breed attribute should determine the string representing the sound that each Dog instance makes, but here you have to manually pass the correct string to .speak() every time you call it.\n\nYou can simplify the experience of working with the Dog class by creating a child class for each breed of dog. This allows you to extend the functionality that each child class inherits, including specifying a default argument for .speak().\n\nRemove ads\nParent Classes vs Child Classes\n\nIn this section, you\u2019ll create a child class for each of the three breeds mentioned above: Jack Russell terrier, dachshund, and bulldog.\n\nFor reference, here\u2019s the full definition of the Dog class that you\u2019re currently working with:\n\nPython\ndog.py\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __str__(self):\n        return f\"{self.name} is {self.age} years old\"\n\n    def speak(self, sound):\n        return f\"{self.name} says {sound}\"\n\n\nAfter doing the dog park example in the previous section, you\u2019ve removed .breed again. You\u2019ll now write code to keep track of a dog\u2019s breed using child classes instead.\n\nTo create a child class, you create a new class with its own name and then put the name of the parent class in parentheses. Add the following to the dog.py file to create three new child classes of the Dog class:\n\nPython\ndog.py\n# ...\n\nclass JackRussellTerrier(Dog):\n    pass\n\nclass Dachshund(Dog):\n    pass\n\nclass Bulldog(Dog):\n    pass\n\n\nPress F5 to save and run the file. With the child classes defined, you can now create some dogs of specific breeds in the interactive window:\n\nPython\n>>> miles = JackRussellTerrier(\"Miles\", 4)\n>>> buddy = Dachshund(\"Buddy\", 9)\n>>> jack = Bulldog(\"Jack\", 3)\n>>> jim = Bulldog(\"Jim\", 5)\n\n\nInstances of child classes inherit all of the attributes and methods of the parent class:\n\nPython\n>>> miles.species\n'Canis familiaris'\n\n>>> buddy.name\n'Buddy'\n\n>>> print(jack)\nJack is 3 years old\n\n>>> jim.speak(\"Woof\")\n'Jim says Woof'\n\n\nTo determine which class a given object belongs to, you can use the built-in type():\n\nPython\n>>> type(miles)\n<class '__main__.JackRussellTerrier'>\n\n\nWhat if you want to determine if miles is also an instance of the Dog class? You can do this with the built-in isinstance():\n\nPython\n>>> isinstance(miles, Dog)\nTrue\n\n\nNotice that isinstance() takes two arguments, an object and a class. In the example above, isinstance() checks if miles is an instance of the Dog class and returns True.\n\nThe miles, buddy, jack, and jim objects are all Dog instances, but miles isn\u2019t a Bulldog instance, and jack isn\u2019t a Dachshund instance:\n\nPython\n>>> isinstance(miles, Bulldog)\nFalse\n\n>>> isinstance(jack, Dachshund)\nFalse\n\n\nMore generally, all objects created from a child class are instances of the parent class, although they may not be instances of other child classes.\n\nNow that you\u2019ve created child classes for some different breeds of dogs, you can give each breed its own sound.\n\nRemove ads\nParent Class Functionality Extension\n\nSince different breeds of dogs have slightly different barks, you want to provide a default value for the sound argument of their respective .speak() methods. To do this, you need to override .speak() in the class definition for each breed.\n\nTo override a method defined on the parent class, you define a method with the same name on the child class. Here\u2019s what that looks like for the JackRussellTerrier class:\n\nPython\ndog.py\n# ...\n\nclass JackRussellTerrier(Dog):\n    def speak(self, sound=\"Arf\"):\n        return f\"{self.name} says {sound}\"\n\n# ...\n\n\nNow .speak() is defined on the JackRussellTerrier class with the default argument for sound set to \"Arf\".\n\nUpdate dog.py with the new JackRussellTerrier class and press F5 to save and run the file. You can now call .speak() on a JackRussellTerrier instance without passing an argument to sound:\n\nPython\n>>> miles = JackRussellTerrier(\"Miles\", 4)\n>>> miles.speak()\n'Miles says Arf'\n\n\nSometimes dogs make different noises, so if Miles gets angry and growls, you can still call .speak() with a different sound:\n\nPython\n>>> miles.speak(\"Grrr\")\n'Miles says Grrr'\n\n\nOne thing to keep in mind about class inheritance is that changes to the parent class automatically propagate to child classes. This occurs as long as the attribute or method being changed isn\u2019t overridden in the child class.\n\nFor example, in the editor window, change the string returned by .speak() in the Dog class:\n\nPython\ndog.py\nclass Dog:\n    # ...\n\n    def speak(self, sound):\n        return f\"{self.name} barks: {sound}\"\n\n# ...\n\n\nSave the file and press F5. Now, when you create a new Bulldog instance named jim, jim.speak() returns the new string:\n\nPython\n>>> jim = Bulldog(\"Jim\", 5)\n>>> jim.speak(\"Woof\")\n'Jim barks: Woof'\n\n\nHowever, calling .speak() on a JackRussellTerrier instance won\u2019t show the new style of output:\n\nPython\n>>> miles = JackRussellTerrier(\"Miles\", 4)\n>>> miles.speak()\n'Miles says Arf'\n\n\nSometimes it makes sense to completely override a method from a parent class. But in this case, you don\u2019t want the JackRussellTerrier class to lose any changes that you might make to the formatting of the Dog.speak() output string.\n\nTo do this, you still need to define a .speak() method on the child JackRussellTerrier class. But instead of explicitly defining the output string, you need to call the Dog class\u2019s .speak() from inside the child class\u2019s .speak() using the same arguments that you passed to JackRussellTerrier.speak().\n\nYou can access the parent class from inside a method of a child class by using super():\n\nPython\ndog.py\n# ...\n\nclass JackRussellTerrier(Dog):\n    def speak(self, sound=\"Arf\"):\n        return super().speak(sound)\n\n# ...\n\n\nWhen you call super().speak(sound) inside JackRussellTerrier, Python searches the parent class, Dog, for a .speak() method and calls it with the variable sound.\n\nUpdate dog.py with the new JackRussellTerrier class. Save the file and press F5 so you can test it in the interactive window:\n\nPython\n>>> miles = JackRussellTerrier(\"Miles\", 4)\n>>> miles.speak()\n'Miles barks: Arf'\n\n\nNow when you call miles.speak(), you\u2019ll see output reflecting the new formatting in the Dog class.\n\nNote: In the above examples, the class hierarchy is very straightforward. The JackRussellTerrier class has a single parent class, Dog. In real-world examples, the class hierarchy can get quite complicated.\n\nThe super() function does much more than just search the parent class for a method or an attribute. It traverses the entire class hierarchy for a matching method or attribute. If you aren\u2019t careful, super() can have surprising results.\n\nIf you want to check your understanding of the concepts that you learned about in this section with a practical exercise, then you can click on the block below and work on solving the challenge:\n\nExercise: Class Inheritance\nShow/Hide\n\nWhen you\u2019re done with your own implementation of the challenge, then you can expand the block below to see a possible solution:\n\nSolution: Class Inheritance\nShow/Hide\n\nNice work! In this section, you\u2019ve learned how to override and extend methods from a parent class, and you worked on a small practical example to cement your new skills.\n\nRemove ads\nConclusion\n\nIn this tutorial, you learned about object-oriented programming (OOP) in Python. Many modern programming languages, such as Java, C#, and C++, follow OOP principles, so the knowledge that you gained here will be applicable no matter where your programming career takes you.\n\nIn this tutorial, you learned how to:\n\nDefine a class, which is a sort of blueprint for an object\nInstantiate a class to create an object\nUse attributes and methods to define the properties and behaviors of an object\nUse inheritance to create child classes from a parent class\nReference a method on a parent class using super()\nCheck if an object inherits from another class using isinstance()\n\nIf you enjoyed what you learned in this sample from Python Basics: A Practical Introduction to Python 3, then be sure to check out the rest of the book and take a look at our Introduction to Python learning path.\n\n Take the Quiz: Test your knowledge with our interactive \u201cObject-Oriented Programming (OOP) in Python\u201d quiz. You\u2019ll receive a score upon completion to help you track your learning progress:\n\nInteractive Quiz\n\nObject-Oriented Programming (OOP) in Python\n\nObject-oriented programming (OOP) is a method of structuring a program by bundling related properties and behaviors into individual objects.\n\nFrequently Asked Questions\n\nNow that you have some experience with object-oriented programming in Python, you can use the questions and answers below to check your understanding and recap what you\u2019ve learned.\n\nThese FAQs are related to the most important concepts you\u2019ve covered in this tutorial. Click the Show/Hide toggle beside each question to reveal the answer.\n\nWhat is object-oriented programming in Python?\nShow/Hide\n\nWhat are the four pillars of object-oriented programming in Python?\nShow/Hide\n\nHow do you define a class in Python?\nShow/Hide\n\nWhat is the purpose of class inheritance in Python?\nShow/Hide\n\nHow can you instantiate a class in Python?\nShow/Hide\n\nWhat is the difference between class attributes and instance attributes in Python?\nShow/Hide\n\nMark as Completed\nShare\n\n Watch Now This tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding: Intro to Object-Oriented Programming (OOP) in Python\n\n\ud83d\udc0d Python Tricks \ud83d\udc8c\n\nGet a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.\n\nSend Me Python Tricks \u00bb\n\nAbout David Amos\n\nDavid is a writer, programmer, and mathematician passionate about exploring mathematics through code.\n\n\u00bb More about David\n\nEach tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are:\n\nAldren\n\nBrenda\n\nGeir Arne\n\nJoanna\n\nJacob\n\nKate\n\nMartin\n\nMaster Real-World Python Skills\nWith Unlimited Access to Real\u00a0Python\n\nJoin us and get access to thousands of tutorials, hands-on video courses, and a community of expert Pythonistas:\n\nLevel Up Your Python Skills \u00bb\n\nWhat Do You Think?\n\nRate this article: \nLinkedIn\nTwitter\nBluesky\nFacebook\nEmail\n\nWhat\u2019s your #1 takeaway or favorite thing you learned? How are you going to put your newfound skills to use? Leave a comment below and let us know.\n\nCommenting Tips: The most useful comments are those written with the goal of learning from or helping out other students. Get tips for asking good questions and get answers to common questions in our support portal.\n\nLooking for a real-time conversation? Visit the Real Python Community Chat or join the next \u201cOffice\u00a0Hours\u201d Live Q&A Session. Happy Pythoning!\n\nKeep Learning\n\nRelated Topics: intermediate python\n\nRecommended Video Course: Intro to Object-Oriented Programming (OOP) in Python\n\nRelated Tutorials:\n\nPython Classes: The Power of Object-Oriented Programming\nPython Class Constructors: Control Your Object Instantiation\nInheritance and Composition: A Python OOP Guide\nPython's property(): Add Managed Attributes to Your Classes\nPrimer on Python Decorators\nRemove ads\n\n\u00a9 2012\u20132025 Real\u00a0Python\u00a0\u22c5 Newsletter\u00a0\u22c5 Podcast\u00a0\u22c5 YouTube\u00a0\u22c5 Twitter\u00a0\u22c5 Facebook\u00a0\u22c5 Instagram\u00a0\u22c5 Python\u00a0Tutorials\u00a0\u22c5 Search\u00a0\u22c5 Privacy Policy\u00a0\u22c5 Energy Policy\u00a0\u22c5 Advertise\u00a0\u22c5 Contact\n\n Happy Pythoning!\n\nTutorials \nExercises \nCertificates \nServices \nSearch field\n\ue80b\nLog in\nSign Up\n Get Certified\n For Teachers\n Spaces\n Plus\nHTML CSS JAVASCRIPT SQL PYTHON JAVA PHP HOW TO W3.CSS C C++ C# BOOTSTRAP REACT MYSQL JQUERY EXCEL XML DJANGO NUMPY PANDAS NODEJS DSA TYPESCRIPT ANGULAR GIT POSTGRESQL MONGODB ASP AI R GO KOTLIN SASS VUE GEN AI SCIPY CYBERSECURITY DATA SCIENCE \nPython Tutorial\nPython HOME\nPython Intro\nPython Get Started\nPython Syntax\nPython Comments\nPython Variables\nPython Data Types\nPython Numbers\nPython Casting\nPython Strings\nPython Booleans\nPython Operators\nPython Lists\nPython Tuples\nPython Sets\nPython Dictionaries\nPython If...Else\nPython While Loops\nPython For Loops\nPython Functions\nPython Lambda\nPython Arrays\nPython Classes/Objects\nPython Inheritance\nPython Iterators\nPython Polymorphism\nPython Scope\nPython Modules\nPython Dates\nPython Math\nPython JSON\nPython RegEx\nPython PIP\nPython Try...Except\nPython User Input\nPython String Formatting\n\n\nFile Handling\nPython File Handling\nPython Read Files\nPython Write/Create Files\nPython Delete Files\n\n\nPython Modules\nNumPy Tutorial\nPandas Tutorial\nSciPy Tutorial\nDjango Tutorial\n\n\nPython Matplotlib\nMatplotlib Intro\nMatplotlib Get Started\nMatplotlib Pyplot\nMatplotlib Plotting\nMatplotlib Markers\nMatplotlib Line\nMatplotlib Labels\nMatplotlib Grid\nMatplotlib Subplot\nMatplotlib Scatter\nMatplotlib Bars\nMatplotlib Histograms\nMatplotlib Pie Charts\n\n\nMachine Learning\nGetting Started\nMean Median Mode\nStandard Deviation\nPercentile\nData Distribution\nNormal Data Distribution\nScatter Plot\nLinear Regression\nPolynomial Regression\nMultiple Regression\nScale\nTrain/Test\nDecision Tree\nConfusion Matrix\nHierarchical Clustering\nLogistic Regression\nGrid Search\nCategorical Data\nK-means\nBootstrap Aggregation\nCross Validation\nAUC - ROC Curve\nK-nearest neighbors\n\n\nPython MySQL\nMySQL Get Started\nMySQL Create Database\nMySQL Create Table\nMySQL Insert\nMySQL Select\nMySQL Where\nMySQL Order By\nMySQL Delete\nMySQL Drop Table\nMySQL Update\nMySQL Limit\nMySQL Join\n\n\nPython MongoDB\nMongoDB Get Started\nMongoDB Create DB\nMongoDB Collection\nMongoDB Insert\nMongoDB Find\nMongoDB Query\nMongoDB Sort\nMongoDB Delete\nMongoDB Drop Collection\nMongoDB Update\nMongoDB Limit\n\n\nPython Reference\nPython Overview\nPython Built-in Functions\nPython String Methods\nPython List Methods\nPython Dictionary Methods\nPython Tuple Methods\nPython Set Methods\nPython File Methods\nPython Keywords\nPython Exceptions\nPython Glossary\n\n\nModule Reference\nRandom Module\nRequests Module\nStatistics Module\nMath Module\ncMath Module\n\n\nPython How To\nRemove List Duplicates\nReverse a String\nAdd Two Numbers\n\n\nPython Examples\nPython Examples\nPython Compiler\nPython Exercises\nPython Quiz\nPython Server\nPython Syllabus\nPython Study Plan\nPython Interview Q&A\nPython Bootcamp\nPython Certificate\nPython Training\n\n\n\nPython Classes and Objects\n\u276e Previous\nNext \u276f\nPython Classes/Objects\n\nPython is an object oriented programming language.\n\nAlmost everything in Python is an object, with its properties and methods.\n\nA Class is like an object constructor, or a \"blueprint\" for creating objects.\n\nCreate a Class\n\nTo create a class, use the keyword class:\n\nExample\nGet your own Python Server\n\nCreate a class named MyClass, with a property named x:\n\nclass MyClass:\n\u00a0 x = 5\nTry it Yourself \u00bb\nCreate Object\n\nNow we can use the class named MyClass to create objects:\n\nExample\n\nCreate an object named p1, and print the value of x:\n\np1 = MyClass()\nprint(p1.x)\nTry it Yourself \u00bb\nThe __init__() Function\n\nThe examples above are classes and objects in their simplest form, and are not really useful in real life applications.\n\nTo understand the meaning of classes we have to understand the built-in __init__() function.\n\nAll classes have a function called __init__(), which is always executed when the class is being initiated.\n\nUse the __init__() function to assign values to object properties, or other operations that are necessary to do when the object is being created:\n\nExample\n\nCreate a class named Person, use the __init__() function to assign values for name and age:\n\nclass Person:\n\u00a0 def __init__(self, name, age):\n\u00a0\u00a0\u00a0 self.name = name\n\u00a0\u00a0\u00a0 self.age = age\n\np1 = Person(\"John\", 36)\n\nprint(p1.name)\nprint(p1.age)\nTry it Yourself \u00bb\n\nNote: The __init__() function is called automatically every time the class is being used to create a new object.\n\nThe __str__() Function\n\nThe __str__() function controls what should be returned when the class object is represented as a string.\n\nIf the __str__() function is not set, the string representation of the object is returned:\n\nExample\n\nThe string representation of an object WITHOUT the __str__() function:\n\nclass Person:\n\u00a0 def __init__(self, name, age):\n\u00a0\u00a0\u00a0 self.name = name\n\u00a0\u00a0\u00a0 self.age = age\n\np1 = Person(\"John\", 36)\n\nprint(p1)\nTry it Yourself \u00bb\nExample\n\nThe string representation of an object WITH the __str__() function:\n\nclass Person:\n\u00a0 def __init__(self, name, age):\n\u00a0\u00a0\u00a0 self.name = name\n\u00a0\u00a0\u00a0 self.age = age\n\n\u00a0 def __str__(self):\n\u00a0\u00a0\u00a0 return f\"{self.name}({self.age})\"\n\np1 = Person(\"John\", 36)\n\nprint(p1)\nTry it Yourself \u00bb\nObject Methods\n\nObjects can also contain methods. Methods in objects are functions that belong to the object.\n\nLet us create a method in the Person class:\n\nExample\n\nInsert a function that prints a greeting, and execute it on the p1 object:\n\nclass Person:\n\u00a0 def __init__(self, name, age):\n\u00a0\u00a0\u00a0 self.name = name\n\u00a0\u00a0\u00a0 self.age = age\n\n\u00a0 def myfunc(self):\n\u00a0\u00a0\u00a0 print(\"Hello my name is \" + self.name)\n\np1 = Person(\"John\", 36)\np1.myfunc()\nTry it Yourself \u00bb\n\nNote: The self parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.\n\nThe self Parameter\n\nThe self parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.\n\nIt does not have to be named self, you can call it whatever you like, but it has to be the first parameter of any function in the class:\n\nExample\n\nUse the words mysillyobject and abc instead of self:\n\nclass Person:\n\u00a0 def __init__(mysillyobject, name, age):\n\u00a0\u00a0\u00a0 mysillyobject.name = name\n\u00a0\u00a0\u00a0 mysillyobject.age = age\n\n\u00a0 def myfunc(abc):\n\u00a0\u00a0\u00a0 print(\"Hello my name is \" + abc.name)\n\np1 = Person(\"John\", 36)\np1.myfunc()\nTry it Yourself \u00bb\nModify Object Properties\n\nYou can modify properties on objects like this:\n\nExample\n\nSet the age of p1 to 40:\n\np1.age = 40\nTry it Yourself \u00bb\nDelete Object Properties\n\nYou can delete properties on objects by using the del keyword:\n\nExample\n\nDelete the age property from the p1 object:\n\ndel p1.age\nTry it Yourself \u00bb\nDelete Objects\n\nYou can delete objects by using the del keyword:\n\nExample\n\nDelete the p1 object:\n\ndel p1\nTry it Yourself \u00bb\nThe pass Statement\n\nclass definitions cannot be empty, but if you for some reason have a class definition with no content, put in the pass statement to avoid getting an error.\n\nExample\nclass Person:\n\u00a0 pass\nTry it Yourself \u00bb\n\u276e Previous\nNext \u276f\n\u00a0\nTrack your progress - it's free!\n\u00a0\nLog in\nSign Up\nCOLOR PICKER\n    \nPLUS\nSPACES\nGET CERTIFIED\nFOR TEACHERS\nFOR BUSINESS\nCONTACT US\nTop Tutorials\nHTML Tutorial\nCSS Tutorial\nJavaScript Tutorial\nHow To Tutorial\nSQL Tutorial\nPython Tutorial\nW3.CSS Tutorial\nBootstrap Tutorial\nPHP Tutorial\nJava Tutorial\nC++ Tutorial\njQuery Tutorial\n\nTop References\nHTML Reference\nCSS Reference\nJavaScript Reference\nSQL Reference\nPython Reference\nW3.CSS Reference\nBootstrap Reference\nPHP Reference\nHTML Colors\nJava Reference\nAngular Reference\njQuery Reference\n\nTop Examples\nHTML Examples\nCSS Examples\nJavaScript Examples\nHow To Examples\nSQL Examples\nPython Examples\nW3.CSS Examples\nBootstrap Examples\nPHP Examples\nJava Examples\nXML Examples\njQuery Examples\n\nGet Certified\nHTML Certificate\nCSS Certificate\nJavaScript Certificate\nFront End Certificate\nSQL Certificate\nPython Certificate\nPHP Certificate\njQuery Certificate\nJava Certificate\nC++ Certificate\nC# Certificate\nXML Certificate\n\n \uf30c \ue807 \ue806 \uf16d FORUM ABOUT ACADEMY\nW3Schools is optimized for learning and training. Examples might be simplified to improve reading and learning. Tutorials, references, and examples are constantly reviewed to avoid errors, but we cannot warrant full correctness of all content. While using W3Schools, you agree to have read and accepted our terms of use, cookie and privacy policy.\n\nCopyright 1999-2025 by Refsnes Data. All Rights Reserved. W3Schools is Powered by W3.CSS.\n\nSkip to content\nCourses\nTutorials\nDSA\nData Science\nWeb Tech\nTrending Now\nDSA\nWeb Tech\nFoundational Courses\nData Science\nPractice Problem\nPython\nMachine Learning\nJavaScript\nSystem Design\nDjango\nDevOps Tutorial\nJava\nC\nC++\nReactJS\nNodeJS\nCP Live\nAptitude\nPuzzles\nProjects\nNext Article:\nObject Oriented Programming (OOPs) in MATLAB\nIntroduction of Object Oriented Programming\nLast Updated : 09 Feb, 2023\n\nAs the name suggests, Object-Oriented Programming or OOPs refers to languages that use objects in programming. Object-oriented programming aims to implement real-world entities like inheritance, hiding, polymorphism, etc in programming. The main aim of OOP is to bind together the data and the functions that operate on them so that no other part of the code can access this data except that function.\n\nOOPs Concepts:\n\nClass\nObjects\nData Abstraction\u00a0\nEncapsulation\nInheritance\nPolymorphism\nDynamic Binding\nMessage Passing\n\n1. Class:\n\nA\u00a0class is a user-defined data type. It consists of data members and member functions, which can be accessed and used by creating an instance of that class. It represents the set of properties or methods that are common to all objects of one type. A class is like a blueprint for an object.\u00a0\u00a0\n\nFor Example: Consider the Class of Cars. There may be many cars with different names and brands but all of them will share some common properties like all of them will have 4 wheels, Speed Limit, Mileage range, etc. So here, Car is the class, and wheels, speed limits, mileage are their properties.\n\n2. Object:\u00a0\n\nIt is a basic unit of Object-Oriented Programming\u00a0and represents the real-life entities. An Object is an instance of a Class. When a class is defined, no memory is allocated but when it is instantiated (i.e. an object is created) memory is allocated. An object has an identity, state, and behavior. Each object contains data and code to manipulate the data. Objects can interact without having to know details of each other\u2019s data or code, it is sufficient to know the type of message accepted and type of response returned by the objects.\u00a0\n\nFor example \u201cDog\u201d is a real-life Object, which has some characteristics like color, Breed, Bark, Sleep, and Eats.\n\nObject\n\n3. Data Abstraction:\u00a0\n\nData abstraction is one of the most essential and important features of object-oriented programming. Data abstraction refers to providing only essential information about the data to the outside world, hiding the background details or implementation. Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the speed of the car or applying brakes will stop the car, but he does not know about how on pressing the accelerator the speed is increasing, he does not know about the inner mechanism of the car or the implementation of the accelerator, brakes, etc in the car. This is what abstraction is.\n\n4. Encapsulation:\u00a0\n\nEncapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates. In Encapsulation, the variables or data of a class are hidden from any other class and can be accessed only through any member function of their class in which they are declared. As in encapsulation, the data in a class is hidden from other classes, so it is also known as data-hiding.\n\nConsider a real-life example of encapsulation, in a company, there are different sections like the accounts section, finance section, sales section, etc. The finance section handles all the financial transactions and keeps records of all the data related to finance. Similarly, the sales section handles all the sales-related activities and keeps records of all the sales. Now there may arise a situation when for some reason an official from the finance section needs all the data about sales in a particular month. In this case, he is not allowed to directly access the data of the sales section. He will first have to contact some other officer in the sales section and then request him to give the particular data. This is what encapsulation is. Here the data of the sales section and the employees that can manipulate them are wrapped under a single name \u201csales section\u201d.\n\n5. Inheritance:\u00a0\n\nInheritance is an important pillar of OOP(Object-Oriented Programming). The capability of a class to derive properties and characteristics from another class is called Inheritance. When we write a class, we inherit properties from other classes. So when we create a class, we do not need to write all the properties and functions again and again, as these can be inherited from another class that possesses it. Inheritance allows the user to reuse the code whenever possible and reduce its redundancy.\n\n6. Polymorphism:\u00a0\n\nThe word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form. For example, A person at the same time can have different characteristics. Like a man at the same time is a father, a husband, an employee. So the same person posses different behavior in different situations. This is called polymorphism.\n\n7. Dynamic Binding:\n\nIn dynamic binding, the code to be executed in response to the function call is decided at runtime. Dynamic binding means that the code associated with a given procedure call is not known until the time of the call at run time.\u00a0Dynamic Method Binding One of the main advantages of inheritance is that some derived class D has all the members of its base class B. Once D is not hiding any of the public members of B, then an object of D can represent B in any context where a B could be used. This feature is known as subtype polymorphism.\n\n8. Message Passing:\n\nIt is a form of communication used in object-oriented programming as well as parallel programming. Objects communicate with one another by sending and receiving information to each other. A message for an object is a request for execution of a procedure and therefore will invoke a function in the receiving object that generates the desired results. Message passing involves specifying the name of the object, the name of the function, and the information to be sent.\n\nWhy do we need object-oriented programming\n\nTo make the development and maintenance of projects more effortless.\u00a0\nTo provide the feature of data hiding that is good for security concerns. \u00a0\nWe can solve real-world problems if we are using object-oriented programming.\u00a0\nIt ensures code reusability.\u00a0\nIt lets us write generic code: which will work with a range of data, so we don\u2019t have to write basic stuff over and over again.\n\n\n\n\nComment\nMore info\nAdvertise with us\nNext Article \nObject Oriented Programming (OOPs) in MATLAB\nSimilar Reads\nIntroduction of Object Oriented Programming\nAs the name suggests, Object-Oriented Programming or OOPs refers to languages that use objects in programming. Object-oriented programming aims to implement real-world entities like inheritance, hiding, polymorphism, etc in programming. The main aim of OOP is to bind together the data and the functi\n6 min read\nObject Oriented Programming (OOPs) in MATLAB\nObject-Oriented Programming (OOPs) in MATLAB is similar to many conventional programming languages like Java, Python, etc except the syntax. The important feature of OOPs is, it enables you to combine data and it's associated actions (methods/functions) into objects. Compared to other languages, suc\n6 min read\nObject-Oriented Programming in Ruby | Set 1\nWhen we say object-oriented programming, we mean that our code is centered on objects. Objects are real-life instances that are classified into various types. Let\u00e2\u20ac\u2122s take an example to understand this better. If we consider a rose as an object, then the class of the rose will be flower. A class is li\n9 min read\nDesign Goals and Principles of Object Oriented Programming\nThe fundamental goal of dealing with the complexity of building modern software naturally gives rise to several sub-goals. These sub-goals are directed at the production of quality software, including good implementations of data structures and algorithms. The article focuses on discussing design go\n13 min read\nIntroduction to Programming Languages\nIntroduction: A programming language is a set of instructions and syntax used to create software programs. Some of the key features of programming languages include: Syntax: The specific rules and structure used to write code in a programming language.Data Types: The type of values that can be store\n13 min read\nTop 10 Object-Oriented Programming Languages in 2024\nIn the present world, almost all sectors make use of software applications or computer programs that require to be coded. Programming Language is a set of instructions used in specific notations to write computer programs. It, basically tells the computer what to do. All Programming languages are no\n9 min read\nDifference between Functional Programming and Object Oriented Programming\nWhat is Functional Programming?In functional programming, we have to build programs using functions. An example of functional programming is Haskell language. What is Object Oriented Programming?Object-oriented programming is built by using classes and objects. In this, we have concepts of encapsula\n3 min read\nDifferences between Procedural and Object Oriented Programming\nThis article focuses on discussing the differences between procedural and object-oriented programming. Procedural Programming Procedural Programming can be defined as a programming model which is derived from structured programming, based upon the concept of calling procedure. Procedures, also known\n2 min read\nIntroduction to Visual Programming Language\nAny language that uses the graphics or blocks that are already defined with the code and you just need to use those blocks without worrying about the lines of code is known as a visual programming language. In today's era majority of the programming languages are text-based i.e. we have to write the\n6 min read\n5 Best Languages for Competitive Programming\nNeedless to say, Competitive Programming is one of the most crucial and popular aspects of a programmer's journey. Though, all the programmers are strongly recommended to participate in such coding challenges to enhance their coding skills and to get various ravishing prizes, rewards, and other care\n5 min read\nCorporate & Communications Address:\nA-143, 7th Floor, Sovereign Corporate Tower, Sector- 136, Noida, Uttar Pradesh (201305)\nRegistered Address:\nK 061, Tower K, Gulshan Vivante Apartment, Sector 137, Noida, Gautam Buddh Nagar, Uttar Pradesh, 201305\nAdvertise with us\nCompany\nAbout Us\nLegal\nPrivacy Policy\nIn Media\nContact Us\nAdvertise with us\nGFG Corporate Solution\nPlacement Training Program\nGeeksforGeeks Community\nLanguages\nPython\nJava\nC++\nPHP\nGoLang\nSQL\nR Language\nAndroid Tutorial\nTutorials Archive\nDSA\nData Structures\nAlgorithms\nDSA for Beginners\nBasic DSA Problems\nDSA Roadmap\nTop 100 DSA Interview Problems\nDSA Roadmap by Sandeep Jain\nAll Cheat Sheets\nData Science & ML\nData Science With Python\nData Science For Beginner\nMachine Learning\nML Maths\nData Visualisation\nPandas\nNumPy\nNLP\nDeep Learning\nWeb Technologies\nHTML\nCSS\nJavaScript\nTypeScript\nReactJS\nNextJS\nBootstrap\nWeb Design\nPython Tutorial\nPython Programming Examples\nPython Projects\nPython Tkinter\nWeb Scraping\nOpenCV Tutorial\nPython Interview Question\nDjango\nComputer Science\nOperating Systems\nComputer Network\nDatabase Management System\nSoftware Engineering\nDigital Logic Design\nEngineering Maths\nSoftware Development\nSoftware Testing\nDevOps\nGit\nLinux\nAWS\nDocker\nKubernetes\nAzure\nGCP\nDevOps Roadmap\nSystem Design\nHigh Level Design\nLow Level Design\nUML Diagrams\nInterview Guide\nDesign Patterns\nOOAD\nSystem Design Bootcamp\nInterview Questions\nInteview Preparation\nCompetitive Programming\nTop DS or Algo for CP\nCompany-Wise Recruitment Process\nCompany-Wise Preparation\nAptitude Preparation\nPuzzles\nSchool Subjects\nMathematics\nPhysics\nChemistry\nBiology\nSocial Science\nEnglish Grammar\nCommerce\nWorld GK\nGeeksforGeeks Videos\nDSA\nPython\nJava\nC++\nWeb Development\nData Science\nCS Subjects\n@GeeksforGeeks, Sanchhaya Education Private Limited, All rights reserved\nWe use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy\nGot It !\n\nindex\nmodules |\nnext |\nprevious |\n Python \u00bb \nEnglish\nSpanish | espa\u00f1ol\nFrench | fran\u00e7ais\nItalian | italiano\nJapanese | \u65e5\u672c\u8a9e\nKorean | \ud55c\uad6d\uc5b4\nPolish | polski\nBrazilian Portuguese | Portugu\u00eas brasileiro\nTurkish | T\u00fcrk\u00e7e\nSimplified Chinese | \u7b80\u4f53\u4e2d\u6587\nTraditional Chinese | \u7e41\u9ad4\u4e2d\u6587\ndev (3.14)\n3.13.2\n3.12\n3.11\n3.10\n3.9\n3.8\n3.7\n3.6\n3.5\n3.4\n3.3\n3.2\n3.1\n3.0\n2.7\n2.6\n 3.13.2 Documentation \u00bb The Python Tutorial \u00bb 9. Classes\n  |\nTheme \nAuto\nLight\nDark\n |\n9. Classes\n\nClasses provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.\n\nCompared with other programming languages, Python\u2019s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for referencing the object\u2019s members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special syntax (arithmetic operators, subscripting etc.) can be redefined for class instances.\n\n(Lacking universally accepted terminology to talk about classes, I will make occasional use of Smalltalk and C++ terms. I would use Modula-3 terms, since its object-oriented semantics are closer to those of Python than C++, but I expect that few readers have heard of it.)\n\n9.1. A Word About Names and Objects\n\nObjects have individuality, and multiple names (in multiple scopes) can be bound to the same object. This is known as aliasing in other languages. This is usually not appreciated on a first glance at Python, and can be safely ignored when dealing with immutable basic types (numbers, strings, tuples). However, aliasing has a possibly surprising effect on the semantics of Python code involving mutable objects such as lists, dictionaries, and most other types. This is usually used to the benefit of the program, since aliases behave like pointers in some respects. For example, passing an object is cheap since only a pointer is passed by the implementation; and if a function modifies an object passed as an argument, the caller will see the change \u2014 this eliminates the need for two different argument passing mechanisms as in Pascal.\n\n9.2. Python Scopes and Namespaces\n\nBefore introducing classes, I first have to tell you something about Python\u2019s scope rules. Class definitions play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand what\u2019s going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer.\n\nLet\u2019s begin with some definitions.\n\nA namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries, but that\u2019s normally not noticeable in any way (except for performance), and it may change in the future. Examples of namespaces are: the set of built-in names (containing functions such as abs(), and built-in exception names); the global names in a module; and the local names in a function invocation. In a sense the set of attributes of an object also form a namespace. The important thing to know about namespaces is that there is absolutely no relation between names in different namespaces; for instance, two different modules may both define a function maximize without confusion \u2014 users of the modules must prefix it with the module name.\n\nBy the way, I use the word attribute for any name following a dot \u2014 for example, in the expression z.real, real is an attribute of the object z. Strictly speaking, references to names in modules are attribute references: in the expression modname.funcname, modname is a module object and funcname is an attribute of it. In this case there happens to be a straightforward mapping between the module\u2019s attributes and the global names defined in the module: they share the same namespace! [1]\n\nAttributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write modname.the_answer = 42. Writable attributes may also be deleted with the del statement. For example, del modname.the_answer will remove the attribute the_answer from the object named by modname.\n\nNamespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called __main__, so they have their own global namespace. (The built-in names actually also live in a module; this is called builtins.)\n\nThe local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace.\n\nA scope is a textual region of a Python program where a namespace is directly accessible. \u201cDirectly accessible\u201d here means that an unqualified reference to a name attempts to find the name in the namespace.\n\nAlthough scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n\nthe innermost scope, which is searched first, contains the local names\n\nthe scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names\n\nthe next-to-last scope contains the current module\u2019s global names\n\nthe outermost scope (searched last) is the namespace containing built-in names\n\nIf a name is declared global, then all references and assignments go directly to the next-to-last scope containing the module\u2019s global names. To rebind variables found outside of the innermost scope, the nonlocal statement can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable will simply create a new local variable in the innermost scope, leaving the identically named outer variable unchanged).\n\nUsually, the local scope references the local names of the (textually) current function. Outside functions, the local scope references the same namespace as the global scope: the module\u2019s namespace. Class definitions place yet another namespace in the local scope.\n\nIt is important to realize that scopes are determined textually: the global scope of a function defined in a module is that module\u2019s namespace, no matter from where or by what alias the function is called. On the other hand, the actual search for names is done dynamically, at run time \u2014 however, the language definition is evolving towards static name resolution, at \u201ccompile\u201d time, so don\u2019t rely on dynamic name resolution! (In fact, local variables are already determined statically.)\n\nA special quirk of Python is that \u2013 if no global or nonlocal statement is in effect \u2013 assignments to names always go into the innermost scope. Assignments do not copy data \u2014 they just bind names to objects. The same is true for deletions: the statement del x removes the binding of x from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, import statements and function definitions bind the module or function name in the local scope.\n\nThe global statement can be used to indicate that particular variables live in the global scope and should be rebound there; the nonlocal statement indicates that particular variables live in an enclosing scope and should be rebound there.\n\n9.2.1. Scopes and Namespaces Example\n\nThis is an example demonstrating how to reference the different scopes and namespaces, and how global and nonlocal affect variable binding:\n\ndef scope_test():\n    def do_local():\n        spam = \"local spam\"\n\n    def do_nonlocal():\n        nonlocal spam\n        spam = \"nonlocal spam\"\n\n    def do_global():\n        global spam\n        spam = \"global spam\"\n\n    spam = \"test spam\"\n    do_local()\n    print(\"After local assignment:\", spam)\n    do_nonlocal()\n    print(\"After nonlocal assignment:\", spam)\n    do_global()\n    print(\"After global assignment:\", spam)\n\nscope_test()\nprint(\"In global scope:\", spam)\n\n\nThe output of the example code is:\n\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n\n\nNote how the local assignment (which is default) didn\u2019t change scope_test's binding of spam. The nonlocal assignment changed scope_test's binding of spam, and the global assignment changed the module-level binding.\n\nYou can also see that there was no previous binding for spam before the global assignment.\n\n9.3. A First Look at Classes\n\nClasses introduce a little bit of new syntax, three new object types, and some new semantics.\n\n9.3.1. Class Definition Syntax\n\nThe simplest form of class definition looks like this:\n\nclass ClassName:\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n\n\nClass definitions, like function definitions (def statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an if statement, or inside a function.)\n\nIn practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful \u2014 we\u2019ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods \u2014 again, this is explained later.\n\nWhen a class definition is entered, a new namespace is created, and used as the local scope \u2014 thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here.\n\nWhen a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; we\u2019ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header (ClassName in the example).\n\n9.3.2. Class Objects\n\nClass objects support two kinds of operations: attribute references and instantiation.\n\nAttribute references use the standard syntax used for all attribute references in Python: obj.name. Valid attribute names are all the names that were in the class\u2019s namespace when the class object was created. So, if the class definition looked like this:\n\nclass MyClass:\n    \"\"\"A simple example class\"\"\"\n    i = 12345\n\n    def f(self):\n        return 'hello world'\n\n\nthen MyClass.i and MyClass.f are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of MyClass.i by assignment. __doc__ is also a valid attribute, returning the docstring belonging to the class: \"A simple example class\".\n\nClass instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class):\n\nx = MyClass()\n\n\ncreates a new instance of the class and assigns this object to the local variable x.\n\nThe instantiation operation (\u201ccalling\u201d a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named __init__(), like this:\n\ndef __init__(self):\n    self.data = []\n\n\nWhen a class defines an __init__() method, class instantiation automatically invokes __init__() for the newly created class instance. So in this example, a new, initialized instance can be obtained by:\n\nx = MyClass()\n\n\nOf course, the __init__() method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to __init__(). For example,\n\n>>>\n>>> class Complex:\n...     def __init__(self, realpart, imagpart):\n...         self.r = realpart\n...         self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n\n9.3.3. Instance Objects\n\nNow what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods.\n\ndata attributes correspond to \u201cinstance variables\u201d in Smalltalk, and to \u201cdata members\u201d in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if x is the instance of MyClass created above, the following piece of code will print the value 16, without leaving a trace:\n\nx.counter = 1\nwhile x.counter < 10:\n    x.counter = x.counter * 2\nprint(x.counter)\ndel x.counter\n\n\nThe other kind of instance attribute reference is a method. A method is a function that \u201cbelongs to\u201d an object.\n\nValid method names of an instance object depend on its class. By definition, all attributes of a class that are function objects define corresponding methods of its instances. So in our example, x.f is a valid method reference, since MyClass.f is a function, but x.i is not, since MyClass.i is not. But x.f is not the same thing as MyClass.f \u2014 it is a method object, not a function object.\n\n9.3.4. Method Objects\n\nUsually, a method is called right after it is bound:\n\nx.f()\n\n\nIn the MyClass example, this will return the string 'hello world'. However, it is not necessary to call a method right away: x.f is a method object, and can be stored away and called at a later time. For example:\n\nxf = x.f\nwhile True:\n    print(xf())\n\n\nwill continue to print hello world until the end of time.\n\nWhat exactly happens when a method is called? You may have noticed that x.f() was called without an argument above, even though the function definition for f() specified an argument. What happened to the argument? Surely Python raises an exception when a function that requires an argument is called without any \u2014 even if the argument isn\u2019t actually used\u2026\n\nActually, you may have guessed the answer: the special thing about methods is that the instance object is passed as the first argument of the function. In our example, the call x.f() is exactly equivalent to MyClass.f(x). In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method\u2019s instance object before the first argument.\n\nIn general, methods work as follows. When a non-data attribute of an instance is referenced, the instance\u2019s class is searched. If the name denotes a valid class attribute that is a function object, references to both the instance object and the function object are packed into a method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list.\n\n9.3.5. Class and Instance Variables\n\nGenerally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:\n\nclass Dog:\n\n    kind = 'canine'         # class variable shared by all instances\n\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\n\n\nAs discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances:\n\nclass Dog:\n\n    tricks = []             # mistaken use of a class variable\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\n\n\nCorrect design of the class should use an instance variable instead:\n\nclass Dog:\n\n    def __init__(self, name):\n        self.name = name\n        self.tricks = []    # creates a new empty list for each dog\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n\n9.4. Random Remarks\n\nIf the same attribute name occurs in both an instance and in a class, then attribute lookup prioritizes the instance:\n\n>>>\n>>> class Warehouse:\n...    purpose = 'storage'\n...    region = 'west'\n...\n>>> w1 = Warehouse()\n>>> print(w1.purpose, w1.region)\nstorage west\n>>> w2 = Warehouse()\n>>> w2.region = 'east'\n>>> print(w2.purpose, w2.region)\nstorage east\n\n\nData attributes may be referenced by methods as well as by ordinary users (\u201cclients\u201d) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding \u2014 it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.)\n\nClients should use data attributes with care \u2014 clients may mess up invariants maintained by the methods by stamping on their data attributes. Note that clients may add data attributes of their own to an instance object without affecting the validity of the methods, as long as name conflicts are avoided \u2014 again, a naming convention can save a lot of headaches here.\n\nThere is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method.\n\nOften, the first argument of a method is called self. This is nothing more than a convention: the name self has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention.\n\nAny function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example:\n\n# Function defined outside the class\ndef f1(self, x, y):\n    return min(x, x+y)\n\nclass C:\n    f = f1\n\n    def g(self):\n        return 'hello world'\n\n    h = g\n\n\nNow f, g and h are all attributes of class C that refer to function objects, and consequently they are all methods of instances of C \u2014 h being exactly equivalent to g. Note that this practice usually only serves to confuse the reader of a program.\n\nMethods may call other methods by using method attributes of the self argument:\n\nclass Bag:\n    def __init__(self):\n        self.data = []\n\n    def add(self, x):\n        self.data.append(x)\n\n    def addtwice(self, x):\n        self.add(x)\n        self.add(x)\n\n\nMethods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section we\u2019ll find some good reasons why a method would want to reference its own class.\n\nEach value is an object, and therefore has a class (also called its type). It is stored as object.__class__.\n\n9.5. Inheritance\n\nOf course, a language feature would not be worthy of the name \u201cclass\u201d without supporting inheritance. The syntax for a derived class definition looks like this:\n\nclass DerivedClassName(BaseClassName):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n\n\nThe name BaseClassName must be defined in a namespace accessible from the scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module:\n\nclass DerivedClassName(modname.BaseClassName):\n\n\nExecution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class.\n\nThere\u2019s nothing special about instantiation of derived classes: DerivedClassName() creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object.\n\nDerived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively virtual.)\n\nAn overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call BaseClassName.methodname(self, arguments). This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as BaseClassName in the global scope.)\n\nPython has two built-in functions that work with inheritance:\n\nUse isinstance() to check an instance\u2019s type: isinstance(obj, int) will be True only if obj.__class__ is int or some class derived from int.\n\nUse issubclass() to check class inheritance: issubclass(bool, int) is True since bool is a subclass of int. However, issubclass(float, int) is False since float is not a subclass of int.\n\n9.5.1. Multiple Inheritance\n\nPython supports a form of multiple inheritance as well. A class definition with multiple base classes looks like this:\n\nclass DerivedClassName(Base1, Base2, Base3):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n\n\nFor most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in DerivedClassName, it is searched for in Base1, then (recursively) in the base classes of Base1, and if it was not found there, it was searched for in Base2, and so on.\n\nIn fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to super(). This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages.\n\nDynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from object, so any case of multiple inheritance provides more than one path to reach object. To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order.\n\n9.6. Private Variables\n\n\u201cPrivate\u201d instance variables that cannot be accessed except from inside an object don\u2019t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice.\n\nSince there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class.\n\nSee also\n\n \n\nThe private name mangling specifications for details and special cases.\n\nName mangling is helpful for letting subclasses override methods without breaking intraclass method calls. For example:\n\nclass Mapping:\n    def __init__(self, iterable):\n        self.items_list = []\n        self.__update(iterable)\n\n    def update(self, iterable):\n        for item in iterable:\n            self.items_list.append(item)\n\n    __update = update   # private copy of original update() method\n\nclass MappingSubclass(Mapping):\n\n    def update(self, keys, values):\n        # provides new signature for update()\n        # but does not break __init__()\n        for item in zip(keys, values):\n            self.items_list.append(item)\n\n\nThe above example would work even if MappingSubclass were to introduce a __update identifier since it is replaced with _Mapping__update in the Mapping class and _MappingSubclass__update in the MappingSubclass class respectively.\n\nNote that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger.\n\nNotice that code passed to exec() or eval() does not consider the classname of the invoking class to be the current class; this is similar to the effect of the global statement, the effect of which is likewise restricted to code that is byte-compiled together. The same restriction applies to getattr(), setattr() and delattr(), as well as when referencing __dict__ directly.\n\n9.7. Odds and Ends\n\nSometimes it is useful to have a data type similar to the Pascal \u201crecord\u201d or C \u201cstruct\u201d, bundling together a few named data items. The idiomatic approach is to use dataclasses for this purpose:\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass Employee:\n    name: str\n    dept: str\n    salary: int\n\n>>>\n>>> john = Employee('john', 'computer lab', 1000)\n>>> john.dept\n'computer lab'\n>>> john.salary\n1000\n\n\nA piece of Python code that expects a particular abstract data type can often be passed a class that emulates the methods of that data type instead. For instance, if you have a function that formats some data from a file object, you can define a class with methods read() and readline() that get the data from a string buffer instead, and pass it as an argument.\n\nInstance method objects have attributes, too: m.__self__ is the instance object with the method m(), and m.__func__ is the function object corresponding to the method.\n\n9.8. Iterators\n\nBy now you have probably noticed that most container objects can be looped over using a for statement:\n\nfor element in [1, 2, 3]:\n    print(element)\nfor element in (1, 2, 3):\n    print(element)\nfor key in {'one':1, 'two':2}:\n    print(key)\nfor char in \"123\":\n    print(char)\nfor line in open(\"myfile.txt\"):\n    print(line, end='')\n\n\nThis style of access is clear, concise, and convenient. The use of iterators pervades and unifies Python. Behind the scenes, the for statement calls iter() on the container object. The function returns an iterator object that defines the method __next__() which accesses elements in the container one at a time. When there are no more elements, __next__() raises a StopIteration exception which tells the for loop to terminate. You can call the __next__() method using the next() built-in function; this example shows how it all works:\n\n>>>\n>>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<str_iterator object at 0x10c90e650>\n>>> next(it)\n'a'\n>>> next(it)\n'b'\n>>> next(it)\n'c'\n>>> next(it)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    next(it)\nStopIteration\n\n\nHaving seen the mechanics behind the iterator protocol, it is easy to add iterator behavior to your classes. Define an __iter__() method which returns an object with a __next__() method. If the class defines __next__(), then __iter__() can just return self:\n\nclass Reverse:\n    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.index = len(data)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.index == 0:\n            raise StopIteration\n        self.index = self.index - 1\n        return self.data[self.index]\n\n>>>\n>>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n...     print(char)\n...\nm\na\np\ns\n\n9.9. Generators\n\nGenerators are a simple and powerful tool for creating iterators. They are written like regular functions but use the yield statement whenever they want to return data. Each time next() is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). An example shows that generators can be trivially easy to create:\n\ndef reverse(data):\n    for index in range(len(data)-1, -1, -1):\n        yield data[index]\n\n>>>\n>>> for char in reverse('golf'):\n...     print(char)\n...\nf\nl\no\ng\n\n\nAnything that can be done with generators can also be done with class-based iterators as described in the previous section. What makes generators so compact is that the __iter__() and __next__() methods are created automatically.\n\nAnother key feature is that the local variables and execution state are automatically saved between calls. This made the function easier to write and much more clear than an approach using instance variables like self.index and self.data.\n\nIn addition to automatic method creation and saving program state, when generators terminate, they automatically raise StopIteration. In combination, these features make it easy to create iterators with no more effort than writing a regular function.\n\n9.10. Generator Expressions\n\nSome simple generators can be coded succinctly as expressions using a syntax similar to list comprehensions but with parentheses instead of square brackets. These expressions are designed for situations where the generator is used right away by an enclosing function. Generator expressions are more compact but less versatile than full generator definitions and tend to be more memory friendly than equivalent list comprehensions.\n\nExamples:\n\n>>>\n>>> sum(i*i for i in range(10))                 # sum of squares\n285\n\n>>> xvec = [10, 20, 30]\n>>> yvec = [7, 5, 3]\n>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n260\n\n>>> unique_words = set(word for line in page  for word in line.split())\n\n>>> valedictorian = max((student.gpa, student.name) for student in graduates)\n\n>>> data = 'golf'\n>>> list(data[i] for i in range(len(data)-1, -1, -1))\n['f', 'l', 'o', 'g']\n\n\nFootnotes\n\n[1]\n\nExcept for one thing. Module objects have a secret read-only attribute called __dict__ which returns the dictionary used to implement the module\u2019s namespace; the name __dict__ is an attribute but not a global name. Obviously, using this violates the abstraction of namespace implementation, and should be restricted to things like post-mortem debuggers.\n\nTable of Contents\n9. Classes\n9.1. A Word About Names and Objects\n9.2. Python Scopes and Namespaces\n9.2.1. Scopes and Namespaces Example\n9.3. A First Look at Classes\n9.3.1. Class Definition Syntax\n9.3.2. Class Objects\n9.3.3. Instance Objects\n9.3.4. Method Objects\n9.3.5. Class and Instance Variables\n9.4. Random Remarks\n9.5. Inheritance\n9.5.1. Multiple Inheritance\n9.6. Private Variables\n9.7. Odds and Ends\n9.8. Iterators\n9.9. Generators\n9.10. Generator Expressions\nPrevious topic\n\n8. Errors and Exceptions\n\nNext topic\n\n10. Brief Tour of the Standard Library\n\nThis Page\nReport a Bug\nShow Source\n\u00ab\nindex\nmodules |\nnext |\nprevious |\n Python \u00bb \nEnglish\nSpanish | espa\u00f1ol\nFrench | fran\u00e7ais\nItalian | italiano\nJapanese | \u65e5\u672c\u8a9e\nKorean | \ud55c\uad6d\uc5b4\nPolish | polski\nBrazilian Portuguese | Portugu\u00eas brasileiro\nTurkish | T\u00fcrk\u00e7e\nSimplified Chinese | \u7b80\u4f53\u4e2d\u6587\nTraditional Chinese | \u7e41\u9ad4\u4e2d\u6587\ndev (3.14)\n3.13.2\n3.12\n3.11\n3.10\n3.9\n3.8\n3.7\n3.6\n3.5\n3.4\n3.3\n3.2\n3.1\n3.0\n2.7\n2.6\n 3.13.2 Documentation \u00bb The Python Tutorial \u00bb 9. Classes\n  |\nTheme \nAuto\nLight\nDark\n |\n\u00a9 Copyright 2001-2025, Python Software Foundation.\nThis page is licensed under the Python Software Foundation License Version 2.\nExamples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.\nSee History and License for more information.\n\nThe Python Software Foundation is a non-profit corporation. Please donate.\n\nLast updated on Mar 11, 2025 (12:47 UTC). Found a bug?\nCreated using Sphinx 8.2.3.\n\nSkip to content\nCourses\nTutorials\nDSA\nData Science\nWeb Tech\nPython Tutorial\nInterview Questions\nPython Quiz\nPython Projects\nPractice Python\nData Science With Python\nPython Web Dev\nDSA with Python\nPython OOPs\nLists\nStrings\nDictionary\nNext Article:\nPython | Method Overloading\nPolymorphism in Python\nLast Updated : 16 Dec, 2024\n\nPolymorphism is a foundational concept in programming that allows entities like functions, methods or operators to behave differently based on the type of data they are handling. Derived from Greek, the term literally means \u201cmany forms\u201d.\n\nPython\u2019s dynamic typing and duck typing make it inherently polymorphic. Functions, operators and even built-in objects like loops exhibit polymorphic behavior.\n\nPolymorphism in Built-in Functions\n\nPython\u2019s built-in functions exhibit polymorphism, adapting to various data types.\n\nExample:\n\nPython\nprint(len(\"Hello\"))  # String length\nprint(len([1, 2, 3]))  # List length\n\nprint(max(1, 3, 2))  # Maximum of integers\nprint(max(\"a\", \"z\", \"m\"))  # Maximum in strings\n\n\nPython determines behavior at runtime, enabling these functions to work across diverse types without explicit type declarations.\n\nLet\u2019s explore polymorphism in detail:\n\nTable of Content\n\nPolymorphism in Built-in Functions\nPolymorphism in Functions\nPolymorphism in Operators\nPolymorphism in Object-Oriented Programming (OOP)\nTypes of Polymorphism\nInheritance Class Polymorphism\nPolymorphism in Functions\n\nDuck typing enables functions to work with any object regardless of its type.\n\nExample:\n\nPython\ndef add(a, b):\n    return a + b\n\nprint(add(3, 4))           # Integer addition\nprint(add(\"Hello, \", \"World!\"))  # String concatenation\nprint(add([1, 2], [3, 4])) # List concatenation\n\nPolymorphism in Operators\nOperator Overloading\n\nIn Python, operators like + behave polymorphically, performing addition, concatenation or merging based on the data type.\n\nExample:\n\nPython\nprint(5 + 10)  # Integer addition\nprint(\"Hello \" + \"World!\")  # String concatenation\nprint([1, 2] + [3, 4])  # List concatenation\n\nPolymorphism in OOPs\n\nIn OOP, polymorphism allows methods in different classes to share the same name but perform distinct tasks. This is achieved through inheritance and interface design. Polymorphism complements other OOP principles like inheritance (sharing behavior) and encapsulation (hiding complexity) to create robust and modular applications.\n\nExample:\n\nPython\nclass Shape:\n    def area(self):\n        return \"Undefined\"\n\nclass Rectangle(Shape):\n    def __init__(self, length, width):\n        self.length = length\n        self.width = width\n\n    def area(self):\n        return self.length * self.width\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14 * self.radius ** 2\n\nshapes = [Rectangle(2, 3), Circle(5)]\nfor shape in shapes:\n    print(f\"Area: {shape.area()}\")\n\n\nExplanation:\n\nThe code showcases polymorphism using a parent class Shape and child classes Rectangle and Circle.\nParent Class Shape: Contains a generic area method returning \u201cUndefined\u201d, acting as a placeholder for derived classes to override.\nChild Class Rectangle: Initializes length and width via the __init__ constructor. Overrides the area method to return the rectangle\u2019s area as length * width.\nChild Class Circle: Initializes radius via the __init__ constructor. Overrides the area method to return the circle\u2019s area as 3.14 * radius^2.\nPolymorphic Behavior: A list of shape objects (Rectangle and Circle) is created. A for loop iterates through the list, calling the area method on each object. The method executed is determined by the object\u2019s type, showcasing polymorphism.\nTypes of Polymorphism\nCompile-time Polymorphism\nFound in statically typed languages like Java or C++, where the behavior of a function or operator is resolved during the program\u2019s compilation phase.\nExamples include method overloading and operator overloading, where multiple functions or operators can share the same name but perform different tasks based on the context.\nIn Python, which is dynamically typed, compile-time polymorphism is not natively supported. Instead, Python uses techniques like dynamic typing and duck typing to achieve similar flexibility.\nRuntime Polymorphism\nOccurs when the behavior of a method is determined at runtime based on the type of the object.\nIn Python, this is achieved through method overriding: a child class can redefine a method from its parent class to provide its own specific implementation.\nPython\u2019s dynamic nature allows it to excel at runtime polymorphism, enabling flexible and adaptable code.\nExample:\nPython\nclass Animal:\n    def sound(self):\n        return \"Some generic sound\"\n\nclass Dog(Animal):\n    def sound(self):\n        return \"Bark\"\n\nclass Cat(Animal):\n    def sound(self):\n        return \"Meow\"\n\n# Polymorphic behavior\nanimals = [Dog(), Cat(), Animal()]\nfor animal in animals:\n    print(animal.sound())  # Calls the overridden method based on the object type\n\n\nOutput\nBark\nMeow\nSome generic sound\n\n\nExplanation: Here, the sound method behaves differently depending on whether the object is a Dog, Cat or Animal and this decision happens at runtime. This dynamic nature makes Python particularly powerful for runtime polymorphism.\n\nInheritance Class Polymorphism\n\nInheritance-based polymorphism occurs when a subclass overrides a method from its parent class, providing a specific implementation. This process of re-implementing a method in the child class is known as Method Overriding.\u00a0\u00a0\n\nExample:\n\nPython\nclass Animal:\n    def sound(self):\n        return \"Some generic animal sound\"\n\nclass Dog(Animal):\n    def sound(self):\n        return \"Bark\"\n\nclass Cat(Animal):\n    def sound(self):\n        return \"Meow\n\n\nExplanation:\n\nClass Animal: Acts as the base (parent) class. Contains a method sound that provides a default behavior, returning \u201cSome generic animal sound\u201d. This serves as a generic representation of the sound method for all animals.\nClass Dog: Inherits from the Animal class (denoted by class Dog(Animal)). Overrides the sound method to return \u201cWoof Woof!\u201d, a behavior specific to dogs. This demonstrates method overriding, where the subclass modifies the implementation of the parent class\u2019s method.\nClass Cat: Inherits from the Animal class (denoted by class Cat(Animal)). Overrides the sound method to return \u201cMeow\u201d, a behavior specific to cats. Like Dog, this also demonstrates method overriding.\n\u00a0Polymorphism in Python \u2013 FAQs\nWhat is method overriding in polymorphism?\n\nMethod overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. This allows the subclass to customize or completely replace the behavior of the method inherited from the superclass.\n\n\n\n\nExample:\n\n\n\nclass Animal:\n    def sound(self):\n        return \"Some sound\"\n\nclass Dog(Animal):\n    def sound(self):\n        return \"Bark\"\n\ndog = Dog()\nprint(dog.sound())  # Output: \"Bark\"\nHow to achieve polymorphism using class inheritance?\n\nPolymorphism can be achieved using class inheritance by defining a common interface in a base class and then providing specific implementations in derived classes. This allows objects of different classes to be treated as objects of a common superclass.\n\n\n\n\nExample:\n\n\n\nclass Shape:\n    def draw(self):\n        raise NotImplementedError(\"Subclass must implement abstract method\")\n\nclass Circle(Shape):\n    def draw(self):\n        return \"Drawing a circle\"\n\nclass Square(Shape):\n    def draw(self):\n        return \"Drawing a square\"\n\nshapes = [Circle(), Square()]\nfor shape in shapes:\n    print(shape.draw())\n# Output:\n# Drawing a circle\n# Drawing a square\nCan polymorphism be achieved with functions in Python?\n\nYes, polymorphism can be achieved with functions in Python through duck typing, where the method or function operates on any object that supports the required method or attribute, regardless of the object\u2019s class.\n\n\n\n\nExample:\n\n\n\ndef make_sound(animal):\n    return animal.sound()\n\nclass Dog:\n    def sound(self):\n        return \"Bark\"\n\nclass Cat:\n    def sound(self):\n        return \"Meow\"\n\nanimals = [Dog(), Cat()]\nfor animal in animals:\n    print(make_sound(animal))\n# Output:\n# Bark\n# Meow\nHow does polymorphism help in writing flexible and maintainable code?\n\nPolymorphism allows you to write more flexible and maintainable code by enabling you to use a single interface to represent different underlying forms (data types). This means you can add new classes with their own implementations without altering the existing code, making it easier to extend and maintain.\n\n\n\n\nExample:\n\n\n\nclass Vehicle:\n    def move(self):\n        raise NotImplementedError(\"Subclass must implement abstract method\")\n\nclass Car(Vehicle):\n    def move(self):\n        return \"Car is moving\"\n\nclass Bike(Vehicle):\n    def move(self):\n        return \"Bike is moving\"\n\nvehicles = [Car(), Bike()]\nfor vehicle in vehicles:\n    print(vehicle.move())\n# Output:\n# Car is moving\n# Bike is moving\nWhat is the role of abstract base classes in polymorphism?\n\nAbstract base classes (ABCs) define a common interface for a group of subclasses. They cannot be instantiated themselves and require subclasses to provide implementations for their abstract methods. ABCs ensure that derived classes adhere to a specific protocol, thus supporting polymorphism.\n\n\n\n\nExample:\n\n\n\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def sound(self):\n        pass\n\nclass Dog(Animal):\n    def sound(self):\n        return \"Bark\"\n\nclass Cat(Animal):\n    def sound(self):\n        return \"Meow\"\n\nanimals = [Dog(), Cat()]\nfor animal in animals:\n    print(animal.sound())\n# Output:\n# Bark\n# Meow\n\n\n\n\nComment\nMore info\nAdvertise with us\nNext Article \nPython | Method Overloading\nSimilar Reads\nPython OOPs Concepts\nObject Oriented Programming is a fundamental concept in Python, empowering developers to build modular, maintainable, and scalable applications. By understanding the core OOP principles (classes, objects, inheritance, encapsulation, polymorphism, and abstraction), programmers can leverage the full p\n11 min read\nPython Classes and Objects\nA class in Python is a user-defined template for creating objects. It bundles data and functions together, making it easier to manage and use them. When we create a new class, we define a new type of object. We can then create multiple instances of this object type. Classes are created using class k\n6 min read\nPython objects\nA class is a user-defined blueprint or prototype from which objects are created. Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to\n2 min read\nClass and Object\nEncapsulation and Access Modifiers\nInheritance\nPolymorphism\nPolymorphism in Python\nPolymorphism is a foundational concept in programming that allows entities like functions, methods or operators to behave differently based on the type of data they are handling. Derived from Greek, the term literally means \"many forms\". Python's dynamic typing and duck typing make it inherently pol\n7 min read\nPython | Method Overloading\nMethod Overloading: Two or more methods have the same name but different numbers of parameters or different types of parameters, or both. These methods are called overloaded methods and this is called method overloading. Like other languages (for example, method overloading in C++) do, python does n\n7 min read\nMethod Overriding in Python\nMethod overriding is an ability of any object-oriented programming language that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes. When a method in a subclass has the same name, the same parameter\n7 min read\nAbstraction\nSpecial Methods and Testing\nAdditional Resources\nCorporate & Communications Address:\nA-143, 7th Floor, Sovereign Corporate Tower, Sector- 136, Noida, Uttar Pradesh (201305)\nRegistered Address:\nK 061, Tower K, Gulshan Vivante Apartment, Sector 137, Noida, Gautam Buddh Nagar, Uttar Pradesh, 201305\nAdvertise with us\nCompany\nAbout Us\nLegal\nPrivacy Policy\nIn Media\nContact Us\nAdvertise with us\nGFG Corporate Solution\nPlacement Training Program\nGeeksforGeeks Community\nLanguages\nPython\nJava\nC++\nPHP\nGoLang\nSQL\nR Language\nAndroid Tutorial\nTutorials Archive\nDSA\nData Structures\nAlgorithms\nDSA for Beginners\nBasic DSA Problems\nDSA Roadmap\nTop 100 DSA Interview Problems\nDSA Roadmap by Sandeep Jain\nAll Cheat Sheets\nData Science & ML\nData Science With Python\nData Science For Beginner\nMachine Learning\nML Maths\nData Visualisation\nPandas\nNumPy\nNLP\nDeep Learning\nWeb Technologies\nHTML\nCSS\nJavaScript\nTypeScript\nReactJS\nNextJS\nBootstrap\nWeb Design\nPython Tutorial\nPython Programming Examples\nPython Projects\nPython Tkinter\nWeb Scraping\nOpenCV Tutorial\nPython Interview Question\nDjango\nComputer Science\nOperating Systems\nComputer Network\nDatabase Management System\nSoftware Engineering\nDigital Logic Design\nEngineering Maths\nSoftware Development\nSoftware Testing\nDevOps\nGit\nLinux\nAWS\nDocker\nKubernetes\nAzure\nGCP\nDevOps Roadmap\nSystem Design\nHigh Level Design\nLow Level Design\nUML Diagrams\nInterview Guide\nDesign Patterns\nOOAD\nSystem Design Bootcamp\nInterview Questions\nInteview Preparation\nCompetitive Programming\nTop DS or Algo for CP\nCompany-Wise Recruitment Process\nCompany-Wise Preparation\nAptitude Preparation\nPuzzles\nSchool Subjects\nMathematics\nPhysics\nChemistry\nBiology\nSocial Science\nEnglish Grammar\nCommerce\nWorld GK\nGeeksforGeeks Videos\nDSA\nPython\nJava\nC++\nWeb Development\nData Science\nCS Subjects\n@GeeksforGeeks, Sanchhaya Education Private Limited, All rights reserved\nWe use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy\nGot It !\n\nSkip to content\nCourses\nTutorials\nDSA\nData Science\nWeb Tech\nPython Tutorial\nInterview Questions\nPython Quiz\nPython Projects\nPractice Python\nData Science With Python\nPython Web Dev\nDSA with Python\nPython OOPs\nLists\nStrings\nDictionary\nNext Article:\nAccess Modifiers in Python : Public, Private and Protected\nEncapsulation in Python\nLast Updated : 27 Feb, 2025\n\nIn Python, encapsulation refers to the bundling of data (attributes) and methods (functions) that operate on the data into a single unit, typically a class. It also restricts direct access to some components, which helps protect the integrity of the data and ensures proper usage.\n\nTable of Content\n\nEncapsulation in Python\nExample of Encapsulation\nPublic Members\nProtected members\nPrivate members\n\nEncapsulation is the process of hiding the internal state of an object and requiring all interactions to be performed through an object\u2019s methods. This approach:\n\nProvides better control over data.\nPrevents accidental modification of data.\nPromotes modular programming.\n\nPython achieves encapsulation through public, protected and private attributes.\n\nEncapsulation Python\n\nHow Encapsulation Works :\nData Hiding: The variables (attributes) are kept private or protected, meaning they are not accessible directly from outside the class. Instead, they can only be accessed or modified through the methods.\nAccess through Methods: Methods act as the interface through which external code interacts with the data stored in the variables. For instance, getters and setters are common methods used to retrieve and update the value of a private variable.\nControl and Security: By encapsulating the variables and only allowing their manipulation via methods, the class can enforce rules on how the variables are accessed or modified, thus maintaining control and security over the data.\nExample of Encapsulation\n\nEncapsulation in Python is like having a bank account system where your account balance (data) is kept private. You can\u2019t directly change your balance by accessing the account database. Instead, the bank provides you with methods (functions) like deposit and withdraw to modify your balance safely.\n\nPrivate Data (Balance): Your balance is stored securely. Direct access from outside is not allowed, ensuring the data is protected from unauthorized changes.\nPublic Methods (Deposit and Withdraw): These are the only ways to modify your balance. They check if your requests (like withdrawing money) follow the rules (e.g., you have enough balance) before allowing changes.\nPublic Members\n\nPublic members are accessible from anywhere, both inside and outside the class. These are the default members in Python.\n\nExample:\n\nPython\nclass Public:\n    def __init__(self):\n        self.name = \"John\"  # Public attribute\n\n    def display_name(self):\n        print(self.name)  # Public method\n\nobj = Public()\nobj.display_name()  # Accessible\nprint(obj.name)  # Accessible\n\n\nExplanation:\n\nPublic Attribute (name): This attribute is declared without any underscore prefixes. It is accessible from anywhere, both inside and outside of the class.\nPublic Method (display_name): This method is also accessible from any part of the code. It directly accesses the public attribute and prints its value.\nObject (obj): An instance of Public is created, and the display_name method is called, demonstrating how public attributes and methods can be accessed directly.\n\nNote: The __init__ method is a constructor and runs as soon as an object of a class is instantiated.\u00a0\u00a0\n\nProtected members\n\nProtected members are identified with a single underscore (_). They are meant to be accessed only within the class or its subclasses.\n\nExample:\n\nPython\nclass Protected:\n    def __init__(self):\n        self._age = 30  # Protected attribute\n\nclass Subclass(Protected):\n    def display_age(self):\n        print(self._age)  # Accessible in subclass\n\nobj = Subclass()\nobj.display_age()\n\n\nExplanation:\n\nProtected Attribute (_age): This attribute is prefixed with a single underscore, which by convention, suggests that it should be treated as a protected member. It\u2019s not enforced by Python but indicates that it should not be accessed outside of this class and its subclasses.\nSubclass: Here, a subclass inherits from Protected. Within this subclass, we can still access the protected attribute _age.\nMethod (display_age): This method within the subclass accesses the protected attribute and prints its value. This shows that protected members can be accessed within the class and its subclasses.\nPrivate members\n\nPrivate members are identified with a double underscore (__) and cannot be accessed directly from outside the class. Python uses name mangling to make private members inaccessible by renaming them internally.\n\nNote: Python\u2019s private and protected members can be accessed outside the class through python name mangling.\u00a0\n\nPython\nclass Private:\n    def __init__(self):\n        self.__salary = 50000  # Private attribute\n\n    def salary(self):\n        return self.__salary  # Access through public method\n\nobj = Private()\nprint(obj.salary())  # Works\n#print(obj.__salary)  # Raises AttributeError\n\n\nExplanation:\n\nPrivate Attribute (__salary): This attribute is prefixed with two underscores, which makes it a private member. Python enforces privacy by name mangling, which means it renames the attribute in a way that makes it hard to access from outside the class.\nMethod (salary): This public method provides the only way to access the private attribute from outside the class. It safely returns the value of __salary.\nDirect Access Attempt: Trying to access the private attribute directly (obj.__salary) will result in an AttributeError, showing that direct access is blocked. This is Python\u2019s way of enforcing encapsulation at a language level.\nEncapsulation in Python \u2013 FAQs\nWhat is Encapsulation in Python Programming?\n\nEncapsulation is an Object-Oriented Programming (OOP) principle that involves bundling the data (attributes) and methods (functions) that operate on the data into a single unit, called a class. This concept helps hide the internal state of an object from the outside world, providing a controlled interface for interacting with the object\u2019s data and methods.\n\n\n\nHow to Implement Encapsulation in Python Classes?\n\nEncapsulation in Python is implemented using access specifiers to control access to class members:\n\n\n\nPublic Members: By default, attributes and methods are public and can be accessed from outside the class.\nProtected Members: Use a single underscore (_) prefix to indicate that an attribute or method is intended for internal use within the class and its subclasses.\nPrivate Members: Use double underscores (__) prefix to make an attribute or method private. This leads to name mangling, making it more challenging to access from outside the class.\nWhat are Private and Protected Members in Python Classes?\nPrivate Members: Members with double underscores (__) are private. They are intended to be accessed only within the class where they are defined. Python uses name mangling to make these members harder to access from outside the class.\nProtected Members: Members with a single underscore (_) are protected. They are intended for use within the class and its subclasses. This is a convention and does not enforce strict access control.\nHow Does Encapsulation Benefit Python Code Organization?\nControlled Access: Encapsulation allows controlled access to the internal state of an object, protecting the data from unintended interference.\nData Hiding: It hides the internal workings of a class, making the implementation details invisible to outside code and reducing the risk of accidental data modification.\nImproved Maintenance: Changes to the internal implementation of a class do not affect code that uses the class, as long as the public interface remains unchanged.\nEnhanced Flexibility: Encapsulation promotes modular design, making it easier to modify or extend functionality without impacting other parts of the program.\nWhat are Key Differences Between Encapsulation and Abstraction?\nEncapsulation:\nDefinition: The bundling of data and methods that operate on the data into a single unit, with controlled access to the internal state.\nPurpose: To protect an object\u2019s internal state and expose a controlled interface.\nImplementation: Achieved through private and protected members.\nAbstraction:\nDefinition: The concept of hiding complex implementation details and showing only the essential features of an object.\nPurpose: To simplify interaction with objects by focusing on high-level operations rather than implementation details.\nImplementation: Achieved through abstract classes and methods, interfaces, and high-level class design.\n\n\n\n\nComment\nMore info\nAdvertise with us\nNext Article \nAccess Modifiers in Python : Public, Private and Protected\nSimilar Reads\nPython OOPs Concepts\nObject Oriented Programming is a fundamental concept in Python, empowering developers to build modular, maintainable, and scalable applications. By understanding the core OOP principles (classes, objects, inheritance, encapsulation, polymorphism, and abstraction), programmers can leverage the full p\n11 min read\nPython Classes and Objects\nA class in Python is a user-defined template for creating objects. It bundles data and functions together, making it easier to manage and use them. When we create a new class, we define a new type of object. We can then create multiple instances of this object type. Classes are created using class k\n6 min read\nPython objects\nA class is a user-defined blueprint or prototype from which objects are created. Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to\n2 min read\nClass and Object\nEncapsulation and Access Modifiers\nEncapsulation in Python\nIn Python, encapsulation refers to the bundling of data (attributes) and methods (functions) that operate on the data into a single unit, typically a class. It also restricts direct access to some components, which helps protect the integrity of the data and ensures proper usage. Table of Content En\n6 min read\nAccess Modifiers in Python : Public, Private and Protected\nPrerequisites: Underscore (_) in Python, Private Variables in Python Encapsulation is one of the four principles used in Object Oriented Paradigm. It is used to bind and hide data to the class. Data hiding is also referred as Scoping and the accessibility of a method or a field of a class can be cha\n9 min read\nAccess Modifiers in Python : Public, Private and Protected\nPrerequisites: Underscore (_) in Python, Private Variables in Python Encapsulation is one of the four principles used in Object Oriented Paradigm. It is used to bind and hide data to the class. Data hiding is also referred as Scoping and the accessibility of a method or a field of a class can be cha\n9 min read\nPrivate Variables in Python\nPrerequisite: Underscore in PythonIn Python, there is no existence of \u00e2\u20ac\u0153Private\u00e2\u20ac\u009d instance variables that cannot be accessed except inside an object. However, a convention is being followed by most Python code and coders i.e., a name prefixed with an underscore, For e.g. _geek should be treated as a n\n3 min read\nPrivate Methods in Python\nEncapsulation is one of the fundamental concepts in object-oriented programming (OOP) in Python. It describes the idea of wrapping data and the methods that work on data within one unit. This puts restrictions on accessing variables and methods directly and can prevent the accidental modification of\n6 min read\nProtected variable in Python\nPrerequisites: Underscore ( _ ) in Python A Variable is an\u00c2\u00a0identifier\u00c2\u00a0that we\u00c2\u00a0assign to a\u00c2\u00a0memory location\u00c2\u00a0which is\u00c2\u00a0used to hold values in a computer program. Variables are named locations of storage in the program. Based on access specification, variables can be public, protected and private in a cl\n2 min read\nInheritance\nPolymorphism\nAbstraction\nSpecial Methods and Testing\nAdditional Resources\nCorporate & Communications Address:\nA-143, 7th Floor, Sovereign Corporate Tower, Sector- 136, Noida, Uttar Pradesh (201305)\nRegistered Address:\nK 061, Tower K, Gulshan Vivante Apartment, Sector 137, Noida, Gautam Buddh Nagar, Uttar Pradesh, 201305\nAdvertise with us\nCompany\nAbout Us\nLegal\nPrivacy Policy\nIn Media\nContact Us\nAdvertise with us\nGFG Corporate Solution\nPlacement Training Program\nGeeksforGeeks Community\nLanguages\nPython\nJava\nC++\nPHP\nGoLang\nSQL\nR Language\nAndroid Tutorial\nTutorials Archive\nDSA\nData Structures\nAlgorithms\nDSA for Beginners\nBasic DSA Problems\nDSA Roadmap\nTop 100 DSA Interview Problems\nDSA Roadmap by Sandeep Jain\nAll Cheat Sheets\nData Science & ML\nData Science With Python\nData Science For Beginner\nMachine Learning\nML Maths\nData Visualisation\nPandas\nNumPy\nNLP\nDeep Learning\nWeb Technologies\nHTML\nCSS\nJavaScript\nTypeScript\nReactJS\nNextJS\nBootstrap\nWeb Design\nPython Tutorial\nPython Programming Examples\nPython Projects\nPython Tkinter\nWeb Scraping\nOpenCV Tutorial\nPython Interview Question\nDjango\nComputer Science\nOperating Systems\nComputer Network\nDatabase Management System\nSoftware Engineering\nDigital Logic Design\nEngineering Maths\nSoftware Development\nSoftware Testing\nDevOps\nGit\nLinux\nAWS\nDocker\nKubernetes\nAzure\nGCP\nDevOps Roadmap\nSystem Design\nHigh Level Design\nLow Level Design\nUML Diagrams\nInterview Guide\nDesign Patterns\nOOAD\nSystem Design Bootcamp\nInterview Questions\nInteview Preparation\nCompetitive Programming\nTop DS or Algo for CP\nCompany-Wise Recruitment Process\nCompany-Wise Preparation\nAptitude Preparation\nPuzzles\nSchool Subjects\nMathematics\nPhysics\nChemistry\nBiology\nSocial Science\nEnglish Grammar\nCommerce\nWorld GK\nGeeksforGeeks Videos\nDSA\nPython\nJava\nC++\nWeb Development\nData Science\nCS Subjects\n@GeeksforGeeks, Sanchhaya Education Private Limited, All rights reserved\nWe use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy\nGot It !\n\nindex\nmodules |\nnext |\nprevious |\n Python \u00bb \nEnglish\nSpanish | espa\u00f1ol\nFrench | fran\u00e7ais\nItalian | italiano\nJapanese | \u65e5\u672c\u8a9e\nKorean | \ud55c\uad6d\uc5b4\nPolish | polski\nBrazilian Portuguese | Portugu\u00eas brasileiro\nTurkish | T\u00fcrk\u00e7e\nSimplified Chinese | \u7b80\u4f53\u4e2d\u6587\nTraditional Chinese | \u7e41\u9ad4\u4e2d\u6587\ndev (3.14)\n3.13.2\n3.12\n3.11\n3.10\n3.9\n3.8\n3.7\n3.6\n3.5\n3.4\n3.3\n3.2\n3.1\n3.0\n2.7\n2.6\n 3.13.2 Documentation \u00bb The Python Language Reference \u00bb 3. Data model\n  |\nTheme \nAuto\nLight\nDark\n |\n3. Data model\n3.1. Objects, values and types\n\nObjects are Python\u2019s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann\u2019s model of a \u201cstored program computer\u201d, code is also represented by objects.)\n\nEvery object has an identity, a type and a value. An object\u2019s identity never changes once it has been created; you may think of it as the object\u2019s address in memory. The is operator compares the identity of two objects; the id() function returns an integer representing its identity.\n\nCPython implementation detail: For CPython, id(x) is the memory address where x is stored.\n\nAn object\u2019s type determines the operations that the object supports (e.g., \u201cdoes it have a length?\u201d) and also defines the possible values for objects of that type. The type() function returns an object\u2019s type (which is an object itself). Like its identity, an object\u2019s type is also unchangeable. [1]\n\nThe value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable. (The value of an immutable container object that contains a reference to a mutable object can change when the latter\u2019s value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed. So, immutability is not strictly the same as having an unchangeable value, it is more subtle.) An object\u2019s mutability is determined by its type; for instance, numbers, strings and tuples are immutable, while dictionaries and lists are mutable.\n\nObjects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected. An implementation is allowed to postpone garbage collection or omit it altogether \u2014 it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable.\n\nCPython implementation detail: CPython currently uses a reference-counting scheme with (optional) delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing circular references. See the documentation of the gc module for information on controlling the collection of cyclic garbage. Other implementations act differently and CPython may change. Do not depend on immediate finalization of objects when they become unreachable (so you should always close files explicitly).\n\nNote that the use of the implementation\u2019s tracing or debugging facilities may keep objects alive that would normally be collectable. Also note that catching an exception with a try\u2026except statement may keep objects alive.\n\nSome objects contain references to \u201cexternal\u201d resources such as open files or windows. It is understood that these resources are freed when the object is garbage-collected, but since garbage collection is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually a close() method. Programs are strongly recommended to explicitly close such objects. The try\u2026finally statement and the with statement provide convenient ways to do this.\n\nSome objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries. The references are part of a container\u2019s value. In most cases, when we talk about the value of a container, we imply the values, not the identities of the contained objects; however, when we talk about the mutability of a container, only the identities of the immediately contained objects are implied. So, if an immutable container (like a tuple) contains a reference to a mutable object, its value changes if that mutable object is changed.\n\nTypes affect almost all aspects of object behavior. Even the importance of object identity is affected in some sense: for immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. For example, after a = 1; b = 1, a and b may or may not refer to the same object with the value one, depending on the implementation. This is because int is an immutable type, so the reference to 1 can be reused. This behaviour depends on the implementation used, so should not be relied upon, but is something to be aware of when making use of object identity tests. However, after c = []; d = [], c and d are guaranteed to refer to two different, unique, newly created empty lists. (Note that e = f = [] assigns the same object to both e and f.)\n\n3.2. The standard type hierarchy\n\nBelow is a list of the types that are built into Python. Extension modules (written in C, Java, or other languages, depending on the implementation) can define additional types. Future versions of Python may add types to the type hierarchy (e.g., rational numbers, efficiently stored arrays of integers, etc.), although such additions will often be provided via the standard library instead.\n\nSome of the type descriptions below contain a paragraph listing \u2018special attributes.\u2019 These are attributes that provide access to the implementation and are not intended for general use. Their definition may change in the future.\n\n3.2.1. None\n\nThis type has a single value. There is a single object with this value. This object is accessed through the built-in name None. It is used to signify the absence of a value in many situations, e.g., it is returned from functions that don\u2019t explicitly return anything. Its truth value is false.\n\n3.2.2. NotImplemented\n\nThis type has a single value. There is a single object with this value. This object is accessed through the built-in name NotImplemented. Numeric methods and rich comparison methods should return this value if they do not implement the operation for the operands provided. (The interpreter will then try the reflected operation, or some other fallback, depending on the operator.) It should not be evaluated in a boolean context.\n\nSee Implementing the arithmetic operations for more details.\n\nChanged in version 3.9: Evaluating NotImplemented in a boolean context is deprecated. While it currently evaluates as true, it will emit a DeprecationWarning. It will raise a TypeError in a future version of Python.\n\n3.2.3. Ellipsis\n\nThis type has a single value. There is a single object with this value. This object is accessed through the literal ... or the built-in name Ellipsis. Its truth value is true.\n\n3.2.4. numbers.Number\n\nThese are created by numeric literals and returned as results by arithmetic operators and arithmetic built-in functions. Numeric objects are immutable; once created their value never changes. Python numbers are of course strongly related to mathematical numbers, but subject to the limitations of numerical representation in computers.\n\nThe string representations of the numeric classes, computed by __repr__() and __str__(), have the following properties:\n\nThey are valid numeric literals which, when passed to their class constructor, produce an object having the value of the original numeric.\n\nThe representation is in base 10, when possible.\n\nLeading zeros, possibly excepting a single zero before a decimal point, are not shown.\n\nTrailing zeros, possibly excepting a single zero after a decimal point, are not shown.\n\nA sign is shown only when the number is negative.\n\nPython distinguishes between integers, floating-point numbers, and complex numbers:\n\n3.2.4.1. numbers.Integral\n\nThese represent elements from the mathematical set of integers (positive and negative).\n\nNote\n\n \n\nThe rules for integer representation are intended to give the most meaningful interpretation of shift and mask operations involving negative integers.\n\nThere are two types of integers:\n\nIntegers (int)\n\nThese represent numbers in an unlimited range, subject to available (virtual) memory only. For the purpose of shift and mask operations, a binary representation is assumed, and negative numbers are represented in a variant of 2\u2019s complement which gives the illusion of an infinite string of sign bits extending to the left.\n\nBooleans (bool)\n\nThese represent the truth values False and True. The two objects representing the values False and True are the only Boolean objects. The Boolean type is a subtype of the integer type, and Boolean values behave like the values 0 and 1, respectively, in almost all contexts, the exception being that when converted to a string, the strings \"False\" or \"True\" are returned, respectively.\n\n3.2.4.2. numbers.Real (float)\n\nThese represent machine-level double precision floating-point numbers. You are at the mercy of the underlying machine architecture (and C or Java implementation) for the accepted range and handling of overflow. Python does not support single-precision floating-point numbers; the savings in processor and memory usage that are usually the reason for using these are dwarfed by the overhead of using objects in Python, so there is no reason to complicate the language with two kinds of floating-point numbers.\n\n3.2.4.3. numbers.Complex (complex)\n\nThese represent complex numbers as a pair of machine-level double precision floating-point numbers. The same caveats apply as for floating-point numbers. The real and imaginary parts of a complex number z can be retrieved through the read-only attributes z.real and z.imag.\n\n3.2.5. Sequences\n\nThese represent finite ordered sets indexed by non-negative numbers. The built-in function len() returns the number of items of a sequence. When the length of a sequence is n, the index set contains the numbers 0, 1, \u2026, n-1. Item i of sequence a is selected by a[i]. Some sequences, including built-in sequences, interpret negative subscripts by adding the sequence length. For example, a[-2] equals a[n-2], the second to last item of sequence a with length n.\n\nSequences also support slicing: a[i:j] selects all items with index k such that i <= k < j. When used as an expression, a slice is a sequence of the same type. The comment above about negative indexes also applies to negative slice positions.\n\nSome sequences also support \u201cextended slicing\u201d with a third \u201cstep\u201d parameter: a[i:j:k] selects all items of a with index x where x = i + n*k, n >= 0 and i <= x < j.\n\nSequences are distinguished according to their mutability:\n\n3.2.5.1. Immutable sequences\n\nAn object of an immutable sequence type cannot change once it is created. (If the object contains references to other objects, these other objects may be mutable and may be changed; however, the collection of objects directly referenced by an immutable object cannot change.)\n\nThe following types are immutable sequences:\n\nStrings\n\nA string is a sequence of values that represent Unicode code points. All the code points in the range U+0000 - U+10FFFF can be represented in a string. Python doesn\u2019t have a char type; instead, every code point in the string is represented as a string object with length 1. The built-in function ord() converts a code point from its string form to an integer in the range 0 - 10FFFF; chr() converts an integer in the range 0 - 10FFFF to the corresponding length 1 string object. str.encode() can be used to convert a str to bytes using the given text encoding, and bytes.decode() can be used to achieve the opposite.\n\nTuples\n\nThe items of a tuple are arbitrary Python objects. Tuples of two or more items are formed by comma-separated lists of expressions. A tuple of one item (a \u2018singleton\u2019) can be formed by affixing a comma to an expression (an expression by itself does not create a tuple, since parentheses must be usable for grouping of expressions). An empty tuple can be formed by an empty pair of parentheses.\n\nBytes\n\nA bytes object is an immutable array. The items are 8-bit bytes, represented by integers in the range 0 <= x < 256. Bytes literals (like b'abc') and the built-in bytes() constructor can be used to create bytes objects. Also, bytes objects can be decoded to strings via the decode() method.\n\n3.2.5.2. Mutable sequences\n\nMutable sequences can be changed after they are created. The subscription and slicing notations can be used as the target of assignment and del (delete) statements.\n\nNote\n\n \n\nThe collections and array module provide additional examples of mutable sequence types.\n\nThere are currently two intrinsic mutable sequence types:\n\nLists\n\nThe items of a list are arbitrary Python objects. Lists are formed by placing a comma-separated list of expressions in square brackets. (Note that there are no special cases needed to form lists of length 0 or 1.)\n\nByte Arrays\n\nA bytearray object is a mutable array. They are created by the built-in bytearray() constructor. Aside from being mutable (and hence unhashable), byte arrays otherwise provide the same interface and functionality as immutable bytes objects.\n\n3.2.6. Set types\n\nThese represent unordered, finite sets of unique, immutable objects. As such, they cannot be indexed by any subscript. However, they can be iterated over, and the built-in function len() returns the number of items in a set. Common uses for sets are fast membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference.\n\nFor set elements, the same immutability rules apply as for dictionary keys. Note that numeric types obey the normal rules for numeric comparison: if two numbers compare equal (e.g., 1 and 1.0), only one of them can be contained in a set.\n\nThere are currently two intrinsic set types:\n\nSets\n\nThese represent a mutable set. They are created by the built-in set() constructor and can be modified afterwards by several methods, such as add().\n\nFrozen sets\n\nThese represent an immutable set. They are created by the built-in frozenset() constructor. As a frozenset is immutable and hashable, it can be used again as an element of another set, or as a dictionary key.\n\n3.2.7. Mappings\n\nThese represent finite sets of objects indexed by arbitrary index sets. The subscript notation a[k] selects the item indexed by k from the mapping a; this can be used in expressions and as the target of assignments or del statements. The built-in function len() returns the number of items in a mapping.\n\nThere is currently a single intrinsic mapping type:\n\n3.2.7.1. Dictionaries\n\nThese represent finite sets of objects indexed by nearly arbitrary values. The only types of values not acceptable as keys are values containing lists or dictionaries or other mutable types that are compared by value rather than by object identity, the reason being that the efficient implementation of dictionaries requires a key\u2019s hash value to remain constant. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (e.g., 1 and 1.0) then they can be used interchangeably to index the same dictionary entry.\n\nDictionaries preserve insertion order, meaning that keys will be produced in the same order they were added sequentially over the dictionary. Replacing an existing key does not change the order, however removing a key and re-inserting it will add it to the end instead of keeping its old place.\n\nDictionaries are mutable; they can be created by the {} notation (see section Dictionary displays).\n\nThe extension modules dbm.ndbm and dbm.gnu provide additional examples of mapping types, as does the collections module.\n\nChanged in version 3.7: Dictionaries did not preserve insertion order in versions of Python before 3.6. In CPython 3.6, insertion order was preserved, but it was considered an implementation detail at that time rather than a language guarantee.\n\n3.2.8. Callable types\n\nThese are the types to which the function call operation (see section Calls) can be applied:\n\n3.2.8.1. User-defined functions\n\nA user-defined function object is created by a function definition (see section Function definitions). It should be called with an argument list containing the same number of items as the function\u2019s formal parameter list.\n\n3.2.8.1.1. Special read-only attributes\n\nAttribute\n\n\t\n\nMeaning\n\n\n\nfunction.__globals__\n\t\n\nA reference to the dictionary that holds the function\u2019s global variables \u2013 the global namespace of the module in which the function was defined.\n\n\n\nfunction.__closure__\n\t\n\nNone or a tuple of cells that contain bindings for the names specified in the co_freevars attribute of the function\u2019s code object.\n\nA cell object has the attribute cell_contents. This can be used to get the value of the cell, as well as set the value.\n\n3.2.8.1.2. Special writable attributes\n\nMost of these attributes check the type of the assigned value:\n\nAttribute\n\n\t\n\nMeaning\n\n\n\nfunction.__doc__\n\t\n\nThe function\u2019s documentation string, or None if unavailable.\n\n\n\nfunction.__name__\n\t\n\nThe function\u2019s name. See also: __name__ attributes.\n\n\n\nfunction.__qualname__\n\t\n\nThe function\u2019s qualified name. See also: __qualname__ attributes.\n\nAdded in version 3.3.\n\n\n\nfunction.__module__\n\t\n\nThe name of the module the function was defined in, or None if unavailable.\n\n\n\nfunction.__defaults__\n\t\n\nA tuple containing default parameter values for those parameters that have defaults, or None if no parameters have a default value.\n\n\n\nfunction.__code__\n\t\n\nThe code object representing the compiled function body.\n\n\n\nfunction.__dict__\n\t\n\nThe namespace supporting arbitrary function attributes. See also: __dict__ attributes.\n\n\n\nfunction.__annotations__\n\t\n\nA dictionary containing annotations of parameters. The keys of the dictionary are the parameter names, and 'return' for the return annotation, if provided. See also: Annotations Best Practices.\n\n\n\nfunction.__kwdefaults__\n\t\n\nA dictionary containing defaults for keyword-only parameters.\n\n\n\nfunction.__type_params__\n\t\n\nA tuple containing the type parameters of a generic function.\n\nAdded in version 3.12.\n\nFunction objects also support getting and setting arbitrary attributes, which can be used, for example, to attach metadata to functions. Regular attribute dot-notation is used to get and set such attributes.\n\nCPython implementation detail: CPython\u2019s current implementation only supports function attributes on user-defined functions. Function attributes on built-in functions may be supported in the future.\n\nAdditional information about a function\u2019s definition can be retrieved from its code object (accessible via the __code__ attribute).\n\n3.2.8.2. Instance methods\n\nAn instance method object combines a class, a class instance and any callable object (normally a user-defined function).\n\nSpecial read-only attributes:\n\nmethod.__self__\n\t\n\nRefers to the class instance object to which the method is bound\n\n\n\nmethod.__func__\n\t\n\nRefers to the original function object\n\n\n\nmethod.__doc__\n\t\n\nThe method\u2019s documentation (same as method.__func__.__doc__). A string if the original function had a docstring, else None.\n\n\n\nmethod.__name__\n\t\n\nThe name of the method (same as method.__func__.__name__)\n\n\n\nmethod.__module__\n\t\n\nThe name of the module the method was defined in, or None if unavailable.\n\nMethods also support accessing (but not setting) the arbitrary function attributes on the underlying function object.\n\nUser-defined method objects may be created when getting an attribute of a class (perhaps via an instance of that class), if that attribute is a user-defined function object or a classmethod object.\n\nWhen an instance method object is created by retrieving a user-defined function object from a class via one of its instances, its __self__ attribute is the instance, and the method object is said to be bound. The new method\u2019s __func__ attribute is the original function object.\n\nWhen an instance method object is created by retrieving a classmethod object from a class or instance, its __self__ attribute is the class itself, and its __func__ attribute is the function object underlying the class method.\n\nWhen an instance method object is called, the underlying function (__func__) is called, inserting the class instance (__self__) in front of the argument list. For instance, when C is a class which contains a definition for a function f(), and x is an instance of C, calling x.f(1) is equivalent to calling C.f(x, 1).\n\nWhen an instance method object is derived from a classmethod object, the \u201cclass instance\u201d stored in __self__ will actually be the class itself, so that calling either x.f(1) or C.f(1) is equivalent to calling f(C,1) where f is the underlying function.\n\nIt is important to note that user-defined functions which are attributes of a class instance are not converted to bound methods; this only happens when the function is an attribute of the class.\n\n3.2.8.3. Generator functions\n\nA function or method which uses the yield statement (see section The yield statement) is called a generator function. Such a function, when called, always returns an iterator object which can be used to execute the body of the function: calling the iterator\u2019s iterator.__next__() method will cause the function to execute until it provides a value using the yield statement. When the function executes a return statement or falls off the end, a StopIteration exception is raised and the iterator will have reached the end of the set of values to be returned.\n\n3.2.8.4. Coroutine functions\n\nA function or method which is defined using async def is called a coroutine function. Such a function, when called, returns a coroutine object. It may contain await expressions, as well as async with and async for statements. See also the Coroutine Objects section.\n\n3.2.8.5. Asynchronous generator functions\n\nA function or method which is defined using async def and which uses the yield statement is called a asynchronous generator function. Such a function, when called, returns an asynchronous iterator object which can be used in an async for statement to execute the body of the function.\n\nCalling the asynchronous iterator\u2019s aiterator.__anext__ method will return an awaitable which when awaited will execute until it provides a value using the yield expression. When the function executes an empty return statement or falls off the end, a StopAsyncIteration exception is raised and the asynchronous iterator will have reached the end of the set of values to be yielded.\n\n3.2.8.6. Built-in functions\n\nA built-in function object is a wrapper around a C function. Examples of built-in functions are len() and math.sin() (math is a standard built-in module). The number and type of the arguments are determined by the C function. Special read-only attributes:\n\n__doc__ is the function\u2019s documentation string, or None if unavailable. See function.__doc__.\n\n__name__ is the function\u2019s name. See function.__name__.\n\n__self__ is set to None (but see the next item).\n\n__module__ is the name of the module the function was defined in or None if unavailable. See function.__module__.\n\n3.2.8.7. Built-in methods\n\nThis is really a different disguise of a built-in function, this time containing an object passed to the C function as an implicit extra argument. An example of a built-in method is alist.append(), assuming alist is a list object. In this case, the special read-only attribute __self__ is set to the object denoted by alist. (The attribute has the same semantics as it does with other instance methods.)\n\n3.2.8.8. Classes\n\nClasses are callable. These objects normally act as factories for new instances of themselves, but variations are possible for class types that override __new__(). The arguments of the call are passed to __new__() and, in the typical case, to __init__() to initialize the new instance.\n\n3.2.8.9. Class Instances\n\nInstances of arbitrary classes can be made callable by defining a __call__() method in their class.\n\n3.2.9. Modules\n\nModules are a basic organizational unit of Python code, and are created by the import system as invoked either by the import statement, or by calling functions such as importlib.import_module() and built-in __import__(). A module object has a namespace implemented by a dictionary object (this is the dictionary referenced by the __globals__ attribute of functions defined in the module). Attribute references are translated to lookups in this dictionary, e.g., m.x is equivalent to m.__dict__[\"x\"]. A module object does not contain the code object used to initialize the module (since it isn\u2019t needed once the initialization is done).\n\nAttribute assignment updates the module\u2019s namespace dictionary, e.g., m.x = 1 is equivalent to m.__dict__[\"x\"] = 1.\n\n3.2.9.1. Import-related attributes on module objects\n\nModule objects have the following attributes that relate to the import system. When a module is created using the machinery associated with the import system, these attributes are filled in based on the module\u2019s spec, before the loader executes and loads the module.\n\nTo create a module dynamically rather than using the import system, it\u2019s recommended to use importlib.util.module_from_spec(), which will set the various import-controlled attributes to appropriate values. It\u2019s also possible to use the types.ModuleType constructor to create modules directly, but this technique is more error-prone, as most attributes must be manually set on the module object after it has been created when using this approach.\n\nCaution\n\n \n\nWith the exception of __name__, it is strongly recommended that you rely on __spec__ and its attributes instead of any of the other individual attributes listed in this subsection. Note that updating an attribute on __spec__ will not update the corresponding attribute on the module itself:\n\n>>>\n>>> import typing\n>>> typing.__name__, typing.__spec__.name\n('typing', 'typing')\n>>> typing.__spec__.name = 'spelling'\n>>> typing.__name__, typing.__spec__.name\n('typing', 'spelling')\n>>> typing.__name__ = 'keyboard_smashing'\n>>> typing.__name__, typing.__spec__.name\n('keyboard_smashing', 'spelling')\n\nmodule.__name__\n\nThe name used to uniquely identify the module in the import system. For a directly executed module, this will be set to \"__main__\".\n\nThis attribute must be set to the fully qualified name of the module. It is expected to match the value of module.__spec__.name.\n\nmodule.__spec__\n\nA record of the module\u2019s import-system-related state.\n\nSet to the module spec that was used when importing the module. See Module specs for more details.\n\nAdded in version 3.4.\n\nmodule.__package__\n\nThe package a module belongs to.\n\nIf the module is top-level (that is, not a part of any specific package) then the attribute should be set to '' (the empty string). Otherwise, it should be set to the name of the module\u2019s package (which can be equal to module.__name__ if the module itself is a package). See PEP 366 for further details.\n\nThis attribute is used instead of __name__ to calculate explicit relative imports for main modules. It defaults to None for modules created dynamically using the types.ModuleType constructor; use importlib.util.module_from_spec() instead to ensure the attribute is set to a str.\n\nIt is strongly recommended that you use module.__spec__.parent instead of module.__package__. __package__ is now only used as a fallback if __spec__.parent is not set, and this fallback path is deprecated.\n\nChanged in version 3.4: This attribute now defaults to None for modules created dynamically using the types.ModuleType constructor. Previously the attribute was optional.\n\nChanged in version 3.6: The value of __package__ is expected to be the same as __spec__.parent. __package__ is now only used as a fallback during import resolution if __spec__.parent is not defined.\n\nChanged in version 3.10: ImportWarning is raised if an import resolution falls back to __package__ instead of __spec__.parent.\n\nChanged in version 3.12: Raise DeprecationWarning instead of ImportWarning when falling back to __package__ during import resolution.\n\nDeprecated since version 3.13, will be removed in version 3.15: __package__ will cease to be set or taken into consideration by the import system or standard library.\n\nmodule.__loader__\n\nThe loader object that the import machinery used to load the module.\n\nThis attribute is mostly useful for introspection, but can be used for additional loader-specific functionality, for example getting data associated with a loader.\n\n__loader__ defaults to None for modules created dynamically using the types.ModuleType constructor; use importlib.util.module_from_spec() instead to ensure the attribute is set to a loader object.\n\nIt is strongly recommended that you use module.__spec__.loader instead of module.__loader__.\n\nChanged in version 3.4: This attribute now defaults to None for modules created dynamically using the types.ModuleType constructor. Previously the attribute was optional.\n\nDeprecated since version 3.12, will be removed in version 3.16: Setting __loader__ on a module while failing to set __spec__.loader is deprecated. In Python 3.16, __loader__ will cease to be set or taken into consideration by the import system or the standard library.\n\nmodule.__path__\n\nA (possibly empty) sequence of strings enumerating the locations where the package\u2019s submodules will be found. Non-package modules should not have a __path__ attribute. See __path__ attributes on modules for more details.\n\nIt is strongly recommended that you use module.__spec__.submodule_search_locations instead of module.__path__.\n\nmodule.__file__\nmodule.__cached__\n\n__file__ and __cached__ are both optional attributes that may or may not be set. Both attributes should be a str when they are available.\n\n__file__ indicates the pathname of the file from which the module was loaded (if loaded from a file), or the pathname of the shared library file for extension modules loaded dynamically from a shared library. It might be missing for certain types of modules, such as C modules that are statically linked into the interpreter, and the import system may opt to leave it unset if it has no semantic meaning (for example, a module loaded from a database).\n\nIf __file__ is set then the __cached__ attribute might also be set, which is the path to any compiled version of the code (for example, a byte-compiled file). The file does not need to exist to set this attribute; the path can simply point to where the compiled file would exist (see PEP 3147).\n\nNote that __cached__ may be set even if __file__ is not set. However, that scenario is quite atypical. Ultimately, the loader is what makes use of the module spec provided by the finder (from which __file__ and __cached__ are derived). So if a loader can load from a cached module but otherwise does not load from a file, that atypical scenario may be appropriate.\n\nIt is strongly recommended that you use module.__spec__.cached instead of module.__cached__.\n\nDeprecated since version 3.13, will be removed in version 3.15: Setting __cached__ on a module while failing to set __spec__.cached is deprecated. In Python 3.15, __cached__ will cease to be set or taken into consideration by the import system or standard library.\n\n3.2.9.2. Other writable attributes on module objects\n\nAs well as the import-related attributes listed above, module objects also have the following writable attributes:\n\nmodule.__doc__\n\nThe module\u2019s documentation string, or None if unavailable. See also: __doc__ attributes.\n\nmodule.__annotations__\n\nA dictionary containing variable annotations collected during module body execution. For best practices on working with __annotations__, please see Annotations Best Practices.\n\n3.2.9.3. Module dictionaries\n\nModule objects also have the following special read-only attribute:\n\nmodule.__dict__\n\nThe module\u2019s namespace as a dictionary object. Uniquely among the attributes listed here, __dict__ cannot be accessed as a global variable from within a module; it can only be accessed as an attribute on module objects.\n\nCPython implementation detail: Because of the way CPython clears module dictionaries, the module dictionary will be cleared when the module falls out of scope even if the dictionary still has live references. To avoid this, copy the dictionary or keep the module around while using its dictionary directly.\n\n3.2.10. Custom classes\n\nCustom class types are typically created by class definitions (see section Class definitions). A class has a namespace implemented by a dictionary object. Class attribute references are translated to lookups in this dictionary, e.g., C.x is translated to C.__dict__[\"x\"] (although there are a number of hooks which allow for other means of locating attributes). When the attribute name is not found there, the attribute search continues in the base classes. This search of the base classes uses the C3 method resolution order which behaves correctly even in the presence of \u2018diamond\u2019 inheritance structures where there are multiple inheritance paths leading back to a common ancestor. Additional details on the C3 MRO used by Python can be found at The Python 2.3 Method Resolution Order.\n\nWhen a class attribute reference (for class C, say) would yield a class method object, it is transformed into an instance method object whose __self__ attribute is C. When it would yield a staticmethod object, it is transformed into the object wrapped by the static method object. See section Implementing Descriptors for another way in which attributes retrieved from a class may differ from those actually contained in its __dict__.\n\nClass attribute assignments update the class\u2019s dictionary, never the dictionary of a base class.\n\nA class object can be called (see above) to yield a class instance (see below).\n\n3.2.10.1. Special attributes\n\nAttribute\n\n\t\n\nMeaning\n\n\n\ntype.__name__\n\t\n\nThe class\u2019s name. See also: __name__ attributes.\n\n\n\ntype.__qualname__\n\t\n\nThe class\u2019s qualified name. See also: __qualname__ attributes.\n\n\n\ntype.__module__\n\t\n\nThe name of the module in which the class was defined.\n\n\n\ntype.__dict__\n\t\n\nA mapping proxy providing a read-only view of the class\u2019s namespace. See also: __dict__ attributes.\n\n\n\ntype.__bases__\n\t\n\nA tuple containing the class\u2019s bases. In most cases, for a class defined as class X(A, B, C), X.__bases__ will be exactly equal to (A, B, C).\n\n\n\ntype.__doc__\n\t\n\nThe class\u2019s documentation string, or None if undefined. Not inherited by subclasses.\n\n\n\ntype.__annotations__\n\t\n\nA dictionary containing variable annotations collected during class body execution. For best practices on working with __annotations__, please see Annotations Best Practices.\n\nCaution\n\n \n\nAccessing the __annotations__ attribute of a class object directly may yield incorrect results in the presence of metaclasses. In addition, the attribute may not exist for some classes. Use inspect.get_annotations() to retrieve class annotations safely.\n\n\n\ntype.__type_params__\n\t\n\nA tuple containing the type parameters of a generic class.\n\nAdded in version 3.12.\n\n\n\ntype.__static_attributes__\n\t\n\nA tuple containing names of attributes of this class which are assigned through self.X from any function in its body.\n\nAdded in version 3.13.\n\n\n\ntype.__firstlineno__\n\t\n\nThe line number of the first line of the class definition, including decorators. Setting the __module__ attribute removes the __firstlineno__ item from the type\u2019s dictionary.\n\nAdded in version 3.13.\n\n\n\ntype.__mro__\n\t\n\nThe tuple of classes that are considered when looking for base classes during method resolution.\n\n3.2.10.2. Special methods\n\nIn addition to the special attributes described above, all Python classes also have the following two methods available:\n\ntype.mro()\n\nThis method can be overridden by a metaclass to customize the method resolution order for its instances. It is called at class instantiation, and its result is stored in __mro__.\n\ntype.__subclasses__()\n\nEach class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order. Example:\n\n>>>\n>>> class A: pass\n>>> class B(A): pass\n>>> A.__subclasses__()\n[<class 'B'>]\n\n3.2.11. Class instances\n\nA class instance is created by calling a class object (see above). A class instance has a namespace implemented as a dictionary which is the first place in which attribute references are searched. When an attribute is not found there, and the instance\u2019s class has an attribute by that name, the search continues with the class attributes. If a class attribute is found that is a user-defined function object, it is transformed into an instance method object whose __self__ attribute is the instance. Static method and class method objects are also transformed; see above under \u201cClasses\u201d. See section Implementing Descriptors for another way in which attributes of a class retrieved via its instances may differ from the objects actually stored in the class\u2019s __dict__. If no class attribute is found, and the object\u2019s class has a __getattr__() method, that is called to satisfy the lookup.\n\nAttribute assignments and deletions update the instance\u2019s dictionary, never a class\u2019s dictionary. If the class has a __setattr__() or __delattr__() method, this is called instead of updating the instance dictionary directly.\n\nClass instances can pretend to be numbers, sequences, or mappings if they have methods with certain special names. See section Special method names.\n\n3.2.11.1. Special attributes\nobject.__class__\n\nThe class to which a class instance belongs.\n\nobject.__dict__\n\nA dictionary or other mapping object used to store an object\u2019s (writable) attributes. Not all instances have a __dict__ attribute; see the section on __slots__ for more details.\n\n3.2.12. I/O objects (also known as file objects)\n\nA file object represents an open file. Various shortcuts are available to create file objects: the open() built-in function, and also os.popen(), os.fdopen(), and the makefile() method of socket objects (and perhaps by other functions or methods provided by extension modules).\n\nThe objects sys.stdin, sys.stdout and sys.stderr are initialized to file objects corresponding to the interpreter\u2019s standard input, output and error streams; they are all open in text mode and therefore follow the interface defined by the io.TextIOBase abstract class.\n\n3.2.13. Internal types\n\nA few types used internally by the interpreter are exposed to the user. Their definitions may change with future versions of the interpreter, but they are mentioned here for completeness.\n\n3.2.13.1. Code objects\n\nCode objects represent byte-compiled executable Python code, or bytecode. The difference between a code object and a function object is that the function object contains an explicit reference to the function\u2019s globals (the module in which it was defined), while a code object contains no context; also the default argument values are stored in the function object, not in the code object (because they represent values calculated at run-time). Unlike function objects, code objects are immutable and contain no references (directly or indirectly) to mutable objects.\n\n3.2.13.1.1. Special read-only attributes\ncodeobject.co_name\n\t\n\nThe function name\n\n\n\ncodeobject.co_qualname\n\t\n\nThe fully qualified function name\n\nAdded in version 3.11.\n\n\n\ncodeobject.co_argcount\n\t\n\nThe total number of positional parameters (including positional-only parameters and parameters with default values) that the function has\n\n\n\ncodeobject.co_posonlyargcount\n\t\n\nThe number of positional-only parameters (including arguments with default values) that the function has\n\n\n\ncodeobject.co_kwonlyargcount\n\t\n\nThe number of keyword-only parameters (including arguments with default values) that the function has\n\n\n\ncodeobject.co_nlocals\n\t\n\nThe number of local variables used by the function (including parameters)\n\n\n\ncodeobject.co_varnames\n\t\n\nA tuple containing the names of the local variables in the function (starting with the parameter names)\n\n\n\ncodeobject.co_cellvars\n\t\n\nA tuple containing the names of local variables that are referenced from at least one nested scope inside the function\n\n\n\ncodeobject.co_freevars\n\t\n\nA tuple containing the names of free (closure) variables that a nested scope references in an outer scope. See also function.__closure__.\n\nNote: references to global and builtin names are not included.\n\n\n\ncodeobject.co_code\n\t\n\nA string representing the sequence of bytecode instructions in the function\n\n\n\ncodeobject.co_consts\n\t\n\nA tuple containing the literals used by the bytecode in the function\n\n\n\ncodeobject.co_names\n\t\n\nA tuple containing the names used by the bytecode in the function\n\n\n\ncodeobject.co_filename\n\t\n\nThe name of the file from which the code was compiled\n\n\n\ncodeobject.co_firstlineno\n\t\n\nThe line number of the first line of the function\n\n\n\ncodeobject.co_lnotab\n\t\n\nA string encoding the mapping from bytecode offsets to line numbers. For details, see the source code of the interpreter.\n\nDeprecated since version 3.12: This attribute of code objects is deprecated, and may be removed in Python 3.15.\n\n\n\ncodeobject.co_stacksize\n\t\n\nThe required stack size of the code object\n\n\n\ncodeobject.co_flags\n\t\n\nAn integer encoding a number of flags for the interpreter.\n\nThe following flag bits are defined for co_flags: bit 0x04 is set if the function uses the *arguments syntax to accept an arbitrary number of positional arguments; bit 0x08 is set if the function uses the **keywords syntax to accept arbitrary keyword arguments; bit 0x20 is set if the function is a generator. See Code Objects Bit Flags for details on the semantics of each flags that might be present.\n\nFuture feature declarations (from __future__ import division) also use bits in co_flags to indicate whether a code object was compiled with a particular feature enabled: bit 0x2000 is set if the function was compiled with future division enabled; bits 0x10 and 0x1000 were used in earlier versions of Python.\n\nOther bits in co_flags are reserved for internal use.\n\nIf a code object represents a function, the first item in co_consts is the documentation string of the function, or None if undefined.\n\n3.2.13.1.2. Methods on code objects\ncodeobject.co_positions()\n\nReturns an iterable over the source code positions of each bytecode instruction in the code object.\n\nThe iterator returns tuples containing the (start_line, end_line, start_column, end_column). The i-th tuple corresponds to the position of the source code that compiled to the i-th code unit. Column information is 0-indexed utf-8 byte offsets on the given source line.\n\nThis positional information can be missing. A non-exhaustive lists of cases where this may happen:\n\nRunning the interpreter with -X no_debug_ranges.\n\nLoading a pyc file compiled while using -X no_debug_ranges.\n\nPosition tuples corresponding to artificial instructions.\n\nLine and column numbers that can\u2019t be represented due to implementation specific limitations.\n\nWhen this occurs, some or all of the tuple elements can be None.\n\nAdded in version 3.11.\n\nNote\n\n \n\nThis feature requires storing column positions in code objects which may result in a small increase of disk usage of compiled Python files or interpreter memory usage. To avoid storing the extra information and/or deactivate printing the extra traceback information, the -X no_debug_ranges command line flag or the PYTHONNODEBUGRANGES environment variable can be used.\n\ncodeobject.co_lines()\n\nReturns an iterator that yields information about successive ranges of bytecodes. Each item yielded is a (start, end, lineno) tuple:\n\nstart (an int) represents the offset (inclusive) of the start of the bytecode range\n\nend (an int) represents the offset (exclusive) of the end of the bytecode range\n\nlineno is an int representing the line number of the bytecode range, or None if the bytecodes in the given range have no line number\n\nThe items yielded will have the following properties:\n\nThe first range yielded will have a start of 0.\n\nThe (start, end) ranges will be non-decreasing and consecutive. That is, for any pair of tuples, the start of the second will be equal to the end of the first.\n\nNo range will be backwards: end >= start for all triples.\n\nThe last tuple yielded will have end equal to the size of the bytecode.\n\nZero-width ranges, where start == end, are allowed. Zero-width ranges are used for lines that are present in the source code, but have been eliminated by the bytecode compiler.\n\nAdded in version 3.10.\n\nSee also\n\nPEP 626 - Precise line numbers for debugging and other tools.\n\nThe PEP that introduced the co_lines() method.\n\ncodeobject.replace(**kwargs)\n\nReturn a copy of the code object with new values for the specified fields.\n\nCode objects are also supported by the generic function copy.replace().\n\nAdded in version 3.8.\n\n3.2.13.2. Frame objects\n\nFrame objects represent execution frames. They may occur in traceback objects, and are also passed to registered trace functions.\n\n3.2.13.2.1. Special read-only attributes\nframe.f_back\n\t\n\nPoints to the previous stack frame (towards the caller), or None if this is the bottom stack frame\n\n\n\nframe.f_code\n\t\n\nThe code object being executed in this frame. Accessing this attribute raises an auditing event object.__getattr__ with arguments obj and \"f_code\".\n\n\n\nframe.f_locals\n\t\n\nThe mapping used by the frame to look up local variables. If the frame refers to an optimized scope, this may return a write-through proxy object.\n\nChanged in version 3.13: Return a proxy for optimized scopes.\n\n\n\nframe.f_globals\n\t\n\nThe dictionary used by the frame to look up global variables\n\n\n\nframe.f_builtins\n\t\n\nThe dictionary used by the frame to look up built-in (intrinsic) names\n\n\n\nframe.f_lasti\n\t\n\nThe \u201cprecise instruction\u201d of the frame object (this is an index into the bytecode string of the code object)\n\n3.2.13.2.2. Special writable attributes\nframe.f_trace\n\t\n\nIf not None, this is a function called for various events during code execution (this is used by debuggers). Normally an event is triggered for each new source line (see f_trace_lines).\n\n\n\nframe.f_trace_lines\n\t\n\nSet this attribute to False to disable triggering a tracing event for each source line.\n\n\n\nframe.f_trace_opcodes\n\t\n\nSet this attribute to True to allow per-opcode events to be requested. Note that this may lead to undefined interpreter behaviour if exceptions raised by the trace function escape to the function being traced.\n\n\n\nframe.f_lineno\n\t\n\nThe current line number of the frame \u2013 writing to this from within a trace function jumps to the given line (only for the bottom-most frame). A debugger can implement a Jump command (aka Set Next Statement) by writing to this attribute.\n\n3.2.13.2.3. Frame object methods\n\nFrame objects support one method:\n\nframe.clear()\n\nThis method clears all references to local variables held by the frame. Also, if the frame belonged to a generator, the generator is finalized. This helps break reference cycles involving frame objects (for example when catching an exception and storing its traceback for later use).\n\nRuntimeError is raised if the frame is currently executing or suspended.\n\nAdded in version 3.4.\n\nChanged in version 3.13: Attempting to clear a suspended frame raises RuntimeError (as has always been the case for executing frames).\n\n3.2.13.3. Traceback objects\n\nTraceback objects represent the stack trace of an exception. A traceback object is implicitly created when an exception occurs, and may also be explicitly created by calling types.TracebackType.\n\nChanged in version 3.7: Traceback objects can now be explicitly instantiated from Python code.\n\nFor implicitly created tracebacks, when the search for an exception handler unwinds the execution stack, at each unwound level a traceback object is inserted in front of the current traceback. When an exception handler is entered, the stack trace is made available to the program. (See section The try statement.) It is accessible as the third item of the tuple returned by sys.exc_info(), and as the __traceback__ attribute of the caught exception.\n\nWhen the program contains no suitable handler, the stack trace is written (nicely formatted) to the standard error stream; if the interpreter is interactive, it is also made available to the user as sys.last_traceback.\n\nFor explicitly created tracebacks, it is up to the creator of the traceback to determine how the tb_next attributes should be linked to form a full stack trace.\n\nSpecial read-only attributes:\n\ntraceback.tb_frame\n\t\n\nPoints to the execution frame of the current level.\n\nAccessing this attribute raises an auditing event object.__getattr__ with arguments obj and \"tb_frame\".\n\n\n\ntraceback.tb_lineno\n\t\n\nGives the line number where the exception occurred\n\n\n\ntraceback.tb_lasti\n\t\n\nIndicates the \u201cprecise instruction\u201d.\n\nThe line number and last instruction in the traceback may differ from the line number of its frame object if the exception occurred in a try statement with no matching except clause or with a finally clause.\n\ntraceback.tb_next\n\nThe special writable attribute tb_next is the next level in the stack trace (towards the frame where the exception occurred), or None if there is no next level.\n\nChanged in version 3.7: This attribute is now writable\n\n3.2.13.4. Slice objects\n\nSlice objects are used to represent slices for __getitem__() methods. They are also created by the built-in slice() function.\n\nSpecial read-only attributes: start is the lower bound; stop is the upper bound; step is the step value; each is None if omitted. These attributes can have any type.\n\nSlice objects support one method:\n\nslice.indices(self, length)\n\nThis method takes a single integer argument length and computes information about the slice that the slice object would describe if applied to a sequence of length items. It returns a tuple of three integers; respectively these are the start and stop indices and the step or stride length of the slice. Missing or out-of-bounds indices are handled in a manner consistent with regular slices.\n\n3.2.13.5. Static method objects\n\nStatic method objects provide a way of defeating the transformation of function objects to method objects described above. A static method object is a wrapper around any other object, usually a user-defined method object. When a static method object is retrieved from a class or a class instance, the object actually returned is the wrapped object, which is not subject to any further transformation. Static method objects are also callable. Static method objects are created by the built-in staticmethod() constructor.\n\n3.2.13.6. Class method objects\n\nA class method object, like a static method object, is a wrapper around another object that alters the way in which that object is retrieved from classes and class instances. The behaviour of class method objects upon such retrieval is described above, under \u201cinstance methods\u201d. Class method objects are created by the built-in classmethod() constructor.\n\n3.3. Special method names\n\nA class can implement certain operations that are invoked by special syntax (such as arithmetic operations or subscripting and slicing) by defining methods with special names. This is Python\u2019s approach to operator overloading, allowing classes to define their own behavior with respect to language operators. For instance, if a class defines a method named __getitem__(), and x is an instance of this class, then x[i] is roughly equivalent to type(x).__getitem__(x, i). Except where mentioned, attempts to execute an operation raise an exception when no appropriate method is defined (typically AttributeError or TypeError).\n\nSetting a special method to None indicates that the corresponding operation is not available. For example, if a class sets __iter__() to None, the class is not iterable, so calling iter() on its instances will raise a TypeError (without falling back to __getitem__()). [2]\n\nWhen implementing a class that emulates any built-in type, it is important that the emulation only be implemented to the degree that it makes sense for the object being modelled. For example, some sequences may work well with retrieval of individual elements, but extracting a slice may not make sense. (One example of this is the NodeList interface in the W3C\u2019s Document Object Model.)\n\n3.3.1. Basic customization\nobject.__new__(cls[, ...])\n\nCalled to create a new instance of class cls. __new__() is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument. The remaining arguments are those passed to the object constructor expression (the call to the class). The return value of __new__() should be the new object instance (usually an instance of cls).\n\nTypical implementations create a new instance of the class by invoking the superclass\u2019s __new__() method using super().__new__(cls[, ...]) with appropriate arguments and then modifying the newly created instance as necessary before returning it.\n\nIf __new__() is invoked during object construction and it returns an instance of cls, then the new instance\u2019s __init__() method will be invoked like __init__(self[, ...]), where self is the new instance and the remaining arguments are the same as were passed to the object constructor.\n\nIf __new__() does not return an instance of cls, then the new instance\u2019s __init__() method will not be invoked.\n\n__new__() is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation. It is also commonly overridden in custom metaclasses in order to customize class creation.\n\nobject.__init__(self[, ...])\n\nCalled after the instance has been created (by __new__()), but before it is returned to the caller. The arguments are those passed to the class constructor expression. If a base class has an __init__() method, the derived class\u2019s __init__() method, if any, must explicitly call it to ensure proper initialization of the base class part of the instance; for example: super().__init__([args...]).\n\nBecause __new__() and __init__() work together in constructing objects (__new__() to create it, and __init__() to customize it), no non-None value may be returned by __init__(); doing so will cause a TypeError to be raised at runtime.\n\nobject.__del__(self)\n\nCalled when the instance is about to be destroyed. This is also called a finalizer or (improperly) a destructor. If a base class has a __del__() method, the derived class\u2019s __del__() method, if any, must explicitly call it to ensure proper deletion of the base class part of the instance.\n\nIt is possible (though not recommended!) for the __del__() method to postpone destruction of the instance by creating a new reference to it. This is called object resurrection. It is implementation-dependent whether __del__() is called a second time when a resurrected object is about to be destroyed; the current CPython implementation only calls it once.\n\nIt is not guaranteed that __del__() methods are called for objects that still exist when the interpreter exits. weakref.finalize provides a straightforward way to register a cleanup function to be called when an object is garbage collected.\n\nNote\n\n \n\ndel x doesn\u2019t directly call x.__del__() \u2014 the former decrements the reference count for x by one, and the latter is only called when x\u2019s reference count reaches zero.\n\nCPython implementation detail: It is possible for a reference cycle to prevent the reference count of an object from going to zero. In this case, the cycle will be later detected and deleted by the cyclic garbage collector. A common cause of reference cycles is when an exception has been caught in a local variable. The frame\u2019s locals then reference the exception, which references its own traceback, which references the locals of all frames caught in the traceback.\n\nSee also\n\n \n\nDocumentation for the gc module.\n\nWarning\n\n \n\nDue to the precarious circumstances under which __del__() methods are invoked, exceptions that occur during their execution are ignored, and a warning is printed to sys.stderr instead. In particular:\n\n__del__() can be invoked when arbitrary code is being executed, including from any arbitrary thread. If __del__() needs to take a lock or invoke any other blocking resource, it may deadlock as the resource may already be taken by the code that gets interrupted to execute __del__().\n\n__del__() can be executed during interpreter shutdown. As a consequence, the global variables it needs to access (including other modules) may already have been deleted or set to None. Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted; if no other references to such globals exist, this may help in assuring that imported modules are still available at the time when the __del__() method is called.\n\nobject.__repr__(self)\n\nCalled by the repr() built-in function to compute the \u201cofficial\u201d string representation of an object. If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment). If this is not possible, a string of the form <...some useful description...> should be returned. The return value must be a string object. If a class defines __repr__() but not __str__(), then __repr__() is also used when an \u201cinformal\u201d string representation of instances of that class is required.\n\nThis is typically used for debugging, so it is important that the representation is information-rich and unambiguous. A default implementation is provided by the object class itself.\n\nobject.__str__(self)\n\nCalled by str(object), the default __format__() implementation, and the built-in function print(), to compute the \u201cinformal\u201d or nicely printable string representation of an object. The return value must be a str object.\n\nThis method differs from object.__repr__() in that there is no expectation that __str__() return a valid Python expression: a more convenient or concise representation can be used.\n\nThe default implementation defined by the built-in type object calls object.__repr__().\n\nobject.__bytes__(self)\n\nCalled by bytes to compute a byte-string representation of an object. This should return a bytes object. The object class itself does not provide this method.\n\nobject.__format__(self, format_spec)\n\nCalled by the format() built-in function, and by extension, evaluation of formatted string literals and the str.format() method, to produce a \u201cformatted\u201d string representation of an object. The format_spec argument is a string that contains a description of the formatting options desired. The interpretation of the format_spec argument is up to the type implementing __format__(), however most classes will either delegate formatting to one of the built-in types, or use a similar formatting option syntax.\n\nSee Format Specification Mini-Language for a description of the standard formatting syntax.\n\nThe return value must be a string object.\n\nThe default implementation by the object class should be given an empty format_spec string. It delegates to __str__().\n\nChanged in version 3.4: The __format__ method of object itself raises a TypeError if passed any non-empty string.\n\nChanged in version 3.7: object.__format__(x, '') is now equivalent to str(x) rather than format(str(x), '').\n\nobject.__lt__(self, other)\nobject.__le__(self, other)\nobject.__eq__(self, other)\nobject.__ne__(self, other)\nobject.__gt__(self, other)\nobject.__ge__(self, other)\n\nThese are the so-called \u201crich comparison\u201d methods. The correspondence between operator symbols and method names is as follows: x<y calls x.__lt__(y), x<=y calls x.__le__(y), x==y calls x.__eq__(y), x!=y calls x.__ne__(y), x>y calls x.__gt__(y), and x>=y calls x.__ge__(y).\n\nA rich comparison method may return the singleton NotImplemented if it does not implement the operation for a given pair of arguments. By convention, False and True are returned for a successful comparison. However, these methods can return any value, so if the comparison operator is used in a Boolean context (e.g., in the condition of an if statement), Python will call bool() on the value to determine if the result is true or false.\n\nBy default, object implements __eq__() by using is, returning NotImplemented in the case of a false comparison: True if x is y else NotImplemented. For __ne__(), by default it delegates to __eq__() and inverts the result unless it is NotImplemented. There are no other implied relationships among the comparison operators or default implementations; for example, the truth of (x<y or x==y) does not imply x<=y. To automatically generate ordering operations from a single root operation, see functools.total_ordering().\n\nBy default, the object class provides implementations consistent with Value comparisons: equality compares according to object identity, and order comparisons raise TypeError. Each default method may generate these results directly, but may also return NotImplemented.\n\nSee the paragraph on __hash__() for some important notes on creating hashable objects which support custom comparison operations and are usable as dictionary keys.\n\nThere are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the right argument does); rather, __lt__() and __gt__() are each other\u2019s reflection, __le__() and __ge__() are each other\u2019s reflection, and __eq__() and __ne__() are their own reflection. If the operands are of different types, and the right operand\u2019s type is a direct or indirect subclass of the left operand\u2019s type, the reflected method of the right operand has priority, otherwise the left operand\u2019s method has priority. Virtual subclassing is not considered.\n\nWhen no appropriate method returns any value other than NotImplemented, the == and != operators will fall back to is and is not, respectively.\n\nobject.__hash__(self)\n\nCalled by built-in function hash() and for operations on members of hashed collections including set, frozenset, and dict. The __hash__() method should return an integer. The only required property is that objects which compare equal have the same hash value; it is advised to mix together the hash values of the components of the object that also play a part in comparison of objects by packing them into a tuple and hashing the tuple. Example:\n\ndef __hash__(self):\n    return hash((self.name, self.nick, self.color))\n\n\nNote\n\n \n\nhash() truncates the value returned from an object\u2019s custom __hash__() method to the size of a Py_ssize_t. This is typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds. If an object\u2019s __hash__() must interoperate on builds of different bit sizes, be sure to check the width on all supported builds. An easy way to do this is with python -c \"import sys; print(sys.hash_info.width)\".\n\nIf a class does not define an __eq__() method it should not define a __hash__() operation either; if it defines __eq__() but not __hash__(), its instances will not be usable as items in hashable collections. If a class defines mutable objects and implements an __eq__() method, it should not implement __hash__(), since the implementation of hashable collections requires that a key\u2019s hash value is immutable (if the object\u2019s hash value changes, it will be in the wrong hash bucket).\n\nUser-defined classes have __eq__() and __hash__() methods by default (inherited from the object class); with them, all objects compare unequal (except with themselves) and x.__hash__() returns an appropriate value such that x == y implies both that x is y and hash(x) == hash(y).\n\nA class that overrides __eq__() and does not define __hash__() will have its __hash__() implicitly set to None. When the __hash__() method of a class is None, instances of the class will raise an appropriate TypeError when a program attempts to retrieve their hash value, and will also be correctly identified as unhashable when checking isinstance(obj, collections.abc.Hashable).\n\nIf a class that overrides __eq__() needs to retain the implementation of __hash__() from a parent class, the interpreter must be told this explicitly by setting __hash__ = <ParentClass>.__hash__.\n\nIf a class that does not override __eq__() wishes to suppress hash support, it should include __hash__ = None in the class definition. A class which defines its own __hash__() that explicitly raises a TypeError would be incorrectly identified as hashable by an isinstance(obj, collections.abc.Hashable) call.\n\nNote\n\n \n\nBy default, the __hash__() values of str and bytes objects are \u201csalted\u201d with an unpredictable random value. Although they remain constant within an individual Python process, they are not predictable between repeated invocations of Python.\n\nThis is intended to provide protection against a denial-of-service caused by carefully chosen inputs that exploit the worst case performance of a dict insertion, O(n2) complexity. See http://ocert.org/advisories/ocert-2011-003.html for details.\n\nChanging hash values affects the iteration order of sets. Python has never made guarantees about this ordering (and it typically varies between 32-bit and 64-bit builds).\n\nSee also PYTHONHASHSEED.\n\nChanged in version 3.3: Hash randomization is enabled by default.\n\nobject.__bool__(self)\n\nCalled to implement truth value testing and the built-in operation bool(); should return False or True. When this method is not defined, __len__() is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither __len__() nor __bool__() (which is true of the object class itself), all its instances are considered true.\n\n3.3.2. Customizing attribute access\n\nThe following methods can be defined to customize the meaning of attribute access (use of, assignment to, or deletion of x.name) for class instances.\n\nobject.__getattr__(self, name)\n\nCalled when the default attribute access fails with an AttributeError (either __getattribute__() raises an AttributeError because name is not an instance attribute or an attribute in the class tree for self; or __get__() of a name property raises AttributeError). This method should either return the (computed) attribute value or raise an AttributeError exception. The object class itself does not provide this method.\n\nNote that if the attribute is found through the normal mechanism, __getattr__() is not called. (This is an intentional asymmetry between __getattr__() and __setattr__().) This is done both for efficiency reasons and because otherwise __getattr__() would have no way to access other attributes of the instance. Note that at least for instance variables, you can take total control by not inserting any values in the instance attribute dictionary (but instead inserting them in another object). See the __getattribute__() method below for a way to actually get total control over attribute access.\n\nobject.__getattribute__(self, name)\n\nCalled unconditionally to implement attribute accesses for instances of the class. If the class also defines __getattr__(), the latter will not be called unless __getattribute__() either calls it explicitly or raises an AttributeError. This method should return the (computed) attribute value or raise an AttributeError exception. In order to avoid infinite recursion in this method, its implementation should always call the base class method with the same name to access any attributes it needs, for example, object.__getattribute__(self, name).\n\nNote\n\n \n\nThis method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See Special method lookup.\n\nFor certain sensitive attribute accesses, raises an auditing event object.__getattr__ with arguments obj and name.\n\nobject.__setattr__(self, name, value)\n\nCalled when an attribute assignment is attempted. This is called instead of the normal mechanism (i.e. store the value in the instance dictionary). name is the attribute name, value is the value to be assigned to it.\n\nIf __setattr__() wants to assign to an instance attribute, it should call the base class method with the same name, for example, object.__setattr__(self, name, value).\n\nFor certain sensitive attribute assignments, raises an auditing event object.__setattr__ with arguments obj, name, value.\n\nobject.__delattr__(self, name)\n\nLike __setattr__() but for attribute deletion instead of assignment. This should only be implemented if del obj.name is meaningful for the object.\n\nFor certain sensitive attribute deletions, raises an auditing event object.__delattr__ with arguments obj and name.\n\nobject.__dir__(self)\n\nCalled when dir() is called on the object. An iterable must be returned. dir() converts the returned iterable to a list and sorts it.\n\n3.3.2.1. Customizing module attribute access\n\nSpecial names __getattr__ and __dir__ can be also used to customize access to module attributes. The __getattr__ function at the module level should accept one argument which is the name of an attribute and return the computed value or raise an AttributeError. If an attribute is not found on a module object through the normal lookup, i.e. object.__getattribute__(), then __getattr__ is searched in the module __dict__ before raising an AttributeError. If found, it is called with the attribute name and the result is returned.\n\nThe __dir__ function should accept no arguments, and return an iterable of strings that represents the names accessible on module. If present, this function overrides the standard dir() search on a module.\n\nFor a more fine grained customization of the module behavior (setting attributes, properties, etc.), one can set the __class__ attribute of a module object to a subclass of types.ModuleType. For example:\n\nimport sys\nfrom types import ModuleType\n\nclass VerboseModule(ModuleType):\n    def __repr__(self):\n        return f'Verbose {self.__name__}'\n\n    def __setattr__(self, attr, value):\n        print(f'Setting {attr}...')\n        super().__setattr__(attr, value)\n\nsys.modules[__name__].__class__ = VerboseModule\n\n\nNote\n\n \n\nDefining module __getattr__ and setting module __class__ only affect lookups made using the attribute access syntax \u2013 directly accessing the module globals (whether by code within the module, or via a reference to the module\u2019s globals dictionary) is unaffected.\n\nChanged in version 3.5: __class__ module attribute is now writable.\n\nAdded in version 3.7: __getattr__ and __dir__ module attributes.\n\nSee also\n\nPEP 562 - Module __getattr__ and __dir__\n\nDescribes the __getattr__ and __dir__ functions on modules.\n\n3.3.2.2. Implementing Descriptors\n\nThe following methods only apply when an instance of the class containing the method (a so-called descriptor class) appears in an owner class (the descriptor must be in either the owner\u2019s class dictionary or in the class dictionary for one of its parents). In the examples below, \u201cthe attribute\u201d refers to the attribute whose name is the key of the property in the owner class\u2019 __dict__. The object class itself does not implement any of these protocols.\n\nobject.__get__(self, instance, owner=None)\n\nCalled to get the attribute of the owner class (class attribute access) or of an instance of that class (instance attribute access). The optional owner argument is the owner class, while instance is the instance that the attribute was accessed through, or None when the attribute is accessed through the owner.\n\nThis method should return the computed attribute value or raise an AttributeError exception.\n\nPEP 252 specifies that __get__() is callable with one or two arguments. Python\u2019s own built-in descriptors support this specification; however, it is likely that some third-party tools have descriptors that require both arguments. Python\u2019s own __getattribute__() implementation always passes in both arguments whether they are required or not.\n\nobject.__set__(self, instance, value)\n\nCalled to set the attribute on an instance instance of the owner class to a new value, value.\n\nNote, adding __set__() or __delete__() changes the kind of descriptor to a \u201cdata descriptor\u201d. See Invoking Descriptors for more details.\n\nobject.__delete__(self, instance)\n\nCalled to delete the attribute on an instance instance of the owner class.\n\nInstances of descriptors may also have the __objclass__ attribute present:\n\nobject.__objclass__\n\nThe attribute __objclass__ is interpreted by the inspect module as specifying the class where this object was defined (setting this appropriately can assist in runtime introspection of dynamic class attributes). For callables, it may indicate that an instance of the given type (or a subclass) is expected or required as the first positional argument (for example, CPython sets this attribute for unbound methods that are implemented in C).\n\n3.3.2.3. Invoking Descriptors\n\nIn general, a descriptor is an object attribute with \u201cbinding behavior\u201d, one whose attribute access has been overridden by methods in the descriptor protocol: __get__(), __set__(), and __delete__(). If any of those methods are defined for an object, it is said to be a descriptor.\n\nThe default behavior for attribute access is to get, set, or delete the attribute from an object\u2019s dictionary. For instance, a.x has a lookup chain starting with a.__dict__['x'], then type(a).__dict__['x'], and continuing through the base classes of type(a) excluding metaclasses.\n\nHowever, if the looked-up value is an object defining one of the descriptor methods, then Python may override the default behavior and invoke the descriptor method instead. Where this occurs in the precedence chain depends on which descriptor methods were defined and how they were called.\n\nThe starting point for descriptor invocation is a binding, a.x. How the arguments are assembled depends on a:\n\nDirect Call\n\nThe simplest and least common call is when user code directly invokes a descriptor method: x.__get__(a).\n\nInstance Binding\n\nIf binding to an object instance, a.x is transformed into the call: type(a).__dict__['x'].__get__(a, type(a)).\n\nClass Binding\n\nIf binding to a class, A.x is transformed into the call: A.__dict__['x'].__get__(None, A).\n\nSuper Binding\n\nA dotted lookup such as super(A, a).x searches a.__class__.__mro__ for a base class B following A and then returns B.__dict__['x'].__get__(a, A). If not a descriptor, x is returned unchanged.\n\nFor instance bindings, the precedence of descriptor invocation depends on which descriptor methods are defined. A descriptor can define any combination of __get__(), __set__() and __delete__(). If it does not define __get__(), then accessing the attribute will return the descriptor object itself unless there is a value in the object\u2019s instance dictionary. If the descriptor defines __set__() and/or __delete__(), it is a data descriptor; if it defines neither, it is a non-data descriptor. Normally, data descriptors define both __get__() and __set__(), while non-data descriptors have just the __get__() method. Data descriptors with __get__() and __set__() (and/or __delete__()) defined always override a redefinition in an instance dictionary. In contrast, non-data descriptors can be overridden by instances.\n\nPython methods (including those decorated with @staticmethod and @classmethod) are implemented as non-data descriptors. Accordingly, instances can redefine and override methods. This allows individual instances to acquire behaviors that differ from other instances of the same class.\n\nThe property() function is implemented as a data descriptor. Accordingly, instances cannot override the behavior of a property.\n\n3.3.2.4. __slots__\n\n__slots__ allow us to explicitly declare data members (like properties) and deny the creation of __dict__ and __weakref__ (unless explicitly declared in __slots__ or available in a parent.)\n\nThe space saved over using __dict__ can be significant. Attribute lookup speed can be significantly improved as well.\n\nobject.__slots__\n\nThis class variable can be assigned a string, iterable, or sequence of strings with variable names used by instances. __slots__ reserves space for the declared variables and prevents the automatic creation of __dict__ and __weakref__ for each instance.\n\nNotes on using __slots__:\n\nWhen inheriting from a class without __slots__, the __dict__ and __weakref__ attribute of the instances will always be accessible.\n\nWithout a __dict__ variable, instances cannot be assigned new variables not listed in the __slots__ definition. Attempts to assign to an unlisted variable name raises AttributeError. If dynamic assignment of new variables is desired, then add '__dict__' to the sequence of strings in the __slots__ declaration.\n\nWithout a __weakref__ variable for each instance, classes defining __slots__ do not support weak references to its instances. If weak reference support is needed, then add '__weakref__' to the sequence of strings in the __slots__ declaration.\n\n__slots__ are implemented at the class level by creating descriptors for each variable name. As a result, class attributes cannot be used to set default values for instance variables defined by __slots__; otherwise, the class attribute would overwrite the descriptor assignment.\n\nThe action of a __slots__ declaration is not limited to the class where it is defined. __slots__ declared in parents are available in child classes. However, instances of a child subclass will get a __dict__ and __weakref__ unless the subclass also defines __slots__ (which should only contain names of any additional slots).\n\nIf a class defines a slot also defined in a base class, the instance variable defined by the base class slot is inaccessible (except by retrieving its descriptor directly from the base class). This renders the meaning of the program undefined. In the future, a check may be added to prevent this.\n\nTypeError will be raised if nonempty __slots__ are defined for a class derived from a \"variable-length\" built-in type such as int, bytes, and tuple.\n\nAny non-string iterable may be assigned to __slots__.\n\nIf a dictionary is used to assign __slots__, the dictionary keys will be used as the slot names. The values of the dictionary can be used to provide per-attribute docstrings that will be recognised by inspect.getdoc() and displayed in the output of help().\n\n__class__ assignment works only if both classes have the same __slots__.\n\nMultiple inheritance with multiple slotted parent classes can be used, but only one parent is allowed to have attributes created by slots (the other bases must have empty slot layouts) - violations raise TypeError.\n\nIf an iterator is used for __slots__ then a descriptor is created for each of the iterator\u2019s values. However, the __slots__ attribute will be an empty iterator.\n\n3.3.3. Customizing class creation\n\nWhenever a class inherits from another class, __init_subclass__() is called on the parent class. This way, it is possible to write classes which change the behavior of subclasses. This is closely related to class decorators, but where class decorators only affect the specific class they\u2019re applied to, __init_subclass__ solely applies to future subclasses of the class defining the method.\n\nclassmethod object.__init_subclass__(cls)\n\nThis method is called whenever the containing class is subclassed. cls is then the new subclass. If defined as a normal instance method, this method is implicitly converted to a class method.\n\nKeyword arguments which are given to a new class are passed to the parent class\u2019s __init_subclass__. For compatibility with other classes using __init_subclass__, one should take out the needed keyword arguments and pass the others over to the base class, as in:\n\nclass Philosopher:\n    def __init_subclass__(cls, /, default_name, **kwargs):\n        super().__init_subclass__(**kwargs)\n        cls.default_name = default_name\n\nclass AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n    pass\n\n\nThe default implementation object.__init_subclass__ does nothing, but raises an error if it is called with any arguments.\n\nNote\n\n \n\nThe metaclass hint metaclass is consumed by the rest of the type machinery, and is never passed to __init_subclass__ implementations. The actual metaclass (rather than the explicit hint) can be accessed as type(cls).\n\nAdded in version 3.6.\n\nWhen a class is created, type.__new__() scans the class variables and makes callbacks to those with a __set_name__() hook.\n\nobject.__set_name__(self, owner, name)\n\nAutomatically called at the time the owning class owner is created. The object has been assigned to name in that class:\n\nclass A:\n    x = C()  # Automatically calls: x.__set_name__(A, 'x')\n\n\nIf the class variable is assigned after the class is created, __set_name__() will not be called automatically. If needed, __set_name__() can be called directly:\n\nclass A:\n   pass\n\nc = C()\nA.x = c                  # The hook is not called\nc.__set_name__(A, 'x')   # Manually invoke the hook\n\n\nSee Creating the class object for more details.\n\nAdded in version 3.6.\n\n3.3.3.1. Metaclasses\n\nBy default, classes are constructed using type(). The class body is executed in a new namespace and the class name is bound locally to the result of type(name, bases, namespace).\n\nThe class creation process can be customized by passing the metaclass keyword argument in the class definition line, or by inheriting from an existing class that included such an argument. In the following example, both MyClass and MySubclass are instances of Meta:\n\nclass Meta(type):\n    pass\n\nclass MyClass(metaclass=Meta):\n    pass\n\nclass MySubclass(MyClass):\n    pass\n\n\nAny other keyword arguments that are specified in the class definition are passed through to all metaclass operations described below.\n\nWhen a class definition is executed, the following steps occur:\n\nMRO entries are resolved;\n\nthe appropriate metaclass is determined;\n\nthe class namespace is prepared;\n\nthe class body is executed;\n\nthe class object is created.\n\n3.3.3.2. Resolving MRO entries\nobject.__mro_entries__(self, bases)\n\nIf a base that appears in a class definition is not an instance of type, then an __mro_entries__() method is searched on the base. If an __mro_entries__() method is found, the base is substituted with the result of a call to __mro_entries__() when creating the class. The method is called with the original bases tuple passed to the bases parameter, and must return a tuple of classes that will be used instead of the base. The returned tuple may be empty: in these cases, the original base is ignored.\n\nSee also\n\ntypes.resolve_bases()\n\nDynamically resolve bases that are not instances of type.\n\ntypes.get_original_bases()\n\nRetrieve a class\u2019s \u201coriginal bases\u201d prior to modifications by __mro_entries__().\n\nPEP 560\n\nCore support for typing module and generic types.\n\n3.3.3.3. Determining the appropriate metaclass\n\nThe appropriate metaclass for a class definition is determined as follows:\n\nif no bases and no explicit metaclass are given, then type() is used;\n\nif an explicit metaclass is given and it is not an instance of type(), then it is used directly as the metaclass;\n\nif an instance of type() is given as the explicit metaclass, or bases are defined, then the most derived metaclass is used.\n\nThe most derived metaclass is selected from the explicitly specified metaclass (if any) and the metaclasses (i.e. type(cls)) of all specified base classes. The most derived metaclass is one which is a subtype of all of these candidate metaclasses. If none of the candidate metaclasses meets that criterion, then the class definition will fail with TypeError.\n\n3.3.3.4. Preparing the class namespace\n\nOnce the appropriate metaclass has been identified, then the class namespace is prepared. If the metaclass has a __prepare__ attribute, it is called as namespace = metaclass.__prepare__(name, bases, **kwds) (where the additional keyword arguments, if any, come from the class definition). The __prepare__ method should be implemented as a classmethod. The namespace returned by __prepare__ is passed in to __new__, but when the final class object is created the namespace is copied into a new dict.\n\nIf the metaclass has no __prepare__ attribute, then the class namespace is initialised as an empty ordered mapping.\n\nSee also\n\nPEP 3115 - Metaclasses in Python 3000\n\nIntroduced the __prepare__ namespace hook\n\n3.3.3.5. Executing the class body\n\nThe class body is executed (approximately) as exec(body, globals(), namespace). The key difference from a normal call to exec() is that lexical scoping allows the class body (including any methods) to reference names from the current and outer scopes when the class definition occurs inside a function.\n\nHowever, even when the class definition occurs inside the function, methods defined inside the class still cannot see names defined at the class scope. Class variables must be accessed through the first parameter of instance or class methods, or through the implicit lexically scoped __class__ reference described in the next section.\n\n3.3.3.6. Creating the class object\n\nOnce the class namespace has been populated by executing the class body, the class object is created by calling metaclass(name, bases, namespace, **kwds) (the additional keywords passed here are the same as those passed to __prepare__).\n\nThis class object is the one that will be referenced by the zero-argument form of super(). __class__ is an implicit closure reference created by the compiler if any methods in a class body refer to either __class__ or super. This allows the zero argument form of super() to correctly identify the class being defined based on lexical scoping, while the class or instance that was used to make the current call is identified based on the first argument passed to the method.\n\nCPython implementation detail: In CPython 3.6 and later, the __class__ cell is passed to the metaclass as a __classcell__ entry in the class namespace. If present, this must be propagated up to the type.__new__ call in order for the class to be initialised correctly. Failing to do so will result in a RuntimeError in Python 3.8.\n\nWhen using the default metaclass type, or any metaclass that ultimately calls type.__new__, the following additional customization steps are invoked after creating the class object:\n\nThe type.__new__ method collects all of the attributes in the class namespace that define a __set_name__() method;\n\nThose __set_name__ methods are called with the class being defined and the assigned name of that particular attribute;\n\nThe __init_subclass__() hook is called on the immediate parent of the new class in its method resolution order.\n\nAfter the class object is created, it is passed to the class decorators included in the class definition (if any) and the resulting object is bound in the local namespace as the defined class.\n\nWhen a new class is created by type.__new__, the object provided as the namespace parameter is copied to a new ordered mapping and the original object is discarded. The new copy is wrapped in a read-only proxy, which becomes the __dict__ attribute of the class object.\n\nSee also\n\nPEP 3135 - New super\n\nDescribes the implicit __class__ closure reference\n\n3.3.3.7. Uses for metaclasses\n\nThe potential uses for metaclasses are boundless. Some ideas that have been explored include enum, logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization.\n\n3.3.4. Customizing instance and subclass checks\n\nThe following methods are used to override the default behavior of the isinstance() and issubclass() built-in functions.\n\nIn particular, the metaclass abc.ABCMeta implements these methods in order to allow the addition of Abstract Base Classes (ABCs) as \u201cvirtual base classes\u201d to any class or type (including built-in types), including other ABCs.\n\ntype.__instancecheck__(self, instance)\n\nReturn true if instance should be considered a (direct or indirect) instance of class. If defined, called to implement isinstance(instance, class).\n\ntype.__subclasscheck__(self, subclass)\n\nReturn true if subclass should be considered a (direct or indirect) subclass of class. If defined, called to implement issubclass(subclass, class).\n\nNote that these methods are looked up on the type (metaclass) of a class. They cannot be defined as class methods in the actual class. This is consistent with the lookup of special methods that are called on instances, only in this case the instance is itself a class.\n\nSee also\n\nPEP 3119 - Introducing Abstract Base Classes\n\nIncludes the specification for customizing isinstance() and issubclass() behavior through __instancecheck__() and __subclasscheck__(), with motivation for this functionality in the context of adding Abstract Base Classes (see the abc module) to the language.\n\n3.3.5. Emulating generic types\n\nWhen using type annotations, it is often useful to parameterize a generic type using Python\u2019s square-brackets notation. For example, the annotation list[int] might be used to signify a list in which all the elements are of type int.\n\nSee also\n\nPEP 484 - Type Hints\n\nIntroducing Python\u2019s framework for type annotations\n\nGeneric Alias Types\n\nDocumentation for objects representing parameterized generic classes\n\nGenerics, user-defined generics and typing.Generic\n\nDocumentation on how to implement generic classes that can be parameterized at runtime and understood by static type-checkers.\n\nA class can generally only be parameterized if it defines the special class method __class_getitem__().\n\nclassmethod object.__class_getitem__(cls, key)\n\nReturn an object representing the specialization of a generic class by type arguments found in key.\n\nWhen defined on a class, __class_getitem__() is automatically a class method. As such, there is no need for it to be decorated with @classmethod when it is defined.\n\n3.3.5.1. The purpose of __class_getitem__\n\nThe purpose of __class_getitem__() is to allow runtime parameterization of standard-library generic classes in order to more easily apply type hints to these classes.\n\nTo implement custom generic classes that can be parameterized at runtime and understood by static type-checkers, users should either inherit from a standard library class that already implements __class_getitem__(), or inherit from typing.Generic, which has its own implementation of __class_getitem__().\n\nCustom implementations of __class_getitem__() on classes defined outside of the standard library may not be understood by third-party type-checkers such as mypy. Using __class_getitem__() on any class for purposes other than type hinting is discouraged.\n\n3.3.5.2. __class_getitem__ versus __getitem__\n\nUsually, the subscription of an object using square brackets will call the __getitem__() instance method defined on the object\u2019s class. However, if the object being subscribed is itself a class, the class method __class_getitem__() may be called instead. __class_getitem__() should return a GenericAlias object if it is properly defined.\n\nPresented with the expression obj[x], the Python interpreter follows something like the following process to decide whether __getitem__() or __class_getitem__() should be called:\n\nfrom inspect import isclass\n\ndef subscribe(obj, x):\n    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n\n    class_of_obj = type(obj)\n\n    # If the class of obj defines __getitem__,\n    # call class_of_obj.__getitem__(obj, x)\n    if hasattr(class_of_obj, '__getitem__'):\n        return class_of_obj.__getitem__(obj, x)\n\n    # Else, if obj is a class and defines __class_getitem__,\n    # call obj.__class_getitem__(x)\n    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n        return obj.__class_getitem__(x)\n\n    # Else, raise an exception\n    else:\n        raise TypeError(\n            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n        )\n\n\nIn Python, all classes are themselves instances of other classes. The class of a class is known as that class\u2019s metaclass, and most classes have the type class as their metaclass. type does not define __getitem__(), meaning that expressions such as list[int], dict[str, float] and tuple[str, bytes] all result in __class_getitem__() being called:\n\n>>>\n>>> # list has class \"type\" as its metaclass, like most classes:\n>>> type(list)\n<class 'type'>\n>>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\nTrue\n>>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n>>> list[int]\nlist[int]\n>>> # list.__class_getitem__ returns a GenericAlias object:\n>>> type(list[int])\n<class 'types.GenericAlias'>\n\n\nHowever, if a class has a custom metaclass that defines __getitem__(), subscribing the class may result in different behaviour. An example of this can be found in the enum module:\n\n>>>\n>>> from enum import Enum\n>>> class Menu(Enum):\n...     \"\"\"A breakfast menu\"\"\"\n...     SPAM = 'spam'\n...     BACON = 'bacon'\n...\n>>> # Enum classes have a custom metaclass:\n>>> type(Menu)\n<class 'enum.EnumMeta'>\n>>> # EnumMeta defines __getitem__,\n>>> # so __class_getitem__ is not called,\n>>> # and the result is not a GenericAlias object:\n>>> Menu['SPAM']\n<Menu.SPAM: 'spam'>\n>>> type(Menu['SPAM'])\n<enum 'Menu'>\n\n\nSee also\n\nPEP 560 - Core Support for typing module and generic types\n\nIntroducing __class_getitem__(), and outlining when a subscription results in __class_getitem__() being called instead of __getitem__()\n\n3.3.6. Emulating callable objects\nobject.__call__(self[, args...])\n\nCalled when the instance is \u201ccalled\u201d as a function; if this method is defined, x(arg1, arg2, ...) roughly translates to type(x).__call__(x, arg1, ...). The object class itself does not provide this method.\n\n3.3.7. Emulating container types\n\nThe following methods can be defined to implement container objects. None of them are provided by the object class itself. Containers usually are sequences (such as lists or tuples) or mappings (like dictionaries), but can represent other containers as well. The first set of methods is used either to emulate a sequence or to emulate a mapping; the difference is that for a sequence, the allowable keys should be the integers k for which 0 <= k < N where N is the length of the sequence, or slice objects, which define a range of items. It is also recommended that mappings provide the methods keys(), values(), items(), get(), clear(), setdefault(), pop(), popitem(), copy(), and update() behaving similar to those for Python\u2019s standard dictionary objects. The collections.abc module provides a MutableMapping abstract base class to help create those methods from a base set of __getitem__(), __setitem__(), __delitem__(), and keys(). Mutable sequences should provide methods append(), count(), index(), extend(), insert(), pop(), remove(), reverse() and sort(), like Python standard list objects. Finally, sequence types should implement addition (meaning concatenation) and multiplication (meaning repetition) by defining the methods __add__(), __radd__(), __iadd__(), __mul__(), __rmul__() and __imul__() described below; they should not define other numerical operators. It is recommended that both mappings and sequences implement the __contains__() method to allow efficient use of the in operator; for mappings, in should search the mapping\u2019s keys; for sequences, it should search through the values. It is further recommended that both mappings and sequences implement the __iter__() method to allow efficient iteration through the container; for mappings, __iter__() should iterate through the object\u2019s keys; for sequences, it should iterate through the values.\n\nobject.__len__(self)\n\nCalled to implement the built-in function len(). Should return the length of the object, an integer >= 0. Also, an object that doesn\u2019t define a __bool__() method and whose __len__() method returns zero is considered to be false in a Boolean context.\n\nCPython implementation detail: In CPython, the length is required to be at most sys.maxsize. If the length is larger than sys.maxsize some features (such as len()) may raise OverflowError. To prevent raising OverflowError by truth value testing, an object must define a __bool__() method.\n\nobject.__length_hint__(self)\n\nCalled to implement operator.length_hint(). Should return an estimated length for the object (which may be greater or less than the actual length). The length must be an integer >= 0. The return value may also be NotImplemented, which is treated the same as if the __length_hint__ method didn\u2019t exist at all. This method is purely an optimization and is never required for correctness.\n\nAdded in version 3.4.\n\nNote\n\n \n\nSlicing is done exclusively with the following three methods. A call like\n\na[1:2] = b\n\n\nis translated to\n\na[slice(1, 2, None)] = b\n\n\nand so forth. Missing slice items are always filled in with None.\n\nobject.__getitem__(self, key)\n\nCalled to implement evaluation of self[key]. For sequence types, the accepted keys should be integers. Optionally, they may support slice objects as well. Negative index support is also optional. If key is of an inappropriate type, TypeError may be raised; if key is a value outside the set of indexes for the sequence (after any special interpretation of negative values), IndexError should be raised. For mapping types, if key is missing (not in the container), KeyError should be raised.\n\nNote\n\n \n\nfor loops expect that an IndexError will be raised for illegal indexes to allow proper detection of the end of the sequence.\n\nNote\n\n \n\nWhen subscripting a class, the special class method __class_getitem__() may be called instead of __getitem__(). See __class_getitem__ versus __getitem__ for more details.\n\nobject.__setitem__(self, key, value)\n\nCalled to implement assignment to self[key]. Same note as for __getitem__(). This should only be implemented for mappings if the objects support changes to the values for keys, or if new keys can be added, or for sequences if elements can be replaced. The same exceptions should be raised for improper key values as for the __getitem__() method.\n\nobject.__delitem__(self, key)\n\nCalled to implement deletion of self[key]. Same note as for __getitem__(). This should only be implemented for mappings if the objects support removal of keys, or for sequences if elements can be removed from the sequence. The same exceptions should be raised for improper key values as for the __getitem__() method.\n\nobject.__missing__(self, key)\n\nCalled by dict.__getitem__() to implement self[key] for dict subclasses when key is not in the dictionary.\n\nobject.__iter__(self)\n\nThis method is called when an iterator is required for a container. This method should return a new iterator object that can iterate over all the objects in the container. For mappings, it should iterate over the keys of the container.\n\nobject.__reversed__(self)\n\nCalled (if present) by the reversed() built-in to implement reverse iteration. It should return a new iterator object that iterates over all the objects in the container in reverse order.\n\nIf the __reversed__() method is not provided, the reversed() built-in will fall back to using the sequence protocol (__len__() and __getitem__()). Objects that support the sequence protocol should only provide __reversed__() if they can provide an implementation that is more efficient than the one provided by reversed().\n\nThe membership test operators (in and not in) are normally implemented as an iteration through a container. However, container objects can supply the following special method with a more efficient implementation, which also does not require the object be iterable.\n\nobject.__contains__(self, item)\n\nCalled to implement membership test operators. Should return true if item is in self, false otherwise. For mapping objects, this should consider the keys of the mapping rather than the values or the key-item pairs.\n\nFor objects that don\u2019t define __contains__(), the membership test first tries iteration via __iter__(), then the old sequence iteration protocol via __getitem__(), see this section in the language reference.\n\n3.3.8. Emulating numeric types\n\nThe following methods can be defined to emulate numeric objects. Methods corresponding to operations that are not supported by the particular kind of number implemented (e.g., bitwise operations for non-integral numbers) should be left undefined.\n\nobject.__add__(self, other)\nobject.__sub__(self, other)\nobject.__mul__(self, other)\nobject.__matmul__(self, other)\nobject.__truediv__(self, other)\nobject.__floordiv__(self, other)\nobject.__mod__(self, other)\nobject.__divmod__(self, other)\nobject.__pow__(self, other[, modulo])\nobject.__lshift__(self, other)\nobject.__rshift__(self, other)\nobject.__and__(self, other)\nobject.__xor__(self, other)\nobject.__or__(self, other)\n\nThese methods are called to implement the binary arithmetic operations (+, -, *, @, /, //, %, divmod(), pow(), **, <<, >>, &, ^, |). For instance, to evaluate the expression x + y, where x is an instance of a class that has an __add__() method, type(x).__add__(x, y) is called. The __divmod__() method should be the equivalent to using __floordiv__() and __mod__(); it should not be related to __truediv__(). Note that __pow__() should be defined to accept an optional third argument if the ternary version of the built-in pow() function is to be supported.\n\nIf one of those methods does not support the operation with the supplied arguments, it should return NotImplemented.\n\nobject.__radd__(self, other)\nobject.__rsub__(self, other)\nobject.__rmul__(self, other)\nobject.__rmatmul__(self, other)\nobject.__rtruediv__(self, other)\nobject.__rfloordiv__(self, other)\nobject.__rmod__(self, other)\nobject.__rdivmod__(self, other)\nobject.__rpow__(self, other[, modulo])\nobject.__rlshift__(self, other)\nobject.__rrshift__(self, other)\nobject.__rand__(self, other)\nobject.__rxor__(self, other)\nobject.__ror__(self, other)\n\nThese methods are called to implement the binary arithmetic operations (+, -, *, @, /, //, %, divmod(), pow(), **, <<, >>, &, ^, |) with reflected (swapped) operands. These functions are only called if the left operand does not support the corresponding operation [3] and the operands are of different types. [4] For instance, to evaluate the expression x - y, where y is an instance of a class that has an __rsub__() method, type(y).__rsub__(y, x) is called if type(x).__sub__(x, y) returns NotImplemented.\n\nNote that ternary pow() will not try calling __rpow__() (the coercion rules would become too complicated).\n\nNote\n\n \n\nIf the right operand\u2019s type is a subclass of the left operand\u2019s type and that subclass provides a different implementation of the reflected method for the operation, this method will be called before the left operand\u2019s non-reflected method. This behavior allows subclasses to override their ancestors\u2019 operations.\n\nobject.__iadd__(self, other)\nobject.__isub__(self, other)\nobject.__imul__(self, other)\nobject.__imatmul__(self, other)\nobject.__itruediv__(self, other)\nobject.__ifloordiv__(self, other)\nobject.__imod__(self, other)\nobject.__ipow__(self, other[, modulo])\nobject.__ilshift__(self, other)\nobject.__irshift__(self, other)\nobject.__iand__(self, other)\nobject.__ixor__(self, other)\nobject.__ior__(self, other)\n\nThese methods are called to implement the augmented arithmetic assignments (+=, -=, *=, @=, /=, //=, %=, **=, <<=, >>=, &=, ^=, |=). These methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self). If a specific method is not defined, or if that method returns NotImplemented, the augmented assignment falls back to the normal methods. For instance, if x is an instance of a class with an __iadd__() method, x += y is equivalent to x = x.__iadd__(y) . If __iadd__() does not exist, or if x.__iadd__(y) returns NotImplemented, x.__add__(y) and y.__radd__(x) are considered, as with the evaluation of x + y. In certain situations, augmented assignment can result in unexpected errors (see Why does a_tuple[i] += [\u2018item\u2019] raise an exception when the addition works?), but this behavior is in fact part of the data model.\n\nobject.__neg__(self)\nobject.__pos__(self)\nobject.__abs__(self)\nobject.__invert__(self)\n\nCalled to implement the unary arithmetic operations (-, +, abs() and ~).\n\nobject.__complex__(self)\nobject.__int__(self)\nobject.__float__(self)\n\nCalled to implement the built-in functions complex(), int() and float(). Should return a value of the appropriate type.\n\nobject.__index__(self)\n\nCalled to implement operator.index(), and whenever Python needs to losslessly convert the numeric object to an integer object (such as in slicing, or in the built-in bin(), hex() and oct() functions). Presence of this method indicates that the numeric object is an integer type. Must return an integer.\n\nIf __int__(), __float__() and __complex__() are not defined then corresponding built-in functions int(), float() and complex() fall back to __index__().\n\nobject.__round__(self[, ndigits])\nobject.__trunc__(self)\nobject.__floor__(self)\nobject.__ceil__(self)\n\nCalled to implement the built-in function round() and math functions trunc(), floor() and ceil(). Unless ndigits is passed to __round__() all these methods should return the value of the object truncated to an Integral (typically an int).\n\nThe built-in function int() falls back to __trunc__() if neither __int__() nor __index__() is defined.\n\nChanged in version 3.11: The delegation of int() to __trunc__() is deprecated.\n\n3.3.9. With Statement Context Managers\n\nA context manager is an object that defines the runtime context to be established when executing a with statement. The context manager handles the entry into, and the exit from, the desired runtime context for the execution of the block of code. Context managers are normally invoked using the with statement (described in section The with statement), but can also be used by directly invoking their methods.\n\nTypical uses of context managers include saving and restoring various kinds of global state, locking and unlocking resources, closing opened files, etc.\n\nFor more information on context managers, see Context Manager Types. The object class itself does not provide the context manager methods.\n\nobject.__enter__(self)\n\nEnter the runtime context related to this object. The with statement will bind this method\u2019s return value to the target(s) specified in the as clause of the statement, if any.\n\nobject.__exit__(self, exc_type, exc_value, traceback)\n\nExit the runtime context related to this object. The parameters describe the exception that caused the context to be exited. If the context was exited without an exception, all three arguments will be None.\n\nIf an exception is supplied, and the method wishes to suppress the exception (i.e., prevent it from being propagated), it should return a true value. Otherwise, the exception will be processed normally upon exit from this method.\n\nNote that __exit__() methods should not reraise the passed-in exception; this is the caller\u2019s responsibility.\n\nSee also\n\nPEP 343 - The \u201cwith\u201d statement\n\nThe specification, background, and examples for the Python with statement.\n\n3.3.10. Customizing positional arguments in class pattern matching\n\nWhen using a class name in a pattern, positional arguments in the pattern are not allowed by default, i.e. case MyClass(x, y) is typically invalid without special support in MyClass. To be able to use that kind of pattern, the class needs to define a __match_args__ attribute.\n\nobject.__match_args__\n\nThis class variable can be assigned a tuple of strings. When this class is used in a class pattern with positional arguments, each positional argument will be converted into a keyword argument, using the corresponding value in __match_args__ as the keyword. The absence of this attribute is equivalent to setting it to ().\n\nFor example, if MyClass.__match_args__ is (\"left\", \"center\", \"right\") that means that case MyClass(x, y) is equivalent to case MyClass(left=x, center=y). Note that the number of arguments in the pattern must be smaller than or equal to the number of elements in __match_args__; if it is larger, the pattern match attempt will raise a TypeError.\n\nAdded in version 3.10.\n\nSee also\n\nPEP 634 - Structural Pattern Matching\n\nThe specification for the Python match statement.\n\n3.3.11. Emulating buffer types\n\nThe buffer protocol provides a way for Python objects to expose efficient access to a low-level memory array. This protocol is implemented by builtin types such as bytes and memoryview, and third-party libraries may define additional buffer types.\n\nWhile buffer types are usually implemented in C, it is also possible to implement the protocol in Python.\n\nobject.__buffer__(self, flags)\n\nCalled when a buffer is requested from self (for example, by the memoryview constructor). The flags argument is an integer representing the kind of buffer requested, affecting for example whether the returned buffer is read-only or writable. inspect.BufferFlags provides a convenient way to interpret the flags. The method must return a memoryview object.\n\nobject.__release_buffer__(self, buffer)\n\nCalled when a buffer is no longer needed. The buffer argument is a memoryview object that was previously returned by __buffer__(). The method must release any resources associated with the buffer. This method should return None. Buffer objects that do not need to perform any cleanup are not required to implement this method.\n\nAdded in version 3.12.\n\nSee also\n\nPEP 688 - Making the buffer protocol accessible in Python\n\nIntroduces the Python __buffer__ and __release_buffer__ methods.\n\ncollections.abc.Buffer\n\nABC for buffer types.\n\n3.3.12. Special method lookup\n\nFor custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object\u2019s type, not in the object\u2019s instance dictionary. That behaviour is the reason why the following code raises an exception:\n\n>>>\n>>> class C:\n...     pass\n...\n>>> c = C()\n>>> c.__len__ = lambda: 5\n>>> len(c)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: object of type 'C' has no len()\n\n\nThe rationale behind this behaviour lies with a number of special methods such as __hash__() and __repr__() that are implemented by all objects, including type objects. If the implicit lookup of these methods used the conventional lookup process, they would fail when invoked on the type object itself:\n\n>>>\n>>> 1 .__hash__() == hash(1)\nTrue\n>>> int.__hash__() == hash(int)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: descriptor '__hash__' of 'int' object needs an argument\n\n\nIncorrectly attempting to invoke an unbound method of a class in this way is sometimes referred to as \u2018metaclass confusion\u2019, and is avoided by bypassing the instance when looking up special methods:\n\n>>>\n>>> type(1).__hash__(1) == hash(1)\nTrue\n>>> type(int).__hash__(int) == hash(int)\nTrue\n\n\nIn addition to bypassing any instance attributes in the interest of correctness, implicit special method lookup generally also bypasses the __getattribute__() method even of the object\u2019s metaclass:\n\n>>>\n>>> class Meta(type):\n...     def __getattribute__(*args):\n...         print(\"Metaclass getattribute invoked\")\n...         return type.__getattribute__(*args)\n...\n>>> class C(object, metaclass=Meta):\n...     def __len__(self):\n...         return 10\n...     def __getattribute__(*args):\n...         print(\"Class getattribute invoked\")\n...         return object.__getattribute__(*args)\n...\n>>> c = C()\n>>> c.__len__()                 # Explicit lookup via instance\nClass getattribute invoked\n10\n>>> type(c).__len__(c)          # Explicit lookup via type\nMetaclass getattribute invoked\n10\n>>> len(c)                      # Implicit lookup\n10\n\n\nBypassing the __getattribute__() machinery in this fashion provides significant scope for speed optimisations within the interpreter, at the cost of some flexibility in the handling of special methods (the special method must be set on the class object itself in order to be consistently invoked by the interpreter).\n\n3.4. Coroutines\n3.4.1. Awaitable Objects\n\nAn awaitable object generally implements an __await__() method. Coroutine objects returned from async def functions are awaitable.\n\nNote\n\n \n\nThe generator iterator objects returned from generators decorated with types.coroutine() are also awaitable, but they do not implement __await__().\n\nobject.__await__(self)\n\nMust return an iterator. Should be used to implement awaitable objects. For instance, asyncio.Future implements this method to be compatible with the await expression. The object class itself is not awaitable and does not provide this method.\n\nNote\n\n \n\nThe language doesn\u2019t place any restriction on the type or value of the objects yielded by the iterator returned by __await__, as this is specific to the implementation of the asynchronous execution framework (e.g. asyncio) that will be managing the awaitable object.\n\nAdded in version 3.5.\n\nSee also\n\n \n\nPEP 492 for additional information about awaitable objects.\n\n3.4.2. Coroutine Objects\n\nCoroutine objects are awaitable objects. A coroutine\u2019s execution can be controlled by calling __await__() and iterating over the result. When the coroutine has finished executing and returns, the iterator raises StopIteration, and the exception\u2019s value attribute holds the return value. If the coroutine raises an exception, it is propagated by the iterator. Coroutines should not directly raise unhandled StopIteration exceptions.\n\nCoroutines also have the methods listed below, which are analogous to those of generators (see Generator-iterator methods). However, unlike generators, coroutines do not directly support iteration.\n\nChanged in version 3.5.2: It is a RuntimeError to await on a coroutine more than once.\n\ncoroutine.send(value)\n\nStarts or resumes execution of the coroutine. If value is None, this is equivalent to advancing the iterator returned by __await__(). If value is not None, this method delegates to the send() method of the iterator that caused the coroutine to suspend. The result (return value, StopIteration, or other exception) is the same as when iterating over the __await__() return value, described above.\n\ncoroutine.throw(value)\ncoroutine.throw(type[, value[, traceback]])\n\nRaises the specified exception in the coroutine. This method delegates to the throw() method of the iterator that caused the coroutine to suspend, if it has such a method. Otherwise, the exception is raised at the suspension point. The result (return value, StopIteration, or other exception) is the same as when iterating over the __await__() return value, described above. If the exception is not caught in the coroutine, it propagates back to the caller.\n\nChanged in version 3.12: The second signature (type[, value[, traceback]]) is deprecated and may be removed in a future version of Python.\n\ncoroutine.close()\n\nCauses the coroutine to clean itself up and exit. If the coroutine is suspended, this method first delegates to the close() method of the iterator that caused the coroutine to suspend, if it has such a method. Then it raises GeneratorExit at the suspension point, causing the coroutine to immediately clean itself up. Finally, the coroutine is marked as having finished executing, even if it was never started.\n\nCoroutine objects are automatically closed using the above process when they are about to be destroyed.\n\n3.4.3. Asynchronous Iterators\n\nAn asynchronous iterator can call asynchronous code in its __anext__ method.\n\nAsynchronous iterators can be used in an async for statement.\n\nThe object class itself does not provide these methods.\n\nobject.__aiter__(self)\n\nMust return an asynchronous iterator object.\n\nobject.__anext__(self)\n\nMust return an awaitable resulting in a next value of the iterator. Should raise a StopAsyncIteration error when the iteration is over.\n\nAn example of an asynchronous iterable object:\n\nclass Reader:\n    async def readline(self):\n        ...\n\n    def __aiter__(self):\n        return self\n\n    async def __anext__(self):\n        val = await self.readline()\n        if val == b'':\n            raise StopAsyncIteration\n        return val\n\n\nAdded in version 3.5.\n\nChanged in version 3.7: Prior to Python 3.7, __aiter__() could return an awaitable that would resolve to an asynchronous iterator.\n\nStarting with Python 3.7, __aiter__() must return an asynchronous iterator object. Returning anything else will result in a TypeError error.\n\n3.4.4. Asynchronous Context Managers\n\nAn asynchronous context manager is a context manager that is able to suspend execution in its __aenter__ and __aexit__ methods.\n\nAsynchronous context managers can be used in an async with statement.\n\nThe object class itself does not provide these methods.\n\nobject.__aenter__(self)\n\nSemantically similar to __enter__(), the only difference being that it must return an awaitable.\n\nobject.__aexit__(self, exc_type, exc_value, traceback)\n\nSemantically similar to __exit__(), the only difference being that it must return an awaitable.\n\nAn example of an asynchronous context manager class:\n\nclass AsyncContextManager:\n    async def __aenter__(self):\n        await log('entering context')\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await log('exiting context')\n\n\nAdded in version 3.5.\n\nFootnotes\n\n[1]\n\nIt is possible in some cases to change an object\u2019s type, under certain controlled conditions. It generally isn\u2019t a good idea though, since it can lead to some very strange behaviour if it is handled incorrectly.\n\n[2]\n\nThe __hash__(), __iter__(), __reversed__(), __contains__(), __class_getitem__() and __fspath__() methods have special handling for this. Others will still raise a TypeError, but may do so by relying on the behavior that None is not callable.\n\n[3]\n\n\u201cDoes not support\u201d here means that the class has no such method, or the method returns NotImplemented. Do not set the method to None if you want to force fallback to the right operand\u2019s reflected method\u2014that will instead have the opposite effect of explicitly blocking such fallback.\n\n[4]\n\nFor operands of the same type, it is assumed that if the non-reflected method \u2013 such as __add__() \u2013 fails then the overall operation is not supported, which is why the reflected method is not called.\n\nTable of Contents\n3. Data model\n3.1. Objects, values and types\n3.2. The standard type hierarchy\n3.2.1. None\n3.2.2. NotImplemented\n3.2.3. Ellipsis\n3.2.4. numbers.Number\n3.2.4.1. numbers.Integral\n3.2.4.2. numbers.Real (float)\n3.2.4.3. numbers.Complex (complex)\n3.2.5. Sequences\n3.2.5.1. Immutable sequences\n3.2.5.2. Mutable sequences\n3.2.6. Set types\n3.2.7. Mappings\n3.2.7.1. Dictionaries\n3.2.8. Callable types\n3.2.8.1. User-defined functions\n3.2.8.1.1. Special read-only attributes\n3.2.8.1.2. Special writable attributes\n3.2.8.2. Instance methods\n3.2.8.3. Generator functions\n3.2.8.4. Coroutine functions\n3.2.8.5. Asynchronous generator functions\n3.2.8.6. Built-in functions\n3.2.8.7. Built-in methods\n3.2.8.8. Classes\n3.2.8.9. Class Instances\n3.2.9. Modules\n3.2.9.1. Import-related attributes on module objects\n3.2.9.2. Other writable attributes on module objects\n3.2.9.3. Module dictionaries\n3.2.10. Custom classes\n3.2.10.1. Special attributes\n3.2.10.2. Special methods\n3.2.11. Class instances\n3.2.11.1. Special attributes\n3.2.12. I/O objects (also known as file objects)\n3.2.13. Internal types\n3.2.13.1. Code objects\n3.2.13.1.1. Special read-only attributes\n3.2.13.1.2. Methods on code objects\n3.2.13.2. Frame objects\n3.2.13.2.1. Special read-only attributes\n3.2.13.2.2. Special writable attributes\n3.2.13.2.3. Frame object methods\n3.2.13.3. Traceback objects\n3.2.13.4. Slice objects\n3.2.13.5. Static method objects\n3.2.13.6. Class method objects\n3.3. Special method names\n3.3.1. Basic customization\n3.3.2. Customizing attribute access\n3.3.2.1. Customizing module attribute access\n3.3.2.2. Implementing Descriptors\n3.3.2.3. Invoking Descriptors\n3.3.2.4. __slots__\n3.3.3. Customizing class creation\n3.3.3.1. Metaclasses\n3.3.3.2. Resolving MRO entries\n3.3.3.3. Determining the appropriate metaclass\n3.3.3.4. Preparing the class namespace\n3.3.3.5. Executing the class body\n3.3.3.6. Creating the class object\n3.3.3.7. Uses for metaclasses\n3.3.4. Customizing instance and subclass checks\n3.3.5. Emulating generic types\n3.3.5.1. The purpose of __class_getitem__\n3.3.5.2. __class_getitem__ versus __getitem__\n3.3.6. Emulating callable objects\n3.3.7. Emulating container types\n3.3.8. Emulating numeric types\n3.3.9. With Statement Context Managers\n3.3.10. Customizing positional arguments in class pattern matching\n3.3.11. Emulating buffer types\n3.3.12. Special method lookup\n3.4. Coroutines\n3.4.1. Awaitable Objects\n3.4.2. Coroutine Objects\n3.4.3. Asynchronous Iterators\n3.4.4. Asynchronous Context Managers\nPrevious topic\n\n2. Lexical analysis\n\nNext topic\n\n4. Execution model\n\nThis Page\nReport a Bug\nShow Source\n\u00ab\nindex\nmodules |\nnext |\nprevious |\n Python \u00bb \nEnglish\nSpanish | espa\u00f1ol\nFrench | fran\u00e7ais\nItalian | italiano\nJapanese | \u65e5\u672c\u8a9e\nKorean | \ud55c\uad6d\uc5b4\nPolish | polski\nBrazilian Portuguese | Portugu\u00eas brasileiro\nTurkish | T\u00fcrk\u00e7e\nSimplified Chinese | \u7b80\u4f53\u4e2d\u6587\nTraditional Chinese | \u7e41\u9ad4\u4e2d\u6587\ndev (3.14)\n3.13.2\n3.12\n3.11\n3.10\n3.9\n3.8\n3.7\n3.6\n3.5\n3.4\n3.3\n3.2\n3.1\n3.0\n2.7\n2.6\n 3.13.2 Documentation \u00bb The Python Language Reference \u00bb 3. Data model\n  |\nTheme \nAuto\nLight\nDark\n |\n\u00a9 Copyright 2001-2025, Python Software Foundation.\nThis page is licensed under the Python Software Foundation License Version 2.\nExamples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.\nSee History and License for more information.\n\nThe Python Software Foundation is a non-profit corporation. Please donate.\n\nLast updated on Mar 11, 2025 (12:47 UTC). Found a bug?\nCreated using Sphinx 8.2.3.\n\nStart\u00a0Here\n Learn Python \nMore \n/\nJoin\nSign\u2011In\n\n\u2014 FREE Email Series \u2014\n\n\ud83d\udc0d Python Tricks \ud83d\udc8c\n\nGet Python Tricks \u00bb\n\n\ud83d\udd12 No spam. Unsubscribe any time.\n\nBrowse Topics \nGuided Learning Paths\n\n Basics \n Intermediate \n Advanced\napi best-practices career community databases data-science data-structures data-viz devops django docker editors flask front-end gamedev gui machine-learning numpy projects python testing tools web-dev web-scraping\n\nTable of Contents\n\nWhat Are Inheritance and Composition?\nAn Overview of Inheritance in Python\nComposition in Python\nChoosing Between Inheritance and Composition in Python\nConclusion\nRecommended Reading\nFrequently Asked Questions\nMark as Completed\nShare\n\n Recommended Video Course\nInheritance and Composition: A Python OOP Guide\n\nInheritance and Composition: A Python OOP Guide\nby Isaac Rodriguez \n Jan 11, 2025 \n intermediate best-practices python\nMark as Completed\nShare\n\nTable of Contents\n\nWhat Are Inheritance and Composition?\nWhat\u2019s Inheritance?\nWhat\u2019s Composition?\nAn Overview of Inheritance in Python\nThe Object Super Class\nExceptions Are an Exception\nCreating Class Hierarchies\nAbstract Base Classes in Python\nImplementation Inheritance vs Interface Inheritance\nThe Class Explosion Problem\nInheriting Multiple Classes\nComposition in Python\nFlexible Designs With Composition\nCustomizing Behavior With Composition\nChoosing Between Inheritance and Composition in Python\nInheritance to Model \u201cIs A\u201d Relationship\nMixing Features With Mixin Classes\nComposition to Model \u201cHas A\u201d Relationship\nComposition to Change Run-Time Behavior\nChoosing Between Inheritance and Composition in Python\nConclusion\nRecommended Reading\nFrequently Asked Questions\nRemove ads\n\n Watch Now This tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding: Inheritance and Composition: A Python OOP Guide\n\nIn Python, understanding inheritance and composition is crucial for effective object-oriented programming. Inheritance allows you to model an is a relationship, where a derived class extends the functionality of a base class. Composition, on the other hand, models a has a relationship, where a class contains objects of other classes to build complex structures. Both techniques promote code reuse, but they approach it differently.\n\nBy the end of this tutorial, you\u2019ll understand that:\n\nComposition and inheritance in Python model relationships between classes, enabling code reuse in different ways.\nComposition is achieved by creating classes that contain objects of other classes, allowing for flexible designs.\nInheritance models an is a relationship, allowing derived classes to extend base class functionality.\nInheritance in Python is achieved by defining classes that derive from base classes, inheriting their interface and implementation.\n\nExploring the differences between inheritance and composition helps you choose the right approach for designing robust, maintainable Python applications. Understanding how and when to apply each concept is key to leveraging the full power of Python\u2019s object-oriented programming capabilities.\n\nGet Your Code: Click here to get the free sample code that shows you how to use inheritance and composition in Python.\n\n Take the Quiz: Test your knowledge with our interactive \u201cInheritance and Composition: A Python OOP Guide\u201d quiz. You\u2019ll receive a score upon completion to help you track your learning progress:\n\nInteractive Quiz\n\nInheritance and Composition: A Python OOP Guide\n\nIn this quiz, you'll test your understanding of inheritance and composition in Python. These are two major concepts in object-oriented programming that help model the relationship between two classes. By working through this quiz, you'll revisit how to use inheritance and composition in Python, model class hierarchies, and use multiple inheritance.\n\nWhat Are Inheritance and Composition?\n\nInheritance and composition are two major concepts in object-oriented programming that model the relationship between two classes. They drive the design of an application and determine how the application should evolve as new features are added or requirements change.\n\nBoth of them enable code reuse, but they do it in different ways.\n\nRemove ads\nWhat\u2019s Inheritance?\n\nInheritance models what\u2019s called an is a relationship. This means that when you have a Derived class that inherits from a Base class, you\u2019ve created a relationship where Derived is a specialized version of Base.\n\nInheritance is represented using the Unified Modeling Language, or UML, in the following way:\n\nThis model represents classes as boxes with the class name on top. It represents the inheritance relationship with an arrow from the derived class pointing to the base class. The word extends is usually added to the arrow.\n\nNote: In an inheritance relationship:\n\nClasses that inherit from another are called derived classes, subclasses, or subtypes.\nClasses from which other classes are derived are called base classes or super classes.\nA derived class is said to derive, inherit, or extend a base class.\n\nSay you have the base class Animal, and you derive from it to create a Horse class. The inheritance relationship states that Horse is an Animal. This means that Horse inherits the interface and implementation of Animal, and you can use Horse objects to replace Animal objects in the application.\n\nThis is known as the Liskov substitution principle. The principle states that if S is a subtype of T, then replacing objects of type T with objects of type S doesn\u2019t change the program\u2019s behavior.\n\nYou\u2019ll see in this tutorial why you should always follow the Liskov substitution principle when creating your class hierarchies, and you\u2019ll learn about the problems that you\u2019ll run into if you don\u2019t.\n\nWhat\u2019s Composition?\n\nComposition is a concept that models a has a relationship. It enables creating complex types by combining objects of other types. This means that a class Composite can contain an object of another class Component. This relationship means that a Composite has a Component.\n\nUML represents composition as follows:\n\nThe model represents composition through a line that starts with a diamond at the composite class and points to the component class. The composite side can express the cardinality of the relationship. The cardinality indicates the number or the valid range of Component instances that the Composite class will contain.\n\nIn the diagram above, the 1 represents that the Composite class contains one object of type Component. You can express cardinality in the following ways:\n\nA number indicates the number of Component instances that Composite contains.\nThe * symbol indicates that the Composite class can contain a variable number of Component instances.\nA range 1..4 indicates that the Composite class can contain a range of Component instances. You indicate the range with the minimum and maximum number of instances, or minimum and many instances like in 1..*.\n\nNote: Classes that contain objects of other classes are usually referred to as composites, while classes that are used to create more complex types are referred to as components.\n\nFor example, your Horse class can be composed by another object of type Tail. Composition allows you to express that relationship by saying Horse has a Tail.\n\nComposition enables you to reuse code by adding objects to other objects, as opposed to inheriting the interface and implementation of other classes. Both Horse and Dog classes can leverage the functionality of Tail through composition without deriving one class from the other.\n\nAn Overview of Inheritance in Python\n\nEverything in Python is an object. Modules are objects, class definitions and functions are objects, and of course, objects created from classes are objects too.\n\nInheritance is a required feature of every object-oriented programming language. This means that Python supports inheritance, and as you\u2019ll see later, it\u2019s one of the few languages that supports multiple inheritance.\n\nWhen you write Python code using classes, you\u2019re using inheritance even if you don\u2019t know that you\u2019re using it. Next up, take a look at what that means.\n\nRemove ads\nThe Object Super Class\n\nThe easiest way to see inheritance in Python is to jump into the Python interactive shell and write a little bit of code. You\u2019ll start by writing the simplest class possible:\n\nPython\n>>> class EmptyClass:\n...     pass\n...\n\n\nYou declared EmptyClass, which doesn\u2019t do much, but it\u2019ll illustrate the most basic inheritance concepts. Now that you have the class declared, you can create an instance of the class and use the dir() function to list its members:\n\nPython\n>>> c = EmptyClass()\n>>> dir(c)\n['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__',\n'__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__',\n'__hash__', '__init__', '__init_subclass__', '__le__', '__lt__',\n'__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',\n'__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']\n\n\nThe dir() function returns a list of all the members in the specified object. You haven\u2019t declared any members in EmptyClass, so where\u2019s the list coming from? You can find out using the interactive interpreter:\n\nPython\n>>> o = object()\n>>> dir(o)\n['__class__', '__delattr__', '__dir__', '__doc__', '__eq__',\n'__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__',\n'__hash__', '__init__', '__init_subclass__', '__le__', '__lt__',\n'__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',\n'__setattr__', '__sizeof__', '__str__', '__subclasshook__']\n\n\nAs you can see, the two lists are nearly identical. There are three additional members in EmptyClass:\n\n__dict__\n__module__\n__weakref__\n\nHowever, every single member of the object class is also present in EmptyClass.\n\nThis is because every class that you create in Python implicitly derives from object. You could be more explicit and write class EmptyClass(object):, but it\u2019s redundant and unnecessary.\n\nNote: In Python 2, you had to explicitly derive from object for reasons beyond the scope of this tutorial, but you can read about it in the new-style and classic classes section of the Python 2 documentation.\n\nOkay, it\u2019s not entirely true that every class in Python derives from object. There\u2019s one aptly named exception, which you\u2019ll learn about next.\n\nExceptions Are an Exception\n\nEvery class that you create in Python will implicitly derive from object. However, there\u2019s one exception to this rule: classes used to indicate errors by raising an exception.\n\nIf you try to treat a normal Python class like an exception and raise it, then Python will present you with a TypeError:\n\nPython\n>>> class NotAnError:\n...     pass\n...\n>>> raise NotAnError()\nTraceback (most recent call last):\n  ...\nTypeError: exceptions must derive from BaseException\n\n\nYou created a new class to indicate a type of error. Then you tried to raise the class to signal an exception. Python does indeed raise an exception, but the output states that the exception is of type TypeError, not NotAnError, and that all exceptions must derive from BaseException.\n\nBaseException is a base class provided for all error types. To create a new error type, you must derive your class from BaseException or one of its derived classes. The convention in Python is to derive your custom error types from Exception, which in turn derives from BaseException.\n\nThe correct way to define your error type is the following:\n\nPython\n>>> class AnError(Exception):\n...     pass\n...\n>>> raise AnError()\nTraceback (most recent call last):\n  ...\nAnError\n\n\nIn this example, AnError explicitly inherits from Exception instead of implicitly inheriting from object. With that change, you\u2019ve fulfilled the requirements for creating a custom exception, and you can now raise your new exception class. When you raise AnError, the output correctly states that Python raised an error of the type AnError.\n\nRemove ads\nCreating Class Hierarchies\n\nInheritance is the mechanism that you\u2019ll use to create hierarchies of related classes. These related classes will share a common interface that the base classes will define. Derived classes can specialize the interface by providing a particular implementation where applicable.\n\nIn this section, you\u2019ll start modeling an HR system. Along the way, you\u2019ll explore the use of inheritance and see how derived classes can provide a concrete implementation of the base class interface.\n\nThe HR system needs to process payroll for the company\u2019s employees, but there are different types of employees depending on how their payroll is calculated.\n\nYou start by implementing a PayrollSystem class that processes payroll:\n\nPython\nhr.py\nclass PayrollSystem:\n    def calculate_payroll(self, employees):\n        print(\"Calculating Payroll\")\n        print(\"===================\")\n        for employee in employees:\n            print(f\"Payroll for: {employee.id} - {employee.name}\")\n            print(f\"- Check amount: {employee.calculate_payroll()}\")\n            print(\"\")\n\n\nPayrollSystem implements a .calculate_payroll() method that takes a collection of employees and prints their .id, .name, and check amount using the .calculate_payroll() method exposed on each employee object.\n\nNow, you implement a base class, Employee, that handles the common interface for every employee type:\n\nPython\nhr.py\n# ...\n\nclass Employee:\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n\n\nEmployee is the base class for all employee types. It\u2019s constructed with an .id and a .name. What you\u2019re saying is that every Employee must have an .id as well as a .name assigned.\n\nThe HR system requires that every Employee processed must provide a .calculate_payroll() interface that returns the weekly salary for the employee. The implementation of that interface differs depending on the type of Employee.\n\nFor example, administrative workers have a fixed salary, so every week they get paid the same amount:\n\nPython\nhr.py\n# ...\n\nclass SalaryEmployee(Employee):\n    def __init__(self, id, name, weekly_salary):\n        super().__init__(id, name)\n        self.weekly_salary = weekly_salary\n\n    def calculate_payroll(self):\n        return self.weekly_salary\n\n\nYou create a derived class, SalaryEmployee, that inherits from Employee. The class initializes with the .id and .name required by the base class, and you use super() to initialize the members of the base class. You can read all about super() in Supercharge Your Classes With Python super().\n\nSalaryEmployee also requires a weekly_salary initialization parameter that represents the amount that the employee makes per week.\n\nThe class provides the required .calculate_payroll() method that the HR system uses. The implementation just returns the amount stored in weekly_salary.\n\nThe company also employs manufacturing workers who are paid by the hour, so you add HourlyEmployee to the HR system:\n\nPython\nhr.py\n# ...\n\nclass HourlyEmployee(Employee):\n    def __init__(self, id, name, hours_worked, hourly_rate):\n        super().__init__(id, name)\n        self.hours_worked = hours_worked\n        self.hourly_rate = hourly_rate\n\n    def calculate_payroll(self):\n        return self.hours_worked * self.hourly_rate\n\n\nThe HourlyEmployee class is initialized with .id and .name, like the base class, plus the hours_worked and the hourly_rate required to calculate the payroll. You implement the .calculate_payroll() method by returning the hours worked times the hourly rate.\n\nFinally, the company employs sales associates who are paid through a fixed salary plus a commission based on their sales, so you create a CommissionEmployee class:\n\nPython\nhr.py\n# ...\n\nclass CommissionEmployee(SalaryEmployee):\n    def __init__(self, id, name, weekly_salary, commission):\n        super().__init__(id, name, weekly_salary)\n        self.commission = commission\n\n    def calculate_payroll(self):\n        fixed = super().calculate_payroll()\n        return fixed + self.commission\n\n\nYou derive CommissionEmployee from SalaryEmployee because both classes have a weekly_salary to consider. At the same time, you initialize CommissionEmployee with a commission value that\u2019s based on the sales for the employee.\n\nWith .calculate_payroll(), you leverage the implementation of the base class to retrieve the fixed salary, and you add the commission value.\n\nSince CommissionEmployee derives from SalaryEmployee, you have access to the weekly_salary property directly, and you could\u2019ve implemented .calculate_payroll() using the value of that property.\n\nThe problem with accessing the property directly is that if the implementation of SalaryEmployee.calculate_payroll() changes, then you\u2019ll have to also change the implementation of CommissionEmployee.calculate_payroll(). It\u2019s better to rely on the already-implemented method in the base class and extend the functionality as needed.\n\nYou\u2019ve created your first class hierarchy for the system. The UML diagram of the classes looks like this:\n\nThe diagram shows the inheritance hierarchy of the classes. The derived classes implement the IPayrollCalculator interface, which the PayrollSystem requires. The PayrollSystem.calculate_payroll() implementation requires that the objects in the employees collection contain an .id, .name, and .calculate_payroll() implementation.\n\nNote: Interfaces are represented similarly to classes in UML diagrams, with the word Interface above the interface name. Interface names are usually prefixed with a capital I.\n\nIn Python, you don\u2019t implement interfaces explicitly. Instead, interfaces are defined by the attributes used and methods called by other functions and methods.\n\nNext, create a new file and call it program.py. This program creates the employees and passes them to the payroll system to process payroll:\n\nPython\nprogram.py\nimport hr\n\nsalary_employee = hr.SalaryEmployee(1, \"John Smith\", 1500)\nhourly_employee = hr.HourlyEmployee(2, \"Jane Doe\", 40, 15)\ncommission_employee = hr.CommissionEmployee(3, \"Kevin Bacon\", 1000, 250)\n\npayroll_system = hr.PayrollSystem()\npayroll_system.calculate_payroll(\n    [salary_employee, hourly_employee, commission_employee]\n)\n\n\nYou can run the program in the command line and see the results:\n\nShell\n$ python program.py\n\nCalculating Payroll\n===================\nPayroll for: 1 - John Smith\n- Check amount: 1500\n\nPayroll for: 2 - Jane Doe\n- Check amount: 600\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1250\n\n\nThe program creates three employee objects, one for each of the derived classes. Then, it creates the payroll system and passes a list of the employees to its .calculate_payroll() method, which calculates the payroll for each employee and prints the results.\n\nNotice how the Employee base class doesn\u2019t define a .calculate_payroll() method. This means that if you were to create a plain Employee object and pass it to the PayrollSystem, then you\u2019d get an error. You can try it in the Python interactive interpreter:\n\nPython\n>>> import hr\n>>> employee = hr.Employee(1, \"Invalid\")\n>>> payroll_system = hr.PayrollSystem()\n>>> payroll_system.calculate_payroll([employee])\n\nCalculating Payroll\n===================\nPayroll for: 1 - Invalid\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/Users/martin/hr.py\", line 7, in calculate_payroll\n    print(f\"- Check amount: {employee.calculate_payroll()}\")\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\nAttributeError: 'Employee' object has no attribute 'calculate_payroll'\n\n\nWhile you can instantiate an Employee object, PayrollSystem can\u2019t use the object. Why? Because it can\u2019t call .calculate_payroll() for Employee. To be more explicit about the requirements of PayrollSystem, you can convert the Employee class, which is currently a concrete class, to an abstract class. That way, no employee is ever just an Employee, but instead always a derived class that implements .calculate_payroll().\n\nRemove ads\nAbstract Base Classes in Python\n\nThe Employee class in the example above is what is called an abstract base class. Abstract base classes exist to be inherited, but never instantiated. Python provides the abc module to formally define abstract base classes.\n\nYou can use leading underscores in your class name to communicate that objects of that class shouldn\u2019t be created. Underscores provide a friendly way to prevent misuse of your code, but they don\u2019t prevent eager users from creating instances of that class.\n\nThe abc module in the Python standard library provides functionality to prevent creating objects from abstract base classes.\n\nYou can modify the implementation of the Employee class to ensure that it can\u2019t be instantiated:\n\nPython\nhr.py\nfrom abc import ABC, abstractmethod\n\n# ...\n\nclass Employee(ABC):\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n\n    @abstractmethod\n    def calculate_payroll(self):\n        pass\n\n\nYou derive Employee from ABC, making it an abstract base class. Then, you decorate the .calculate_payroll() method with the @abstractmethod decorator.\n\nThis change has two nice side-effects:\n\nYou\u2019re telling users of the module that objects of type Employee can\u2019t be created.\nYou\u2019re telling other developers working on the hr module that if they derive from Employee, then they must override the .calculate_payroll() abstract method.\n\nYou can see that you can\u2019t create objects of type Employee anymore using the interactive interpreter:\n\nPython\n>>> import hr\n>>> employee = hr.Employee(1, \"Abstract\")\nTraceback (most recent call last):\n  ...\nTypeError: Can't instantiate abstract class Employee\n\u2b91 with abstract method calculate_payroll\n\n\nThe output shows that you can\u2019t instantiate the class because it contains an abstract method, .calculate_payroll(). Derived classes must override the method to allow creating objects of their type.\n\nImplementation Inheritance vs Interface Inheritance\n\nWhen you derive one class from another, the derived class inherits both of the following:\n\nThe base class interface: The derived class inherits all the methods, properties, and attributes of the base class.\n\nThe base class implementation: The derived class inherits the code that implements the class interface.\n\nMost of the time, you\u2019ll want to inherit the implementation of a class, but you\u2019ll want to implement multiple interfaces so that you can use your objects in different situations.\n\nModern programming languages are designed with this basic concept in mind. They allow you to inherit from a single class, but you can implement multiple interfaces.\n\nIn Python, you don\u2019t have to explicitly declare an interface. Any object that implements the desired interface can be used in place of another object. This is known as duck typing. Duck typing is usually explained as if it walks like a duck and it quacks like a duck, then it must be a duck. In other words, it\u2019s enough to behave like a duck to be considered a duck.\n\nTo illustrate this, you\u2019ll now add a DisgruntledEmployee class to the example above, and it won\u2019t derive from Employee. Create a new file called disgruntled.py and add the following code:\n\nPython\ndisgruntled.py\nclass DisgruntledEmployee:\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n\n    def calculate_payroll(self):\n        return 1_000_000\n\n\nThe DisgruntledEmployee class doesn\u2019t derive from Employee, but it exposes the same interface that PayrollSystem requires. Remember that PayrollSystem.calculate_payroll() requires a list of objects that implement the following interface:\n\nAn .id property or attribute that returns the employee\u2019s ID\nA .name property or attribute that represents the employee\u2019s name\nA .calculate_payroll() method that doesn\u2019t take any parameters and returns the payroll amount to process\n\nThe DisgruntledEmployee class meets all these requirements, so PayrollSystem can still calculate its payroll.\n\nYou can modify the program to use the DisgruntledEmployee class:\n\nPython\nprogram.py\nimport hr\nimport disgruntled\n\nsalary_employee = hr.SalaryEmployee(1, \"John Smith\", 1500)\nhourly_employee = hr.HourlyEmployee(2, \"Jane Doe\", 40, 15)\ncommission_employee = hr.CommissionEmployee(3, \"Kevin Bacon\", 1000, 250)\ndisgruntled_employee = disgruntled.DisgruntledEmployee(20000, \"Anonymous\")\n\npayroll_system = hr.PayrollSystem()\npayroll_system.calculate_payroll(\n    [\n        salary_employee,\n        hourly_employee,\n        commission_employee,\n        disgruntled_employee,\n    ]\n)\n\n\nThe program creates a DisgruntledEmployee object and adds it to the list that PayrollSystem processes. You can now run the program and see its output:\n\nShell\n$ python program.py\n\nCalculating Payroll\n===================\nPayroll for: 1 - John Smith\n- Check amount: 1500\n\nPayroll for: 2 - Jane Doe\n- Check amount: 600\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1250\n\nPayroll for: 20000 - Anonymous\n- Check amount: 1000000\n\n\nAs you can see, the PayrollSystem can still process the new object because it meets the desired interface.\n\nSince you don\u2019t have to derive from a specific class for your objects to be reusable by the program, you may be asking why you should use inheritance instead of just implementing the desired interface. The following rules may help you to make this decision:\n\nUse inheritance to reuse an implementation: Your derived classes should leverage most of their base class implementation. They must also model an is a relationship. A Customer class might also have an .id and a .name, but a Customer is not an Employee, so in this case, you shouldn\u2019t use inheritance.\n\nImplement an interface to be reused: When you want your class to be reused by a specific part of your application, you implement the required interface in your class, but you don\u2019t need to provide a base class, or inherit from another class.\n\nYou can now clean up the example above to move on to the next topic. You can delete the disgruntled.py file and then modify the hr module to its original state:\n\nPython\nhr.py\nclass PayrollSystem:\n    def calculate_payroll(self, employees):\n        print(\"Calculating Payroll\")\n        print(\"===================\")\n        for employee in employees:\n            print(f\"Payroll for: {employee.id} - {employee.name}\")\n            print(f\"- Check amount: {employee.calculate_payroll()}\")\n            print(\"\")\n\nclass Employee:\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n\nclass SalaryEmployee(Employee):\n    def __init__(self, id, name, weekly_salary):\n        super().__init__(id, name)\n        self.weekly_salary = weekly_salary\n\n    def calculate_payroll(self):\n        return self.weekly_salary\n\nclass HourlyEmployee(Employee):\n    def __init__(self, id, name, hours_worked, hourly_rate):\n        super().__init__(id, name)\n        self.hours_worked = hours_worked\n        self.hourly_rate = hourly_rate\n\n    def calculate_payroll(self):\n        return self.hours_worked * self.hourly_rate\n\nclass CommissionEmployee(SalaryEmployee):\n    def __init__(self, id, name, weekly_salary, commission):\n        super().__init__(id, name, weekly_salary)\n        self.commission = commission\n\n    def calculate_payroll(self):\n        fixed = super().calculate_payroll()\n        return fixed + self.commission\n\n\nYou removed the import of the abc module since the Employee class doesn\u2019t need to be abstract. You also removed the abstract .calculate_payroll() method from it since it doesn\u2019t provide any implementation.\n\nBasically, you\u2019re inheriting the implementation of the .id and .name attributes of the Employee class in your derived classes. Since .calculate_payroll() is just an interface to the PayrollSystem.calculate_payroll() method, you don\u2019t need to implement it in the Employee base class.\n\nNotice how the CommissionEmployee class derives from SalaryEmployee. This means that CommissionEmployee inherits the implementation and interface of SalaryEmployee. You can see how the CommissionEmployee.calculate_payroll() method leverages the base class implementation because it relies on the result from super().calculate_payroll() to implement its own version.\n\nRemove ads\nThe Class Explosion Problem\n\nIf you\u2019re not careful, inheritance can lead you to a huge hierarchical class structure that\u2019s hard to understand and maintain. This is known as the class explosion problem.\n\nYou started building a class hierarchy of Employee types used by the PayrollSystem to calculate payroll. Now, you need to add some functionality to those classes so that you can use them with the new ProductivitySystem.\n\nProductivitySystem tracks productivity based on employee roles. There are different employee roles:\n\nManagers: They walk around yelling at people, telling them what to do. They\u2019re salaried employees and make more money.\nSecretaries: They do all the paperwork for managers and ensure that everything gets billed and payed on time. They\u2019re also salaried employees but make less money.\nSales employees: They make a lot of phone calls to sell products. They have a salary, but they also get commissions for sales.\nFactory workers: They manufacture the products for the company. They\u2019re paid by the hour.\n\nWith those requirements, you start to see that Employee and its derived classes might belong somewhere other than the hr module because now they\u2019re also used by the ProductivitySystem.\n\nYou create an employees module and move the classes there:\n\nPython\nemployees.py\nclass Employee:\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n\nclass SalaryEmployee(Employee):\n    def __init__(self, id, name, weekly_salary):\n        super().__init__(id, name)\n        self.weekly_salary = weekly_salary\n\n    def calculate_payroll(self):\n        return self.weekly_salary\n\nclass HourlyEmployee(Employee):\n    def __init__(self, id, name, hours_worked, hourly_rate):\n        super().__init__(id, name)\n        self.hours_worked = hours_worked\n        self.hourly_rate = hourly_rate\n\n    def calculate_payroll(self):\n        return self.hours_worked * self.hourly_rate\n\nclass CommissionEmployee(SalaryEmployee):\n    def __init__(self, id, name, weekly_salary, commission):\n        super().__init__(id, name, weekly_salary)\n        self.commission = commission\n\n    def calculate_payroll(self):\n        fixed = super().calculate_payroll()\n        return fixed + self.commission\n\n\nThe implementation remains the same, but you move the classes to the employees module. Your hr module is now much smaller and focused on the payroll system:\n\nPython\nhr.py\nclass PayrollSystem:\n    def calculate_payroll(self, employees):\n        print(\"Calculating Payroll\")\n        print(\"===================\")\n        for employee in employees:\n            print(f\"Payroll for: {employee.id} - {employee.name}\")\n            print(f\"- Check amount: {employee.calculate_payroll()}\")\n            print(\"\")\n\n\nWith both hr.py and employees.py in place, you can now update your program to support the change:\n\nPython\nprogram.py\nimport hr\nimport employees\n\nsalary_employee = employees.SalaryEmployee(1, \"John Smith\", 1500)\nhourly_employee = employees.HourlyEmployee(2, \"Jane Doe\", 40, 15)\ncommission_employee = employees.CommissionEmployee(3, \"Kevin Bacon\", 1000, 250)\n\npayroll_system = hr.PayrollSystem()\npayroll_system.calculate_payroll(\n    [salary_employee, hourly_employee, commission_employee]\n)\n\n\nYou run the program and verify that it still works:\n\nShell\n$ python program.py\n\nCalculating Payroll\n===================\nPayroll for: 1 - John Smith\n- Check amount: 1500\n\nPayroll for: 2 - Jane Doe\n- Check amount: 600\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1250\n\n\nWith everything in place, you start adding the new classes:\n\nPython\nemployees.py\n# ...\n\nclass Manager(SalaryEmployee):\n    def work(self, hours):\n        print(f\"{self.name} screams and yells for {hours} hours.\")\n\nclass Secretary(SalaryEmployee):\n    def work(self, hours):\n        print(f\"{self.name} expends {hours} hours doing office paperwork.\")\n\nclass SalesPerson(CommissionEmployee):\n    def work(self, hours):\n        print(f\"{self.name} expends {hours} hours on the phone.\")\n\nclass FactoryWorker(HourlyEmployee):\n    def work(self, hours):\n        print(f\"{self.name} manufactures gadgets for {hours} hours.\")\n\n\nFirst, you add a Manager class that derives from SalaryEmployee. The class exposes a .work() method that the productivity system will use. The method takes the hours that the employee worked.\n\nThen you add Secretary, SalesPerson, and FactoryWorker and then implement the .work() interface, so they can be used by the productivity system\u2014which you haven\u2019t created yet.\n\nAs a next step, you can create a new file called productivity.py and add the ProductivitySytem class:\n\nPython\nproductivity.py\nclass ProductivitySystem:\n    def track(self, employees, hours):\n        print(\"Tracking Employee Productivity\")\n        print(\"==============================\")\n        for employee in employees:\n            employee.work(hours)\n        print(\"\")\n\n\nThe class tracks employees in the .track() method that takes a list of employees and the number of hours to track. As outlined above, the productivity system makes use of .work() on each of the objects in employees to accomplish the tracking.\n\nYou can now add the productivity system to your program, and update it to represent different types of employees:\n\nPython\nprogram.py\nimport hr\nimport employees\nimport productivity\n\nmanager = employees.Manager(1, \"Mary Poppins\", 3000)\nsecretary = employees.Secretary(2, \"John Smith\", 1500)\nsales_guy = employees.SalesPerson(3, \"Kevin Bacon\", 1000, 250)\nfactory_worker = employees.FactoryWorker(4, \"Jane Doe\", 40, 15)\nemployees = [\n    manager,\n    secretary,\n    sales_guy,\n    factory_worker,\n]\n\nproductivity_system = productivity.ProductivitySystem()\nproductivity_system.track(employees, 40)\n\npayroll_system = hr.PayrollSystem()\npayroll_system.calculate_payroll(employees)\n\n\nYour updated program creates a list of employees of different types. The employee list is sent to the productivity system to track their work for forty hours. Then the same list of employees is sent to the payroll system to calculate their payroll.\n\nYou can run the program to see the output:\n\nShell\n$ python program.py\n\nTracking Employee Productivity\n==============================\nMary Poppins screams and yells for 40 hours.\nJohn Smith expends 40 hours doing office paperwork.\nKevin Bacon expends 40 hours on the phone.\nJane Doe manufactures gadgets for 40 hours.\n\nCalculating Payroll\n===================\nPayroll for: 1 - Mary Poppins\n- Check amount: 3000\n\nPayroll for: 2 - John Smith\n- Check amount: 1500\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1250\n\nPayroll for: 4 - Jane Doe\n- Check amount: 600\n\n\nThe program shows the employees working for forty hours through the productivity system. Then it calculates and displays the payroll for each of the employees.\n\nThe program works as expected, but you had to add four new classes to support the changes. As new requirements come, your class hierarchy will inevitably grow, leading to the class explosion problem where your hierarchies will become so big that they\u2019ll be hard to understand and maintain.\n\nThe following diagram shows the new class hierarchy:\n\nThe diagram shows how the class hierarchy is growing. Additional requirements might have an exponential effect on the number of classes with this design.\n\nRemove ads\nInheriting Multiple Classes\n\nPython is one of the few modern programming languages that supports multiple inheritance. Multiple inheritance is the ability to derive a class from multiple base classes at the same time.\n\nMultiple inheritance has a bad reputation to the extent that most modern programming languages don\u2019t support it. Instead, modern programming languages support the concept of interfaces. In those languages, you inherit from a single base class and then implement multiple interfaces, so you can reuse your classes in different situations.\n\nThis approach puts some constraints in your designs. You can only inherit the implementation of one class by directly deriving from it. You can implement multiple interfaces, but you can\u2019t inherit the implementation of multiple classes.\n\nThis constraint is good for software design because it forces you to design your classes with fewer dependencies on each other. You will see later in this tutorial that you can leverage multiple implementations through composition, which makes software more flexible. This section, however, is about multiple inheritance, so take a look at how it works.\n\nIt turns out that sometimes temporary secretaries are hired when there\u2019s too much paperwork to do. The TemporarySecretary class performs the role of a Secretary in the context of the ProductivitySystem, but for payroll purposes, it\u2019s an HourlyEmployee.\n\nYou look at your class design. It\u2019s grown a little bit, but you can still understand how it works. It seems you have two options:\n\nDerive from Secretary: You can derive from Secretary to inherit the .work() method for the role, and then override the .calculate_payroll() method to implement it as an HourlyEmployee.\n\nDerive from HourlyEmployee: You can derive from HourlyEmployee to inherit the .calculate_payroll() method, and then override the .work() method to implement it as a Secretary.\n\nThen, you remember that Python supports multiple inheritance, so you decide to derive from both Secretary and HourlyEmployee:\n\nPython\nemployees.py\n# ...\n\nclass TemporarySecretary(Secretary, HourlyEmployee):\n    pass\n\n\nPython allows you to inherit from two different classes by specifying them between parentheses in the class declaration, and separating them with commas.\n\nNow, you modify your program to add the new temporary secretary employee:\n\nPython\nprogram.py\nimport hr\nimport employees\nimport productivity\n\nmanager = employees.Manager(1, \"Mary Poppins\", 3000)\nsecretary = employees.Secretary(2, \"John Smith\", 1500)\nsales_guy = employees.SalesPerson(3, \"Kevin Bacon\", 1000, 250)\nfactory_worker = employees.FactoryWorker(4, \"Jane Doe\", 40, 15)\ntemporary_secretary = employees.TemporarySecretary(5, \"Robin Williams\", 40, 9)\ncompany_employees = [\n    manager,\n    secretary,\n    sales_guy,\n    factory_worker,\n    temporary_secretary,\n]\n\nproductivity_system = productivity.ProductivitySystem()\nproductivity_system.track(company_employees, 40)\n\npayroll_system = hr.PayrollSystem()\npayroll_system.calculate_payroll(company_employees)\n\n\nYou run the program to test it:\n\nShell\n$ python program.py\n\nTraceback (most recent call last):\n  File \"/Users/martin/program.py\", line 9, in <module>\n    temporary_secretary = employees.TemporarySecretary(5, \"Robin Williams\", 40, 9)\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: SalaryEmployee.__init__() takes 4 positional arguments but 5 were given\n\n\nYou get a TypeError exception saying that 4 positional arguments where expected, but 5 were given.\n\nThis is because you derived TemporarySecretary first from Secretary and then from HourlyEmployee, so the interpreter is trying to use Secretary.__init__() to initialize the object.\n\nOkay, go ahead and reverse it:\n\nPython\n# ...\n\nclass TemporarySecretary(HourlyEmployee, Secretary):\n    pass\n\n\nNow, run the program again and see what happens:\n\nShell\n$ python program.py\n\nTraceback (most recent call last):\n  File \"/Users/martin/program.py\", line 9, in <module>\n    temporary_secretary = employees.TemporarySecretary(5, \"Robin Williams\", 40, 9)\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/martin/employees.py\", line 18, in __init__\n    super().__init__(id, name)\nTypeError: SalaryEmployee.__init__() missing 1 required positional argument: 'weekly_salary'\n\n\nNow it seems that you\u2019re missing a weekly_salary parameter, which is necessary to initialize Secretary, but that parameter doesn\u2019t make sense in the context of a TemporarySecretary because it\u2019s an HourlyEmployee.\n\nMaybe implementing TemporarySecretary.__init__() will help:\n\nPython\nemployees.py\n# ...\n\nclass TemporarySecretary(HourlyEmployee, Secretary):\n    def __init__(self, id, name, hours_worked, hourly_rate):\n        super().__init__(id, name, hours_worked, hourly_rate)\n\n\nTry it:\n\nShell\n$ python program.py\n\nTraceback (most recent call last):\n  File \"/Users/martin/program.py\", line 9, in <module>\n    temporary_secretary = employees.TemporarySecretary(5, \"Robin Williams\", 40, 9)\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/martin/employees.py\", line 58, in __init__\n    super().__init__(id, name, hours_worked, hourly_rate)\n  File \"/Users/martin/employees.py\", line 18, in __init__\n    super().__init__(id, name)\nTypeError: SalaryEmployee.__init__() missing 1 required positional argument: 'weekly_salary'\n\n\nThat didn\u2019t work either. Okay, it\u2019s time for you to dive into Python\u2019s method resolution order (MRO) to see what\u2019s going on.\n\nWhen a method or attribute of a class is accessed, Python uses the class MRO to find it. The MRO is also used by super() to determine which method or attribute to invoke. You can learn more about super() in Supercharge Your Classes With Python super().\n\nYou can evaluate the TemporarySecretary class MRO using the interactive interpreter:\n\nPython\n>>> from employees import TemporarySecretary\n>>> TemporarySecretary.__mro__\n(<class 'employees.TemporarySecretary'>,\n <class 'employees.HourlyEmployee'>,\n <class 'employees.Secretary'>,\n <class 'employees.SalaryEmployee'>,\n <class 'employees.Employee'>,\n <class 'object'>)\n\n\nThe MRO shows the order in which Python is going to look for a matching attribute or method. In the example, this is what happens when you create the TemporarySecretary object:\n\nThe TemporarySecretary.__init__(self, id, name, hours_worked, hourly_rate) method is called.\n\nThe super().__init__(id, name, hours_worked, hourly_rate) call matches HourlyEmployee.__init__(self, id, name, hours_worked, hourly_rate).\n\nHourlyEmployee calls super().__init__(id, name), which the MRO is going to match to Secretary.__init__(), which is inherited from SalaryEmployee.__init__(self, id, name, weekly_salary).\n\nBecause the parameters don\u2019t match, Python raises a TypeError exception.\n\nYou can bypass parts of the MRO. In this case, you want to skip the initialization of Secretary and SalaryEmployee. You can do this by reversing the inheritance order again back to how you had it initially. Then, you\u2019ll directly call HourlyEmployee.__init__():\n\nPython\nemployees.py\n# ...\n\nclass TemporarySecretary(Secretary, HourlyEmployee):\n    def __init__(self, id, name, hours_worked, hourly_rate):\n        HourlyEmployee.__init__(self, id, name, hours_worked, hourly_rate)\n\n\nWhen you put Secretary before HourlyEmployee, then the MRO of TemporarySecretary looks like the following:\n\nPython\n>>> from employees import TemporarySecretary\n>>> TemporarySecretary.__mro__\n(<class 'employees.TemporarySecretary'>,\n <class 'employees.Secretary'>,\n <class 'employees.SalaryEmployee'>,\n <class 'employees.HourlyEmployee'>,\n <class 'employees.Employee'>,\n <class 'object'>)\n\n\nBecause you explicitly specified that .__init__() should use HourlyEmployee.__init__(), you\u2019re effectively skipping Secretary and SalaryEmployee in the MRO when initializing an object.\n\nThat solves the problem of creating the object, but you\u2019ll run into a similar problem when trying to calculate payroll. You can run the program to see the problem:\n\nShell\n$ python program.py\n\nTracking Employee Productivity\n==============================\nMary Poppins screams and yells for 40 hours.\nJohn Smith expends 40 hours doing office paperwork.\nKevin Bacon expends 40 hours on the phone.\nJane Doe manufactures gadgets for 40 hours.\nRobin Williams expends 40 hours doing office paperwork.\n\nCalculating Payroll\n===================\nPayroll for: 1 - Mary Poppins\n- Check amount: 3000\n\nPayroll for: 2 - John Smith\n- Check amount: 1500\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1250\n\nPayroll for: 4 - Jane Doe\n- Check amount: 600\n\nPayroll for: 5 - Robin Williams\nTraceback (most recent call last):\n  File \"/Users/martin/program.py\", line 22, in <module>\n    payroll_system.calculate_payroll(company_employees)\n  File \"/Users/martin/hr.py\", line 7, in calculate_payroll\n    print(f\"- Check amount: {employee.calculate_payroll()}\")\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/martin/employees.py\", line 13, in calculate_payroll\n    return self.weekly_salary\n           ^^^^^^^^^^^^^^^^^^\nAttributeError: 'TemporarySecretary' object has no attribute 'weekly_salary'\n\n\nThe problem now is that because you reversed the inheritance order, the MRO is finding the .calculate_payroll() method of SalariedEmployee before the one in HourlyEmployee. You need to override .calculate_payroll() in TemporarySecretary and invoke the right implementation from it:\n\nPython\n# ...\n\nclass TemporarySecretary(Secretary, HourlyEmployee):\n    def __init__(self, id, name, hours_worked, hourly_rate):\n        HourlyEmployee.__init__(self, id, name, hours_worked, hourly_rate)\n\n    def calculate_payroll(self):\n        return HourlyEmployee.calculate_payroll(self)\n\n\nThe new .calculate_payroll() method now directly invokes HourlyEmployee.calculate_payroll() to ensure that you get the correct result. You can run the program again to see it working:\n\nShell\n$ python program.py\n\nTracking Employee Productivity\n==============================\nMary Poppins screams and yells for 40 hours.\nJohn Smith expends 40 hours doing office paperwork.\nKevin Bacon expends 40 hours on the phone.\nJane Doe manufactures gadgets for 40 hours.\nRobin Williams expends 40 hours doing office paperwork.\n\nCalculating Payroll\n===================\nPayroll for: 1 - Mary Poppins\n- Check amount: 3000\n\nPayroll for: 2 - John Smith\n- Check amount: 1500\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1250\n\nPayroll for: 4 - Jane Doe\n- Check amount: 600\n\nPayroll for: 5 - Robin Williams\n- Check amount: 360\n\n\nThe program now works as expected because you\u2019re forcing the method resolution order by explicitly telling the interpreter which method you want to use.\n\nAs you can see, multiple inheritance can be confusing, especially when you run into the diamond problem.\n\nThe following diagram shows the diamond problem in your class hierarchy:\n\nThe diagram shows the diamond problem with the current class design. TemporarySecretary uses multiple inheritance to derive from two classes that ultimately also derive from Employee. This causes two paths to reach the Employee base class, which is something you want to avoid in your designs.\n\nThe diamond problem appears when you\u2019re using multiple inheritance and deriving from two classes that have a common base class. This can cause the wrong version of a method to be called.\n\nAs you\u2019ve seen, Python provides a way to force the right method to be invoked, and analyzing the MRO can help you understand the problem.\n\nStill, when you run into the diamond problem, it\u2019s better to rethink the design. You\u2019ll now make some changes to leverage multiple inheritance, avoiding the diamond problem.\n\nTwo different systems use the Employee derived classes:\n\nThe productivity system that tracks employee productivity\n\nThe payroll system that calculates the employee payroll\n\nThis means that everything related to productivity should be together in one module, and everything related to payroll should be together in another. You can start making changes to the productivity module:\n\nPython\nproductivity.py\nclass ProductivitySystem:\n    def track(self, employees, hours):\n        print(\"Tracking Employee Productivity\")\n        print(\"==============================\")\n        for employee in employees:\n            result = employee.work(hours)\n            print(f\"{employee.name}: {result}\")\n        print(\"\")\n\nclass ManagerRole:\n    def work(self, hours):\n        return f\"screams and yells for {hours} hours.\"\n\nclass SecretaryRole:\n    def work(self, hours):\n        return f\"expends {hours} hours doing office paperwork.\"\n\nclass SalesRole:\n    def work(self, hours):\n        return f\"expends {hours} hours on the phone.\"\n\nclass FactoryRole:\n    def work(self, hours):\n        return f\"manufactures gadgets for {hours} hours.\"\n\n\nThe productivity module implements the ProductivitySystem class, as well as the related roles that it supports. The classes implement the .work() interface required by the system, but they don\u2019t derive from Employee.\n\nYou can do the same with the hr module:\n\nPython\nhr.py\nclass PayrollSystem:\n    def calculate_payroll(self, employees):\n        print(\"Calculating Payroll\")\n        print(\"===================\")\n        for employee in employees:\n            print(f\"Payroll for: {employee.id} - {employee.name}\")\n            print(f\"- Check amount: {employee.calculate_payroll()}\")\n            print(\"\")\n\nclass SalaryPolicy:\n    def __init__(self, weekly_salary):\n        self.weekly_salary = weekly_salary\n\n    def calculate_payroll(self):\n        return self.weekly_salary\n\nclass HourlyPolicy:\n    def __init__(self, hours_worked, hourly_rate):\n        self.hours_worked = hours_worked\n        self.hourly_rate = hourly_rate\n\n    def calculate_payroll(self):\n        return self.hours_worked * self.hourly_rate\n\nclass CommissionPolicy(SalaryPolicy):\n    def __init__(self, weekly_salary, commission):\n        super().__init__(weekly_salary)\n        self.commission = commission\n\n    def calculate_payroll(self):\n        fixed = super().calculate_payroll()\n        return fixed + self.commission\n\n\nThe hr module implements the PayrollSystem, which calculates payroll for the employees. It also implements the policy classes for payroll. As you can see, the policy classes don\u2019t derive from Employee anymore.\n\nYou can now add the necessary classes to the employee module:\n\nPython\nemployees.py\nfrom hr import SalaryPolicy, CommissionPolicy, HourlyPolicy\nfrom productivity import ManagerRole, SecretaryRole, SalesRole, FactoryRole\n\nclass Employee:\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n\nclass Manager(Employee, ManagerRole, SalaryPolicy):\n    def __init__(self, id, name, weekly_salary):\n        SalaryPolicy.__init__(self, weekly_salary)\n        super().__init__(id, name)\n\nclass Secretary(Employee, SecretaryRole, SalaryPolicy):\n    def __init__(self, id, name, weekly_salary):\n        SalaryPolicy.__init__(self, weekly_salary)\n        super().__init__(id, name)\n\nclass SalesPerson(Employee, SalesRole, CommissionPolicy):\n    def __init__(self, id, name, weekly_salary, commission):\n        CommissionPolicy.__init__(self, weekly_salary, commission)\n        super().__init__(id, name)\n\nclass FactoryWorker(Employee, FactoryRole, HourlyPolicy):\n    def __init__(self, id, name, hours_worked, hourly_rate):\n        HourlyPolicy.__init__(self, hours_worked, hourly_rate)\n        super().__init__(id, name)\n\nclass TemporarySecretary(Employee, SecretaryRole, HourlyPolicy):\n    def __init__(self, id, name, hours_worked, hourly_rate):\n        HourlyPolicy.__init__(self, hours_worked, hourly_rate)\n        super().__init__(id, name)\n\n\nThe employees module imports policies and roles from the other modules and implements the different Employee types. You\u2019re still using multiple inheritance to inherit the implementation of the salary policy classes and the productivity roles, but the implementation of each class only needs to deal with initialization.\n\nNotice that you still need to explicitly initialize the salary policies in the constructors. You probably saw that the initializations of Manager and Secretary are identical. Also, the initializations of FactoryWorker and TemporarySecretary are the same.\n\nYou won\u2019t want to have this kind of code duplication in more complex designs, so you have to be careful when designing class hierarchies.\n\nHere\u2019s the UML diagram for the new design:\n\nThe diagram shows the relationships to define the Secretary and TemporarySecretary using multiple inheritance, but avoiding the diamond problem.\n\nYou can run the program and see how it works:\n\nShell\n$ python program.py\n\nTracking Employee Productivity\n==============================\nMary Poppins: screams and yells for 40 hours.\nJohn Smith: expends 40 hours doing office paperwork.\nKevin Bacon: expends 40 hours on the phone.\nJane Doe: manufactures gadgets for 40 hours.\nRobin Williams: expends 40 hours doing office paperwork.\n\nCalculating Payroll\n===================\nPayroll for: 1 - Mary Poppins\n- Check amount: 3000\n\nPayroll for: 2 - John Smith\n- Check amount: 1500\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1250\n\nPayroll for: 4 - Jane Doe\n- Check amount: 600\n\nPayroll for: 5 - Robin Williams\n- Check amount: 360\n\n\nYou\u2019ve seen how inheritance and multiple inheritance work in Python. You can now explore the topic of composition.\n\nRemove ads\nComposition in Python\n\nComposition is an object-oriented design concept that models a has a relationship. In composition, a class known as composite contains an object, or component, of another class. In other words, a composite class has a component of another class.\n\nComposition allows composite classes to reuse the implementation of the components it contains. The composite class doesn\u2019t inherit the component class interface, but it can leverage its implementation.\n\nThe composition relation between two classes is considered loosely coupled. That means that changes to the component class rarely affect the composite class, and changes to the composite class never affect the component class.\n\nThis provides better adaptability to change and allows applications to introduce new requirements without affecting existing code.\n\nWhen looking at two competing software designs, one based on inheritance and another based on composition, the composition solution usually is more flexible. You can now look at how composition works.\n\nYou\u2019ve already used composition in your examples. If you look at the Employee class, then you\u2019ll see that it contains two attributes:\n\n.id to identify an employee\n.name to contain the name of the employee\n\nThese two attributes are objects that the Employee class has. Therefore, you can say that an Employee has an .id and has a .name.\n\nAnother attribute for an Employee might be an Address. Create a new Python file called contacts.py and add code for an Address class:\n\nPython\ncontacts.py\nclass Address:\n    def __init__(self, street, city, state, zipcode, street2=\"\"):\n        self.street = street\n        self.street2 = street2\n        self.city = city\n        self.state = state\n        self.zipcode = zipcode\n\n    def __str__(self):\n        lines = [self.street]\n        if self.street2:\n            lines.append(self.street2)\n        lines.append(f\"{self.city}, {self.state} {self.zipcode}\")\n        return \"\\n\".join(lines)\n\n\nYou implemented a basic address class that contains the usual components for an address. You made the street2 attribute optional because not all addresses will have that component.\n\nYou implemented .__str__() to provide a pretty representation of an Address. You can see this implementation in the interactive interpreter:\n\nPython\n>>> from contacts import Address\n>>> address = Address(\"55 Main St.\", \"Concord\", \"NH\", \"03301\")\n>>> print(address)\n55 Main St.\nConcord, NH 03301\n\n\nWhen you print() the address variable, you\u2019re invoking the special method .__str__(). Since you overloaded the method to return a string formatted as an address, you get a nice, readable representation. Operator and Function Overloading in Custom Python Classes gives a good overview of the special methods available in classes that you can implement to customize the behavior of your objects.\n\nYou can now add Address to the Employee class through composition:\n\nPython\nemployees.py\n# ...\n\nclass Employee:\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n        self.address = None\n\n\nYou initialize the .address attribute to None for now to make it optional, but by doing that, you can now assign an Address to an Employee. Also notice that there\u2019s no reference in the employee module to the contacts module.\n\nComposition is a loosely coupled relationship that often doesn\u2019t require the composite class to have knowledge of the component.\n\nThe UML diagram representing the relationship between Employee and Address looks like this:\n\nThe diagram shows the basic composition relationship between Employee and Address.\n\nYou can now modify the PayrollSystem class to leverage the .address attribute in Employee:\n\nPython\nhr.py\nclass PayrollSystem:\n    def calculate_payroll(self, employees):\n        print(\"Calculating Payroll\")\n        print(\"===================\")\n        for employee in employees:\n            print(f\"Payroll for: {employee.id} - {employee.name}\")\n            print(f\"- Check amount: {employee.calculate_payroll()}\")\n            if employee.address:\n                print(\"- Sent to:\")\n                print(employee.address)\n            print(\"\")\n\n\nYou check to see if the employee object has an address, and if it does, you print it. You can now modify the program to assign some addresses to the employees:\n\nPython\nprogram.py\nimport hr\nimport employees\nimport productivity\nimport contacts\n\nmanager = employees.Manager(1, \"Mary Poppins\", 3000)\nmanager.address = contacts.Address(\n    \"121 Admin Rd\", \"Concord\", \"NH\", \"03301\"\n)\nsecretary = employees.Secretary(2, \"John Smith\", 1500)\nsecretary.address = contacts.Address(\n    \"67 Paperwork Ave.\", \"Manchester\", \"NH\", \"03101\"\n)\nsales_guy = employees.SalesPerson(3, \"Kevin Bacon\", 1000, 250)\nfactory_worker = employees.FactoryWorker(4, \"Jane Doe\", 40, 15)\ntemporary_secretary = employees.TemporarySecretary(5, \"Robin Williams\", 40, 9)\nemployees = [\n    manager,\n    secretary,\n    sales_guy,\n    factory_worker,\n    temporary_secretary,\n]\n\nproductivity_system = productivity.ProductivitySystem()\nproductivity_system.track(employees, 40)\n\npayroll_system = hr.PayrollSystem()\npayroll_system.calculate_payroll(employees)\n\n\nYou added a couple of addresses to the manager and secretary objects. When you run the program, you\u2019ll see the addresses printed:\n\nShell\n$ python program.py\n\nTracking Employee Productivity\n==============================\nMary Poppins: screams and yells for 40 hours.\nJohn Smith: expends 40 hours doing office paperwork.\nKevin Bacon: expends 40 hours on the phone.\nJane Doe: manufactures gadgets for 40 hours.\nRobin Williams: expends 40 hours doing office paperwork.\n\nCalculating Payroll\n===================\nPayroll for: 1 - Mary Poppins\n- Check amount: 3000\n- Sent to:\n121 Admin Rd\nConcord, NH 03301\n\nPayroll for: 2 - John Smith\n- Check amount: 1500\n- Sent to:\n67 Paperwork Ave.\nManchester, NH 03101\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1250\n\nPayroll for: 4 - Jane Doe\n- Check amount: 600\n\nPayroll for: 5 - Robin Williams\n- Check amount: 360\n\n\nNotice how the payroll output for the manager and secretary objects shows the addresses where the checks were sent.\n\nThe Employee class leverages the implementation of the Address class without any knowledge of what an Address object is or how it\u2019s represented. This type of design is so flexible that you can change the Address class without any impact to the Employee class.\n\nRemove ads\nFlexible Designs With Composition\n\nComposition is more flexible than inheritance because it models a loosely coupled relationship. Changes to a component class have minimal or no effects on the composite class. Designs based on composition are more suitable to change.\n\nYou change behavior by providing new components that implement those behaviors instead of adding new classes to your hierarchy.\n\nTake a look at the multiple inheritance example above. Imagine how new payroll policies will affect the design. Try to picture what the class hierarchy will look like if new roles are needed. As you saw before, relying too heavily on inheritance can lead to class explosion.\n\nThe biggest problem isn\u2019t so much the number of classes in your design, but how tightly coupled the relationships between those classes are. Tightly coupled classes affect each other when changes are introduced.\n\nIn this section, you\u2019re going to use composition to implement a better design that still fits the requirements of the PayrollSystem and the ProductivitySystem.\n\nYou can start by implementing the functionality of the ProductivitySystem:\n\nPython\nproductivity.py\nclass ProductivitySystem:\n    def __init__(self):\n        self._roles = {\n            \"manager\": ManagerRole,\n            \"secretary\": SecretaryRole,\n            \"sales\": SalesRole,\n            \"factory\": FactoryRole,\n        }\n\n    def get_role(self, role_id):\n        role_type = self._roles.get(role_id)\n        if not role_type:\n            raise ValueError(role_id)\n        return role_type()\n\n    def track(self, employees, hours):\n        print(\"Tracking Employee Productivity\")\n        print(\"==============================\")\n        for employee in employees:\n            employee.work(hours)\n        print(\"\")\n\n\nThe updated ProductivitySystem class defines some roles using a string identifier mapped to a role class that implements the role. It exposes a .get_role() method that, given a role identifier, returns the role type object. If the role isn\u2019t found, then Python raises a ValueError exception.\n\nIt also exposes the previous functionality in the .track() method, where given a list of employees, it tracks the productivity of those employees.\n\nYou can now implement the different role classes:\n\nPython\nproductivity.py\n# ...\n\nclass ManagerRole:\n    def perform_duties(self, hours):\n        return f\"screams and yells for {hours} hours.\"\n\nclass SecretaryRole:\n    def perform_duties(self, hours):\n        return f\"does paperwork for {hours} hours.\"\n\nclass SalesRole:\n    def perform_duties(self, hours):\n        return f\"expends {hours} hours on the phone.\"\n\nclass FactoryRole:\n    def perform_duties(self, hours):\n        return f\"manufactures gadgets for {hours} hours.\"\n\n\nEach of the roles that you implemented exposes its own .perform_duties() method that takes the number of hours worked. These methods return a string representing the duties.\n\nNote: If you\u2019ve followed along throughout the section on inheritance, then you\u2019ll notice that these roles are similar, but slightly different from that example.\n\nFeel free to continue working with the roles that you previously defined and their .work() methods if you prefer. You\u2019ll just need to adapt the relevant names to account for the change.\n\nThe role classes are independent of each other, but they expose the same interface, so they\u2019re interchangeable. You\u2019ll see later how they\u2019re used in the application.\n\nNow, you can implement the PayrollSystem for the application:\n\nPython\nhr.py\nclass PayrollSystem:\n    def __init__(self):\n        self._employee_policies = {\n            1: SalaryPolicy(3000),\n            2: SalaryPolicy(1500),\n            3: CommissionPolicy(1000, 100),\n            4: HourlyPolicy(15),\n            5: HourlyPolicy(9),\n        }\n\n    def get_policy(self, employee_id):\n        policy = self._employee_policies.get(employee_id)\n        if not policy:\n            return ValueError(employee_id)\n        return policy\n\n    def calculate_payroll(self, employees):\n        print(\"Calculating Payroll\")\n        print(\"===================\")\n        for employee in employees:\n            print(f\"Payroll for: {employee.id} - {employee.name}\")\n            print(f\"- Check amount: {employee.calculate_payroll()}\")\n            if employee.address:\n                print(\"- Sent to:\")\n                print(employee.address)\n            print(\"\")\n\n\nPayrollSystem keeps an internal database of payroll policies for each employee. It exposes a .get_policy() method that, given an employee .id, returns its payroll policy. If a specified .id doesn\u2019t exist in the system, then the method raises a ValueError exception.\n\nThe implementation of .calculate_payroll() works the same as before. It takes a list of employees, calculates the payroll, and prints the results.\n\nYou can now implement the payroll policy classes:\n\nPython\nhr.py\n# ...\n\nclass PayrollPolicy:\n    def __init__(self):\n        self.hours_worked = 0\n\n    def track_work(self, hours):\n        self.hours_worked += hours\n\nclass SalaryPolicy(PayrollPolicy):\n    def __init__(self, weekly_salary):\n        super().__init__()\n        self.weekly_salary = weekly_salary\n\n    def calculate_payroll(self):\n        return self.weekly_salary\n\nclass HourlyPolicy(PayrollPolicy):\n    def __init__(self, hourly_rate):\n        super().__init__()\n        self.hourly_rate = hourly_rate\n\n    def calculate_payroll(self):\n        return self.hours_worked * self.hourly_rate\n\nclass CommissionPolicy(SalaryPolicy):\n    def __init__(self, weekly_salary, commission_per_sale):\n        super().__init__(weekly_salary)\n        self.commission_per_sale = commission_per_sale\n\n    @property\n    def commission(self):\n        sales = self.hours_worked / 5\n        return sales * self.commission_per_sale\n\n    def calculate_payroll(self):\n        fixed = super().calculate_payroll()\n        return fixed + self.commission\n\n\nYou first implement a PayrollPolicy class that serves as a base class for all the payroll policies. This class tracks the hours_worked, which is common to all payroll policies.\n\nThe other policy classes derive from PayrollPolicy. You use inheritance here because you want to leverage the implementation of PayrollPolicy. Also, SalaryPolicy, HourlyPolicy, and CommissionPolicy are a PayrollPolicy.\n\nSalaryPolicy is initialized with a weekly_salary value that .calculate_payroll() then uses. HourlyPolicy is initialized with hourly_rate and implements .calculate_payroll() by leveraging the base class hours_worked.\n\nThe CommissionPolicy class derives from SalaryPolicy because it wants to inherit its implementation. It\u2019s initialized with the weekly_salary parameters, but it also requires a commission_per_sale parameter.\n\nThe .commission_per_sale is used to calculate the .commission, which is implemented as a property so it gets calculated when requested. In the example, you\u2019re assuming that a sale happens every five hours worked, and the .commission is the number of sales times the .commission_per_sale value.\n\nCommissionPolicy implements the .calculate_payroll() method by first leveraging the implementation in SalaryPolicy and then adding the calculated commission.\n\nYou can now add an AddressBook class to manage employee addresses:\n\nPython\ncontacts.py\n# ...\n\nclass AddressBook:\n    def __init__(self):\n        self._employee_addresses = {\n            1: Address(\"121 Admin Rd.\", \"Concord\", \"NH\", \"03301\"),\n            2: Address(\"67 Paperwork Ave\", \"Manchester\", \"NH\", \"03101\"),\n            3: Address(\"15 Rose St\", \"Concord\", \"NH\", \"03301\", \"Apt. B-1\"),\n            4: Address(\"39 Sole St.\", \"Concord\", \"NH\", \"03301\"),\n            5: Address(\"99 Mountain Rd.\", \"Concord\", \"NH\", \"03301\"),\n        }\n\n    def get_employee_address(self, employee_id):\n        address = self._employee_addresses.get(employee_id)\n        if not address:\n            raise ValueError(employee_id)\n        return address\n\n\nThe AddressBook class keeps an internal database of Address objects for each employee. It exposes a .get_employee_address() method that returns the address of the specified employee .id. If the employee .id doesn\u2019t exist, then it raises a ValueError.\n\nThe Address class implementation remains the same as before:\n\nPython\ncontacts.py\nclass Address:\n    def __init__(self, street, city, state, zipcode, street2=\"\"):\n        self.street = street\n        self.street2 = street2\n        self.city = city\n        self.state = state\n        self.zipcode = zipcode\n\n    def __str__(self):\n        lines = [self.street]\n        if self.street2:\n            lines.append(self.street2)\n        lines.append(f\"{self.city}, {self.state} {self.zipcode}\")\n        return \"\\n\".join(lines)\n\n\nThe class manages the address components and provides a pretty representation of an address.\n\nSo far, the new classes have been extended to support more functionality, but there are no significant changes to the previous design. This is going to change with the design of the employees module and its classes.\n\nYou can start by implementing an EmployeeDatabase class:\n\nPython\nemployees.py\nfrom productivity import ProductivitySystem\nfrom hr import PayrollSystem\nfrom contacts import AddressBook\n\nclass EmployeeDatabase:\n    def __init__(self):\n        self._employees = [\n            {\"id\": 1, \"name\": \"Mary Poppins\", \"role\": \"manager\"},\n            {\"id\": 2, \"name\": \"John Smith\", \"role\": \"secretary\"},\n            {\"id\": 3, \"name\": \"Kevin Bacon\", \"role\": \"sales\"},\n            {\"id\": 4, \"name\": \"Jane Doe\", \"role\": \"factory\"},\n            {\"id\": 5, \"name\": \"Robin Williams\", \"role\": \"secretary\"},\n        ]\n        self.productivity = ProductivitySystem()\n        self.payroll = PayrollSystem()\n        self.employee_addresses = AddressBook()\n\n    @property\n    def employees(self):\n        return [self._create_employee(**data) for data in self._employees]\n\n    def _create_employee(self, id, name, role):\n        address = self.employee_addresses.get_employee_address(id)\n        employee_role = self.productivity.get_role(role)\n        payroll_policy = self.payroll.get_policy(id)\n        return Employee(id, name, address, employee_role, payroll_policy)\n\n\nEmployeeDatabase keeps track of all the employees in the company. For each employee, it tracks the .id, .name, and .role. It has an instance of the ProductivitySystem, the PayrollSystem, and the AddressBook. These instances are used to create employees.\n\nIt exposes an .employees property that returns the list of employees. The Employee objects are created in an internal ._create_employee() method. Notice that you don\u2019t have different types of Employee classes. You just need to implement a single Employee class:\n\nPython\nemployees.py\n# ...\n\nclass Employee:\n    def __init__(self, id, name, address, role, payroll):\n        self.id = id\n        self.name = name\n        self.address = address\n        self.role = role\n        self.payroll = payroll\n\n    def work(self, hours):\n        duties = self.role.perform_duties(hours)\n        print(f\"Employee {self.id} - {self.name}:\")\n        print(f\"- {duties}\")\n        print(\"\")\n        self.payroll.track_work(hours)\n\n    def calculate_payroll(self):\n        return self.payroll.calculate_payroll()\n\n\nYou initialize the Employee class with the .id, .name, and .address attributes. This class also requires the productivity .role for the employee and the .payroll policy.\n\nThe class exposes a .work() method that takes the hours worked. This method first retrieves the duties from the .role. In other words, it delegates to the .role object to perform its duties.\n\nIn the same way, it delegates to the .payroll object to track the work hours. The .payroll, as you saw, uses those hours to calculate the payroll if needed.\n\nThe following diagram shows the composition design used:\n\nThe diagram shows the design of composition-based policies. There\u2019s a single Employee that\u2019s composed of other data objects like Address and depends on the IRole and IPayrollCalculator interfaces to delegate the work. There are multiple implementations of these interfaces.\n\nYou can now use this design in your program:\n\nPython\nprogram.py\nfrom hr import PayrollSystem\nfrom productivity import ProductivitySystem\nfrom employees import EmployeeDatabase\n\nproductivity_system = ProductivitySystem()\npayroll_system = PayrollSystem()\nemployee_database = EmployeeDatabase()\n\nemployees = employee_database.employees\nproductivity_system.track(employees, 40)\npayroll_system.calculate_payroll(employees)\n\n\nYou can run the program to see its output:\n\nShell\n$ python program.py\n\nTracking Employee Productivity\n==============================\nEmployee 1 - Mary Poppins:\n- screams and yells for 40 hours.\n\nEmployee 2 - John Smith:\n- does paperwork for 40 hours.\n\nEmployee 3 - Kevin Bacon:\n- expends 40 hours on the phone.\n\nEmployee 4 - Jane Doe:\n- manufactures gadgets for 40 hours.\n\nEmployee 5 - Robin Williams:\n- does paperwork for 40 hours.\n\n\nCalculating Payroll\n===================\nPayroll for: 1 - Mary Poppins\n- Check amount: 3000\n- Sent to:\n121 Admin Rd.\nConcord, NH 03301\n\nPayroll for: 2 - John Smith\n- Check amount: 1500\n- Sent to:\n67 Paperwork Ave\nManchester, NH 03101\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1800.0\n- Sent to:\n15 Rose St\nApt. B-1\nConcord, NH 03301\n\nPayroll for: 4 - Jane Doe\n- Check amount: 600\n- Sent to:\n39 Sole St.\nConcord, NH 03301\n\nPayroll for: 5 - Robin Williams\n- Check amount: 360\n- Sent to:\n99 Mountain Rd.\nConcord, NH 03301\n\n\nThis design is what\u2019s called policy-based design, where classes are composed of policies, and they delegate to those policies to do the work.\n\nPolicy-based design was introduced in the book Modern C++ Design, and it uses template metaprogramming in C++ to achieve the results.\n\nPython doesn\u2019t support templates, but you can achieve similar results using composition, as you saw in the example above.\n\nThis type of design gives you all the flexibility you\u2019ll need as requirements change. Imagine that you need to change the way payroll is calculated for an object at runtime.\n\nRemove ads\nCustomizing Behavior With Composition\n\nIf your design relies on inheritance, then you need to find a way to change the type of an object to change its behavior. With composition, you just need to change the policy that the object uses.\n\nImagine that your manager all of a sudden becomes a temporary employee who gets paid by the hour. You can modify the object during the execution of the program in the following way:\n\nPython\nprogram.py\nfrom hr import PayrollSystem, HourlyPolicy\nfrom productivity import ProductivitySystem\nfrom employees import EmployeeDatabase\n\nproductivity_system = ProductivitySystem()\npayroll_system = PayrollSystem()\nemployee_database = EmployeeDatabase()\n\nemployees = employee_database.employees\nmanager = employees[0]\nmanager.payroll = HourlyPolicy(55)\n\nproductivity_system.track(employees, 40)\npayroll_system.calculate_payroll(employees)\n\n\nThe program gets the employee list from the EmployeeDatabase and retrieves the first employee, which is the manager you want. Then it creates a new HourlyPolicy initialized at 55 dollars per hour and assigns it to the manager object.\n\nThe new policy is now used by the PayrollSystem, modifying the existing behavior. You can run the program again to see the result:\n\nShell\n$ python program.py\n\nTracking Employee Productivity\n==============================\nEmployee 1 - Mary Poppins:\n- screams and yells for 40 hours.\n\nEmployee 2 - John Smith:\n- does paperwork for 40 hours.\n\nEmployee 3 - Kevin Bacon:\n- expends 40 hours on the phone.\n\nEmployee 4 - Jane Doe:\n- manufactures gadgets for 40 hours.\n\nEmployee 5 - Robin Williams:\n- does paperwork for 40 hours.\n\n\nCalculating Payroll\n===================\nPayroll for: 1 - Mary Poppins\n- Check amount: 2200\n- Sent to:\n121 Admin Rd.\nConcord, NH 03301\n\nPayroll for: 2 - John Smith\n- Check amount: 1500\n- Sent to:\n67 Paperwork Ave\nManchester, NH 03101\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1800.0\n- Sent to:\n15 Rose St\nApt. B-1\nConcord, NH 03301\n\nPayroll for: 4 - Jane Doe\n- Check amount: 600\n- Sent to:\n39 Sole St.\nConcord, NH 03301\n\nPayroll for: 5 - Robin Williams\n- Check amount: 360\n- Sent to:\n99 Mountain Rd.\nConcord, NH 03301\n\n\nThe check for Mary Poppins, your manager, is now for 2200 dollars instead of the fixed weekly salary of 3000 dollars that she used to have.\n\nNotice how you added that business rule to the program without changing any of the existing classes. Consider what type of changes would\u2019ve been required with an inheritance design.\n\nYou would\u2019ve had to create a new class and change the type of the manager employee. There\u2019s no chance that you could\u2019ve changed the policy at runtime.\n\nChoosing Between Inheritance and Composition in Python\n\nSo far, you\u2019ve seen how inheritance and composition work in Python. You\u2019ve seen that derived classes inherit the interface and implementation of their base classes. You\u2019ve also seen that composition allows you to reuse the implementation of another class.\n\nYou\u2019ve implemented two solutions to the same problem. The first solution used multiple inheritance, and the second one used composition.\n\nYou\u2019ve also seen that Python\u2019s duck typing allows you to reuse objects with existing parts of a program by implementing the desired interface. In Python, it isn\u2019t necessary to derive from a base class to reuse your classes.\n\nAt this point, you might be asking when to use inheritance vs composition in Python. They both enable code reuse. Inheritance and composition can tackle similar problems in your Python programs.\n\nThe general advice is to use the relationship that creates fewer dependencies between two classes. This relation is composition. Still, there\u2019ll be times where inheritance will make more sense.\n\nThe following sections provide some guidelines to help you make the right choice between inheritance and composition in Python.\n\nInheritance to Model \u201cIs A\u201d Relationship\n\nYou should only use inheritance to model an is a relationship. Liskov\u2019s substitution principle says that an object of type Derived, which inherits from Base, can replace an object of type Base without altering the desirable properties of a program.\n\nLiskov\u2019s substitution principle is the most important guideline to determine if inheritance is the appropriate design solution. Still, the answer might not be straightforward in all situations. Fortunately, there\u2019s a simple test that you can use to determine if your design follows Liskov\u2019s substitution principle.\n\nLet\u2019s say you have a class, A, that provides an implementation and interface you want to reuse in another class, B. Your initial thought is that you can derive B from A and inherit both the interface and the implementation. To be sure this is the right design, you follow theses steps:\n\nEvaluate B is an A: Think about this relationship and justify it. Does it make sense?\n\nEvaluate A is a B: Reverse the relationship and justify it. Does it also make sense?\n\nIf you can justify both relationships, then you should never inherit those classes from one another. Look at a more concrete example.\n\nYou have a Rectangle class that exposes an .area property. You need a Square class, which also has an .area. It seems that a Square is a special type of Rectangle, so maybe you can derive from it and leverage both the interface and implementation.\n\nBefore you jump into the implementation, you use Liskov\u2019s substitution principle to evaluate the relationship.\n\nA Square is a Rectangle because its area is calculated from the product of its .height times its .length. The constraint is that Square.height and Square.length must be equal.\n\nIt makes sense. You can justify the relationship and explain why a Square is a Rectangle. Now reverse the relationship to see if it makes sense.\n\nA Rectangle is a Square because its area is calculated from the product of its .height times its .length. The difference is that Rectangle.height and Rectangle.width can change independently.\n\nIt also makes sense. You can justify the relationship and describe the special constraints for each class. This is a good sign that these two classes should never derive from each other.\n\nYou might have seen other examples that derive Square from Rectangle to explain inheritance. You might be skeptical with the little test that you just did. Fair enough. Next, you\u2019ll write a program that illustrates the problem with deriving Square from Rectangle.\n\nFirst, you implement Rectangle. You\u2019re even going to encapsulate the attributes to ensure that you\u2019re meeting all the constraints:\n\nPython\nrectangle_square_demo.py\nclass Rectangle:\n    def __init__(self, length, height):\n        self._length = length\n        self._height = height\n\n    @property\n    def area(self):\n        return self._length * self._height\n\n\nYou initialize the Rectangle class with a length and a height, and the class provides an .area property that returns the area. The length and height are encapsulated as ._length and ._height to avoid changing them directly.\n\nNow, you derive Square from Rectangle and override the necessary interface to meet the constraints of a Square:\n\nPython\nrectangle_square_demo.py\n# ...\n\nclass Square(Rectangle):\n    def __init__(self, side_size):\n        super().__init__(side_size, side_size)\n\n\nYou initialize the Square class with a side_size, which is used to initialize both components of the base class. Now, you write a small program to test the behavior:\n\nPython\nrectangle_square_demo.py\n# ...\n\nrectangle = Rectangle(2, 4)\nassert rectangle.area == 8\n\nsquare = Square(2)\nassert square.area == 4\n\nprint(\"OK!\")\n\n\nThe program creates a Rectangle and a Square and asserts that their .area is calculated correctly. You can run the program and see that everything is OK so far:\n\nShell\n$ python rectangle_square_demo.py\n\nOK!\n\n\nThe program executes correctly, so it seems that Square is just a special case of a Rectangle.\n\nLater on, you need to support resizing Rectangle objects, so you make the appropriate changes to the class:\n\nPython\nrectangle_square_demo.py\nclass Rectangle:\n    def __init__(self, length, height):\n        self._length = length\n        self._height = height\n\n    @property\n    def area(self):\n        return self._length * self._height\n\n    def resize(self, new_length, new_height):\n        self._length = new_length\n        self._height = new_height\n\n\nYour .resize() method takes the new_length and new_width for the object. You can add the following code to the program to verify that it works correctly:\n\nPython\nrectangle_square_demo.py\n# ...\n\nrectangle.resize(3, 5)\nassert rectangle.area == 15\n\nprint(\"OK!\")\n\n\nYou resize the rectangle object and assert that the new area is correct. You can run the program to verify the behavior:\n\nShell\n$ python rectangle_square_demo.py\n\nOK!\n\n\nThe assertion passes, and you see that the program runs correctly.\n\nSo, what happens if you resize a square? Modify the program, and try to modify the square object:\n\nPython\nrectangle_square_demo.py\n# ...\n\nsquare.resize(3, 5)\nprint(f\"Square area: {square.area}\")\n\nprint(\"OK!\")\n\n\nYou pass the same parameters to square.resize() that you used with rectangle, and print the area. When you run the program you see:\n\nShell\n$ python rectangle_square_demo.py\n\nSquare area: 15\nOK!\n\n\nThe program shows that the new area is 15 like the rectangle object. The problem now is that the square object no longer meets the Square class constraint that the length and height must be equal.\n\nHow can you fix that problem? You can try several approaches, but all of them will be awkward. You can override .resize() in Square and ignore the height parameter. However, that will be confusing for people looking at other parts of the program where Rectangle objects are being resized and some of them are not getting the expected areas because they\u2019re really Square objects.\n\nIn a small program like this one, it might be easy to spot the causes of the weird behavior, but in a more complex program, the problem will be harder to find.\n\nThe reality is that if you\u2019re able to justify an inheritance relationship between two classes both ways, then you shouldn\u2019t derive one class from another.\n\nIn the example, it doesn\u2019t make sense that Square inherits the interface and implementation of .resize() from Rectangle. That doesn\u2019t mean that Square objects can\u2019t be resized. It means that the interface is different because it only needs a side_size parameter.\n\nThis difference in interface justifies not deriving Square from Rectangle, like the test above advised.\n\nRemove ads\nMixing Features With Mixin Classes\n\nOne of the uses of multiple inheritance in Python is to extend class features through mixins. A mixin is a class that provides methods to other classes but isn\u2019t considered a base class.\n\nA mixin allows other classes to reuse its interface and implementation without becoming a superclass. It implements a unique behavior that you can aggregate to other unrelated classes. Mixins are similar to composition, but they create a stronger relationship.\n\nSay you want to convert objects of certain types in your application to a dictionary representation of the object. You could provide a .to_dict() method in every class that you want to support this feature, but the implementation of .to_dict() seems to be very similar.\n\nThis could be a good candidate for a mixin. You start by slightly modifying the Employee class from the composition example:\n\nPython\nemployees.py\n# ...\n\nclass Employee:\n    def __init__(self, id, name, address, role, payroll):\n        self.id = id\n        self.name = name\n        self.address = address\n        self._role = role\n        self._payroll = payroll\n\n    def work(self, hours):\n        duties = self._role.perform_duties(hours)\n        print(f\"Employee {self.id} - {self.name}:\")\n        print(f\"- {duties}\")\n        print(\"\")\n        self._payroll.track_work(hours)\n\n    def calculate_payroll(self):\n        return self._payroll.calculate_payroll()\n\n\nThe changes are minimal. You just changed the .role and .payroll attributes to be internal by adding a leading underscore to their names. You\u2019ll see soon why you\u2019re making that change.\n\nNow, you create an AsDictionaryMixin class in a new file called representations.py:\n\nPython\nrepresentations.py\nclass AsDictionaryMixin:\n    def to_dict(self):\n        return {\n            prop: self._represent(value)\n            for prop, value in self.__dict__.items()\n            if not self._is_internal(prop)\n        }\n\n    def _represent(self, value):\n        if isinstance(value, object):\n            if hasattr(value, \"to_dict\"):\n                return value.to_dict()\n            else:\n                return str(value)\n        else:\n            return value\n\n    def _is_internal(self, prop):\n        return prop.startswith(\"_\")\n\n\nThe AsDictionaryMixin class exposes a .to_dict() method that returns the representation of itself as a dictionary. The method is implemented as a dict comprehension that creates a dictionary mapping prop to value for each item in self.__dict__.items() if the prop isn\u2019t internal.\n\nNote: This is why you made the role and payroll attributes internal in the Employee class\u2014because you don\u2019t want to represent them in the dictionary.\n\nAs you saw at the beginning, creating a class inherits some members from object, and one of those members is .__dict__, which is basically a mapping of all the attributes in an object to their values.\n\nYou iterate through all the items in .__dict__ and filter out the ones that have a name that starts with an underscore using ._is_internal().\n\nWith ._represent(), you check the specified value. If the value is an object, then the method looks to see if it also has a .to_dict() member and uses it to represent the object. Otherwise, it returns a string representation. If the value isn\u2019t an object, then it simply returns the value.\n\nYou can modify the Employee class to support this mixin:\n\nPython\nemployees.py\n# ...\n\nfrom representations import AsDictionaryMixin\n\n# ...\n\nclass Employee(AsDictionaryMixin):\n    # ...\n\n\nAll you have to do is inherit the AsDictionaryMixin to support the functionality. It\u2019ll be nice to support the same functionality in the Address class, so you represent the Employee.address attribute in the same way:\n\nPython\ncontacts.py\nfrom representations import AsDictionaryMixin\n\nclass Address(AsDictionaryMixin):\n    # ...\n\n\nYou apply the mixin to the Address class to support the feature. Now, you can write a small program to test it:\n\nPython\nprogram.py\nimport json\n\nfrom employees import EmployeeDatabase\n\ndef print_dict(d):\n    print(json.dumps(d, indent=2))\n\nfor employee in EmployeeDatabase().employees:\n    print_dict(employee.to_dict())\n\n\nThe program implements print_dict(), which converts the dictionary to a JSON string using indentation so the output looks better.\n\nThen, it iterates through all the employees, printing the dictionary representation provided by .to_dict(). You can run the program to see its output:\n\nShell\n $ python program.py\n\n{\n  \"id\": \"1\",\n  \"name\": \"Mary Poppins\",\n  \"address\": {\n    \"street\": \"121 Admin Rd.\",\n    \"street2\": \"\",\n    \"city\": \"Concord\",\n    \"state\": \"NH\",\n    \"zipcode\": \"03301\"\n  }\n}\n{\n  \"id\": \"2\",\n  \"name\": \"John Smith\",\n  \"address\": {\n    \"street\": \"67 Paperwork Ave\",\n    \"street2\": \"\",\n    \"city\": \"Manchester\",\n    \"state\": \"NH\",\n    \"zipcode\": \"03101\"\n  }\n}\n{\n  \"id\": \"3\",\n  \"name\": \"Kevin Bacon\",\n  \"address\": {\n    \"street\": \"15 Rose St\",\n    \"street2\": \"Apt. B-1\",\n    \"city\": \"Concord\",\n    \"state\": \"NH\",\n    \"zipcode\": \"03301\"\n  }\n}\n{\n  \"id\": \"4\",\n  \"name\": \"Jane Doe\",\n  \"address\": {\n    \"street\": \"39 Sole St.\",\n    \"street2\": \"\",\n    \"city\": \"Concord\",\n    \"state\": \"NH\",\n    \"zipcode\": \"03301\"\n  }\n}\n{\n  \"id\": \"5\",\n  \"name\": \"Robin Williams\",\n  \"address\": {\n    \"street\": \"99 Mountain Rd.\",\n    \"street2\": \"\",\n    \"city\": \"Concord\",\n    \"state\": \"NH\",\n    \"zipcode\": \"03301\"\n  }\n}\n\n\nYou leveraged the implementation of AsDictionaryMixin in both Employee and Address classes even when they\u2019re not related. Because AsDictionaryMixin only provides behavior, you can reuse it with other classes without causing problems.\n\nComposition to Model \u201cHas A\u201d Relationship\n\nComposition models a has a relationship. With composition, a class Composite has an instance of the class Component and can leverage its implementation. You can reuse the Component class in other classes completely unrelated to the Composite.\n\nIn the composition example above, the Employee class has an Address object. Address implements all the functionality to handle addresses, and other classes can reuse it.\n\nOther classes like Customer or Vendor can reuse Address without being related to Employee. They can leverage the same implementation, ensuring that addresses are handled consistently across the application.\n\nA problem that you may run into when using composition is that some of your classes may start growing by using multiple components. Your classes may require multiple parameters in the constructor just to pass in the components that they\u2019re made of. This can make your classes hard to use.\n\nA way to avoid the problem is by using the factory method to construct your objects. You did that with the composition example.\n\nIf you look at the implementation of the EmployeeDatabase class, then you\u2019ll notice that it uses ._create_employee() to construct an Employee object with the right parameters.\n\nThis design will work, but ideally, you should be able to construct an Employee object just by specifying an ID, for example employee = Employee(1).\n\nThe following changes might improve your design. You can start with the productivity module:\n\nPython\nproductivity.py\nclass _ProductivitySystem:\n    # ...\n\n# ...\n\n_productivity_system = _ProductivitySystem()\n\ndef get_role(role_id):\n    return _productivity_system.get_role(role_id)\n\ndef track(employees, hours):\n    _productivity_system.track(employees, hours)\n\n\nFirst, you make the _ProductivitySystem class internal by prepending an underscore to the class name. Then you provide a _productivity_system internal variable to the module. You\u2019re communicating to other developers that they shouldn\u2019t create or use _ProductivitySystem directly. Instead, you provide two functions, get_role() and track(), as the public interface to the module. This is what other modules should use.\n\nWhat you\u2019re saying is that _ProductivitySystem is a singleton, and there should only be one object created from it.\n\nNow, you can do the same with the hr module:\n\nPython\nhr.py\nclass _PayrollSystem:\n    # ...\n\n# ...\n\n_payroll_system = _PayrollSystem()\n\ndef get_policy(employee_id):\n    return _payroll_system.get_policy(employee_id)\n\ndef calculate_payroll(employees):\n    _payroll_system.calculate_payroll(employees)\n\n\nAgain, you make _PayrollSystem internal and provide a public interface to it. The application will use the public interface to get policies and calculate payroll.\n\nYou\u2019ll now do the same with the contacts module:\n\nPython\ncontacts.py\n# ...\n\nclass _AddressBook:\n    # ...\n\n_address_book = _AddressBook()\n\ndef get_employee_address(employee_id):\n    return _address_book.get_employee_address(employee_id)\n\n\nYou\u2019re basically saying that there should only be one _AddressBook, one _PayrollSystem, and one _ProductivitySystem. Again, this design pattern is called the singleton design pattern, which comes in handy for classes from which there should only be one single instance.\n\nNow, you can work on the employees module. You\u2019ll also mark the EmployeeDatabase as internal and make a singleton out of it, but you\u2019ll make some additional changes:\n\nPython\nemployees.py\nfrom productivity import get_role\nfrom hr import get_policy\nfrom contacts import get_employee_address\nfrom representations import AsDictionaryMixin\n\nclass _EmployeeDatabase:\n    def __init__(self):\n        self._employees = {\n            1: {\"name\": \"Mary Poppins\", \"role\": \"manager\"},\n            2: {\"name\": \"John Smith\", \"role\": \"secretary\"},\n            3: {\"name\": \"Kevin Bacon\", \"role\": \"sales\"},\n            4: {\"name\": \"Jane Doe\", \"role\": \"factory\"},\n            5: {\"name\": \"Robin Williams\", \"role\": \"secretary\"},\n        }\n\n    @property\n    def employees(self):\n        return [Employee(id_) for id_ in sorted(self._employees)]\n\n    def get_employee_info(self, employee_id):\n        info = self._employees.get(employee_id)\n        if not info:\n            raise ValueError(employee_id)\n        return info\n\nclass Employee(AsDictionaryMixin):\n    def __init__(self, id):\n        self.id = id\n        info = employee_database.get_employee_info(self.id)\n        self.name = info.get(\"name\")\n        self.address = get_employee_address(self.id)\n        self._role = get_role(info.get(\"role\"))\n        self._payroll = get_policy(self.id)\n\n    def work(self, hours):\n        duties = self._role.perform_duties(hours)\n        print(f\"Employee {self.id} - {self.name}:\")\n        print(f\"- {duties}\")\n        print(\"\")\n        self._payroll.track_work(hours)\n\n    def calculate_payroll(self):\n        return self._payroll.calculate_payroll()\n\nemployee_database = _EmployeeDatabase()\n\n\nYou first import the relevant public functions and classes from other modules. You make _EmployeeDatabase internal, and at the bottom, you create a single instance. This instance is public and part of the interface because you\u2019ll want to use it in the application.\n\nYou changed the _EmployeeDatabase._employees attribute to a dictionary where the key is the employee ID and the value is the employee information. You also exposed a .get_employee_info() method to return the information for the specified employee employee_id.\n\nThe _EmployeeDatabase.employees property now sorts the keys to return the employees sorted by their .id. You replaced the method that constructed the Employee objects with calls to the Employee initializer directly.\n\nThe Employee class now is initialized with the ID and uses the public functions exposed in the other modules to initialize its attributes.\n\nYou can now change the program to test the changes:\n\nPython\nprogram.py\nimport json\n\nfrom hr import calculate_payroll\nfrom productivity import track\nfrom employees import employee_database, Employee\n\ndef print_dict(d):\n    print(json.dumps(d, indent=2))\n\nemployees = employee_database.employees\n\ntrack(employees, 40)\ncalculate_payroll(employees)\n\ntemp_secretary = Employee(5)\nprint(\"Temporary Secretary:\")\nprint_dict(temp_secretary.to_dict())\n\n\nYou import the relevant functions from the hr and productivity modules, as well as the employee_database and Employee class. The program is cleaner because you exposed the required interface and encapsulated how to access objects.\n\nNotice that you can now create an Employee object directly just using its ID. You can run the program to see its output:\n\nShell\n$ python program.py\n\nTracking Employee Productivity\n==============================\nEmployee 1 - Mary Poppins:\n- screams and yells for 40 hours.\n\nEmployee 2 - John Smith:\n- does paperwork for 40 hours.\n\nEmployee 3 - Kevin Bacon:\n- expends 40 hours on the phone.\n\nEmployee 4 - Jane Doe:\n- manufactures gadgets for 40 hours.\n\nEmployee 5 - Robin Williams:\n- does paperwork for 40 hours.\n\n\nCalculating Payroll\n===================\nPayroll for: 1 - Mary Poppins\n- Check amount: 3000\n- Sent to:\n121 Admin Rd.\nConcord, NH 03301\n\nPayroll for: 2 - John Smith\n- Check amount: 1500\n- Sent to:\n67 Paperwork Ave\nManchester, NH 03101\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1800.0\n- Sent to:\n15 Rose St\nApt. B-1\nConcord, NH 03301\n\nPayroll for: 4 - Jane Doe\n- Check amount: 600\n- Sent to:\n39 Sole St.\nConcord, NH 03301\n\nPayroll for: 5 - Robin Williams\n- Check amount: 360\n- Sent to:\n99 Mountain Rd.\nConcord, NH 03301\n\nTemporary Secretary:\n{\n  \"id\": \"5\",\n  \"name\": \"Robin Williams\",\n  \"address\": {\n    \"street\": \"99 Mountain Rd.\",\n    \"street2\": \"\",\n    \"city\": \"Concord\",\n    \"state\": \"NH\",\n    \"zipcode\": \"03301\"\n  }\n}\n\n\nThe program works the same as before, but now you can see that you can create a single Employee object from its ID and display its dictionary representation.\n\nTake a closer look at the Employee class:\n\nPython\nemployees.py\n# ...\n\nclass Employee(AsDictionaryMixin):\n    def __init__(self, id):\n        self.id = id\n        info = employee_database.get_employee_info(self.id)\n        self.name = info.get(\"name\")\n        self.address = get_employee_address(self.id)\n        self._role = get_role(info.get(\"role\"))\n        self._payroll = get_policy(self.id)\n\n    def work(self, hours):\n        duties = self._role.perform_duties(hours)\n        print(f\"Employee {self.id} - {self.name}:\")\n        print(f\"- {duties}\")\n        print(\"\")\n        self._payroll.track_work(hours)\n\n    def calculate_payroll(self):\n        return self._payroll.calculate_payroll()\n\n\nThe Employee class is a composite that contains multiple objects providing different functionality. It contains an Address that implements all the functionality related to where the employee lives.\n\nEmployee also contains a productivity role from the productivity module, and a payroll policy from the hr module. These two objects provide implementations that the Employee class leverages to track work in the .work() method and to calculate the payroll in the .calculate_payroll() method.\n\nYou\u2019re using composition in two different ways. The Address class provides additional data to Employee, while the role and payroll objects provide additional behavior.\n\nStill, the relationship between Employee and those objects is loosely coupled, which provides some interesting capabilities that you\u2019ll see in the next section.\n\nComposition to Change Run-Time Behavior\n\nInheritance, as opposed to composition, is a tightly coupled relationship. With inheritance, there\u2019s only one way to change and customize behavior. Method overriding is the only way to customize the behavior of a base class. This creates rigid designs that are difficult to change.\n\nComposition, on the other hand, provides a loosely coupled relationship that enables flexible designs and can be used to change behavior at runtime.\n\nImagine you need to support a long-term disability (LTD) policy when calculating payroll. The policy states that an employee on LTD should be paid 60 percent of their weekly salary, assuming forty hours of work.\n\nWith an inheritance design, this can be a very difficult requirement to support. Adding it to the composition example is a lot simpler. Start by adding the policy class:\n\nPython\nhr.py\n# ...\n\nclass LTDPolicy:\n    def __init__(self):\n        self._base_policy = None\n\n    def track_work(self, hours):\n        self._check_base_policy()\n        return self._base_policy.track_work(hours)\n\n    def calculate_payroll(self):\n        self._check_base_policy()\n        base_salary = self._base_policy.calculate_payroll()\n        return base_salary * 0.6\n\n    def apply_to_policy(self, base_policy):\n        self._base_policy = base_policy\n\n    def _check_base_policy(self):\n        if not self._base_policy:\n            raise RuntimeError(\"Base policy missing\")\n\n# ...\n\n\nNotice that LTDPolicy doesn\u2019t inherit from PayrollPolicy, but implements the same interface. This is because the implementation is completely different, so you don\u2019t want to inherit any of the PayrollPolicy implementation.\n\nThe LTDPolicy initializes ._base_policy to None and provides an internal ._check_base_policy() method that raises an exception if the ._base_policy hasn\u2019t been applied. Then, it provides an .apply_to_policy() method to assign ._base_policy.\n\nThe public interface first checks that ._base_policy has been applied, and then it implements the functionality in terms of that base policy. The .track_work() method just delegates to the base policy, and .calculate_payroll() uses it to calculate the base_salary and then return the 60 percent.\n\nYou can now make a small change to the Employee class:\n\nPython\nemployees.py\n# ...\n\nclass Employee(AsDictionaryMixin):\n\n    # ...\n\n    def apply_payroll_policy(self, new_policy):\n        new_policy.apply_to_policy(self._payroll)\n        self._payroll = new_policy\n\n\nYou added an .apply_payroll_policy() method that applies the existing payroll policy to the new policy and then substitutes it. You can now modify the program to apply the policy to an Employee object:\n\nPython\nprogram.py\nfrom hr import calculate_payroll, LTDPolicy\nfrom productivity import track\nfrom employees import employee_database\n\nemployees = employee_database.employees\n\nsales_employee = employees[2]\nltd_policy = LTDPolicy()\nsales_employee.apply_payroll_policy(ltd_policy)\n\ntrack(employees, 40)\ncalculate_payroll(employees)\n\n\nThe program accesses sales_employee located at index 2, creates the LTDPolicy object, and applies the policy to the employee. When you call .calculate_payroll(), the change is reflected. You can run the program to evaluate the output:\n\nShell\n$ python program.py\n\nTracking Employee Productivity\n==============================\nEmployee 1 - Mary Poppins:\n- screams and yells for 40 hours.\n\nEmployee 2 - John Smith:\n- does paperwork for 40 hours.\n\nEmployee 3 - Kevin Bacon:\n- expends 40 hours on the phone.\n\nEmployee 4 - Jane Doe:\n- manufactures gadgets for 40 hours.\n\nEmployee 5 - Robin Williams:\n- does paperwork for 40 hours.\n\n\nCalculating Payroll\n===================\nPayroll for: 1 - Mary Poppins\n- Check amount: 3000\n- Sent to:\n121 Admin Rd.\nConcord, NH 03301\n\nPayroll for: 2 - John Smith\n- Check amount: 1500\n- Sent to:\n67 Paperwork Ave\nManchester, NH 03101\n\nPayroll for: 3 - Kevin Bacon\n- Check amount: 1080.0\n- Sent to:\n15 Rose St\nApt. B-1\nConcord, NH 03301\n\nPayroll for: 4 - Jane Doe\n- Check amount: 600\n- Sent to:\n39 Sole St.\nConcord, NH 03301\n\nPayroll for: 5 - Robin Williams\n- Check amount: 360\n- Sent to:\n99 Mountain Rd.\nConcord, NH 03301\n\n\nThe check amount for employee Kevin Bacon, who\u2019s the sales employee, is now for 1080 dollars instead of 1800 dollars. That\u2019s because the LTDPolicy has been applied to the salary.\n\nAs you can see, you were able to support the changes just by adding a new policy and modifying a couple of interfaces. This is the kind of flexibility that policy design based on composition gives you.\n\nChoosing Between Inheritance and Composition in Python\n\nPython, as an object-oriented programming language, supports both inheritance and composition. You saw that inheritance is best used to model an is a relationship, whereas composition models a has a relationship.\n\nSometimes, it\u2019s hard to see what the relationship between two classes should be, but you can follow these guidelines:\n\nUse inheritance over composition in Python to model a clear is a relationship. First, justify the relationship between the derived class and its base. Then, reverse the relationship and try to justify it. Only if you can\u2019t justify the relationship in both directions should you use inheritance between them.\n\nUse inheritance over composition in Python to leverage both the interface and implementation of the base class.\n\nUse inheritance over composition in Python to provide mixin features to several unrelated classes when there\u2019s only one implementation of that feature.\n\nUse composition over inheritance in Python to model a has a relationship that leverages the implementation of the component class.\n\nUse composition over inheritance in Python to create components that multiple classes in your Python applications can reuse.\n\nUse composition over inheritance in Python to implement groups of behaviors and policies that can be applied interchangeably to other classes to customize their behavior.\n\nUse composition over inheritance in Python to enable runtime behavior changes without affecting existing classes.\n\nWith that, you have a strong understanding of when to use inheritance vs composition.\n\nConclusion\n\nYou explored inheritance and composition in Python. You learned about the type of relationships that inheritance and composition create. You also went through a series of exercises to understand how inheritance and composition are implemented in Python.\n\nIn this tutorial, you learned how to:\n\nUse inheritance to express an is a relationship between two classes\nEvaluate if inheritance is the right relationship\nUse multiple inheritance in Python and evaluate Python\u2019s MRO to troubleshoot multiple inheritance problems\nExtend classes with mixins and reuse their implementation\nUse composition to express a has a relationship between two classes\nProvide flexible designs using composition\nReuse existing code through policy design based on composition\n\nInheritance and composition are both important concepts in object-oriented programming. By working through this tutorial, you\u2019ve strengthened your understanding of how you can use them in your Python programs and when you should choose one over the other.\n\nRecommended Reading\n\nBelow, you\u2019ll find a list of books and articles that further explore object-oriented design. These can help you understand the correct use of inheritance and composition in Python and other programming languages:\n\nDesign Patterns: Elements of Reusable Object-Oriented Software\nHead First Design Patterns: A Brain-Friendly Guide\nClean Code: A Handbook of Agile Software Craftsmanship\nSOLID Principles: Improve Object-Oriented Design in Python\nLiskov Substitution Principle\n\nWhat\u2019s your main takeaway from reading about inheritance and composition in Python? Share your thoughts in the comments below.\n\nGet Your Code: Click here to get the free sample code that shows you how to use inheritance and composition in Python.\n\n Take the Quiz: Test your knowledge with our interactive \u201cInheritance and Composition: A Python OOP Guide\u201d quiz. You\u2019ll receive a score upon completion to help you track your learning progress:\n\nInteractive Quiz\n\nInheritance and Composition: A Python OOP Guide\n\nIn this quiz, you'll test your understanding of inheritance and composition in Python. These are two major concepts in object-oriented programming that help model the relationship between two classes. By working through this quiz, you'll revisit how to use inheritance and composition in Python, model class hierarchies, and use multiple inheritance.\n\nFrequently Asked Questions\n\nNow that you have some experience with inheritance and composition in Python, you can use the questions and answers below to check your understanding and recap what you\u2019ve learned.\n\nThese FAQs are related to the most important concepts you\u2019ve covered in this tutorial. Click the Show/Hide toggle beside each question to reveal the answer.\n\nWhat are composition and inheritance in Python?\nShow/Hide\n\nHow is composition achieved in Python?\nShow/Hide\n\nWhat is the difference between composition and inheritance?\nShow/Hide\n\nHow to achieve inheritance in Python?\nShow/Hide\n\nMark as Completed\nShare\n\n Watch Now This tutorial has a related video course created by the Real Python team. Watch it together with the written tutorial to deepen your understanding: Inheritance and Composition: A Python OOP Guide\n\n\ud83d\udc0d Python Tricks \ud83d\udc8c\n\nGet a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.\n\nSend Me Python Tricks \u00bb\n\nAbout Isaac Rodriguez\n\nHi, I'm Isaac. I build, lead, and mentor software development teams, and for the past few years I've been focusing on cloud services and back-end applications using Python among other languages. Love to hear from you here at Real Python.\n\n\u00bb More about Isaac\n\nEach tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are:\n\nAlex\n\nAldren\n\nBrenda\n\nGeir Arne\n\nJoanna\n\nKate\n\nMartin\n\nStephen\n\nMaster Real-World Python Skills\nWith Unlimited Access to Real\u00a0Python\n\nJoin us and get access to thousands of tutorials, hands-on video courses, and a community of expert Pythonistas:\n\nLevel Up Your Python Skills \u00bb\n\nWhat Do You Think?\n\nRate this article: \nLinkedIn\nTwitter\nBluesky\nFacebook\nEmail\n\nWhat\u2019s your #1 takeaway or favorite thing you learned? How are you going to put your newfound skills to use? Leave a comment below and let us know.\n\nCommenting Tips: The most useful comments are those written with the goal of learning from or helping out other students. Get tips for asking good questions and get answers to common questions in our support portal.\n\nLooking for a real-time conversation? Visit the Real Python Community Chat or join the next \u201cOffice\u00a0Hours\u201d Live Q&A Session. Happy Pythoning!\n\nKeep Learning\n\nRelated Topics: intermediate best-practices python\n\nRecommended Video Course: Inheritance and Composition: A Python OOP Guide\n\nRelated Tutorials:\n\nSupercharge Your Classes With Python super()\nPython Modules and Packages \u2013 An Introduction\nPrimer on Python Decorators\nImplementing an Interface in Python\nPython Classes: The Power of Object-Oriented Programming\nRemove ads\n\n\u00a9 2012\u20132025 Real\u00a0Python\u00a0\u22c5 Newsletter\u00a0\u22c5 Podcast\u00a0\u22c5 YouTube\u00a0\u22c5 Twitter\u00a0\u22c5 Facebook\u00a0\u22c5 Instagram\u00a0\u22c5 Python\u00a0Tutorials\u00a0\u22c5 Search\u00a0\u22c5 Privacy Policy\u00a0\u22c5 Energy Policy\u00a0\u22c5 Advertise\u00a0\u22c5 Contact\n\n Happy Pythoning!",
  "content": {
    "Introduction to Oops Concepts": "Introduction to OOPs Concepts:\n\nObject-Oriented Programming (OOP) is a fundamental concept in programming that empowers developers to build modular, maintainable, and scalable applications. The core OOP principles include classes, objects, inheritance, encapsulation, polymorphism, and abstraction.\n\nClasses and Objects:\nA class is a user-defined template for creating objects. It bundles data and functions together, making it easier to manage and use them. An object is an instance of a class, and multiple instances of an object type can be created.\n\nKey Concepts:\n\n1. **Classes**: A class is a blueprint or a template that defines the properties and behavior of an object.\n2. **Objects**: An object is an instance of a class, and has its own set of attributes (data) and methods (functions).\n3. **Inheritance**: Inheritance is the mechanism by which one class can inherit the properties and behavior of another class.\n4. **Encapsulation**: Encapsulation is the concept of hiding the implementation details of an object from the outside world, and only exposing the necessary information through public methods.\n5. **Polymorphism**: Polymorphism is the ability of an object to take on multiple forms, depending on the context in which it is used.\n6. **Abstraction**: Abstraction is the concept of showing only the necessary information to the outside world, while hiding the internal implementation details.\n\nBenefits of OOP:\n\n1. **Modularity**: OOP allows for the creation of self-contained modules of code that can be easily reused and maintained.\n2. **Reusability**: OOP enables the creation of reusable code, which can be used to build multiple applications.\n3. **Easier Maintenance**: OOP makes it easier to modify and maintain code, as changes can be made at the class or object level without affecting other parts of the program.\n4. **Improved Readability**: OOP promotes readability by organizing code into logical units, making it easier to understand and follow.\n\nBy understanding the core OOP principles and concepts, programmers can leverage the full potential of object-oriented programming to build robust, scalable, and maintainable applications.",
    "Class and Objects in Python": "**Introduction to Classes and Objects in Python**\n======================================================\n\nPython is an object-oriented programming language that supports the concept of classes and objects. A class is a user-defined data type that consists of data members and member functions, which can be accessed and used by creating an instance of that class.\n\n**Class Definition**\n-------------------\n\nA class in Python is defined using the \"class\" keyword followed by the name of the class. The class definition includes the attributes and methods of the class.\n\n**Object Creation**\n------------------\n\nAn object is created by instantiating a class. This is done by calling the class name followed by parentheses containing the required arguments.\n\n**Inheritance**\n----------------\n\nInheritance is a fundamental concept in object-oriented programming (OOP) that allows a class (called a child or derived class) to inherit attributes and methods from another class (called a parent or base class).\n\n**Polymorphism**\n----------------\n\nPolymorphism is the ability of an object to take on multiple forms. This can be achieved through method overriding or method overloading.\n\n**Encapsulation**\n----------------\n\nEncapsulation is the concept of hiding the implementation details of an object from the outside world and only exposing the necessary information through public methods.\n\n**Example Use Cases**\n--------------------\n\n*   Creating a class to represent a car with attributes like color, model, year, and methods like start(), stop(), accelerate(), etc.\n*   Creating a class to represent a bank account with attributes like account number, balance, and methods like deposit(), withdraw(), get_balance(), etc.\n\nBy using classes and objects, you can create more organized, reusable, and maintainable code that is easier to understand and modify.",
    "Inheritance in Python": "Inheritance in Python is a fundamental concept in object-oriented programming that allows a class (called a child or derived class) to inherit attributes and methods from another class (called a parent or base class). This promotes code reuse, modularity, and a hierarchical class structure. \n\nThere are several types of inheritance in Python, including single inheritance, multiple inheritance, multilevel inheritance, hierarchical inheritance, and hybrid inheritance. \n\nTo use inheritance in Python, you can define a parent class and a child class, and the child class can inherit attributes and methods from the parent class using the `(ParentClass)` syntax. \n\nMethod overriding is also an important concept in inheritance, where a child class can provide a specific implementation of a method that is already provided by one of its super-classes or parent classes. \n\nBest practices for using inheritance in Python include using composition over inheritance to implement groups of behaviors and policies that can be applied interchangeably to other classes to customize their behavior, and using inheritance to promote code reuse, modularity, and a hierarchical class structure. \n\nSome key concepts and techniques in inheritance include:\n\n* Defining a parent class and a child class\n* Using the `(ParentClass)` syntax to inherit attributes and methods\n* Method overriding to provide a specific implementation of a method\n* Using composition over inheritance to customize behavior\n* Using inheritance to promote code reuse, modularity, and a hierarchical class structure\n\nExample code for inheritance in Python includes:\n```python\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} barks!\"\n\ndog = Dog(\"Buddy\")\nprint(dog.speak())  # Output: Buddy barks!\n```\nThis code defines a parent class `Animal` and a child class `Dog`, where the `Dog` class inherits the `name` attribute and the `speak` method from the `Animal` class, and provides a specific implementation of the `speak` method. \n\nIn conclusion, inheritance is a powerful concept in object-oriented programming that allows for code reuse, modularity, and a hierarchical class structure. By understanding the different types of inheritance, method overriding, and best practices for using inheritance, you can write more efficient and effective Python code.",
    "Polymorphism in Python": "Polymorphism in Python refers to the ability of an entity, such as a function, method, or operator, to behave differently based on the type of data it is handling. This concept is derived from the Greek word \"polymorphism,\" which means \"many forms.\" Python's dynamic typing and duck typing make it inherently polymorphic, allowing functions, operators, and built-in objects to exhibit polymorphic behavior.\n\nThere are several types of polymorphism in Python, including:\n\n1. Function Polymorphism: This occurs when a function can be used with different types of data. For example, the len() function can be used to get the length of a string, tuple, or dictionary.\n2. Operator Polymorphism: This occurs when an operator, such as the + operator, can be used with different types of data. For example, the + operator can be used to perform arithmetic addition with integers or concatenation with strings.\n3. Class Polymorphism: This occurs when multiple classes can have the same method name. This allows objects of different classes to be treated as objects of a common superclass.\n\nPolymorphism is often used in object-oriented programming (OOP) to create more flexible and reusable code. It allows for the creation of functions and methods that can work with a variety of data types, making it easier to write code that can be applied to different situations.\n\nSome examples of polymorphism in Python include:\n\n* Using the len() function to get the length of a string, tuple, or dictionary\n* Using the + operator to perform arithmetic addition with integers or concatenation with strings\n* Defining a function that can work with different types of data, such as a function that can add two numbers or concatenate two strings\n* Creating multiple classes that have the same method name, allowing objects of different classes to be treated as objects of a common superclass\n\nOverall, polymorphism is a powerful tool in Python that allows for more flexibility and reuse in coding. It enables developers to write code that can be applied to a variety of situations, making it easier to create robust and maintainable software systems.",
    "Encapsulation and Abstraction in Python": "**Encapsulation and Abstraction in Python: A Structured Summary**\n\n### Introduction\n\nEncapsulation and abstraction are fundamental concepts in object-oriented programming (OOP) that enable developers to create robust, maintainable, and scalable software systems. In Python, these concepts play a crucial role in designing and implementing classes, objects, and interfaces.\n\n### Encapsulation\n\nEncapsulation is the practice of bundling data and methods that operate on that data into a single unit, called a class. This concept helps hide the internal state of an object from the outside world, providing a controlled interface for interacting with the object's data and methods.\n\n**Key Points:**\n\n1. **Definition:** Encapsulation is the bundling of data and methods that operate on the data into a single unit, with controlled access to the internal state.\n2. **Purpose:** To protect an object's internal state and expose a controlled interface.\n3. **Implementation:** Achieved through private and protected members in Python.\n4. **Benefits:**\n\t* Controlled access to data\n\t* Data hiding\n\t* Improved maintenance\n\t* Enhanced flexibility\n\n### Abstraction\n\nAbstraction is the concept of hiding complex implementation details and showing only the essential features of an object. This concept simplifies interaction with objects by focusing on high-level operations rather than implementation details.\n\n**Key Points:**\n\n1. **Definition:** Abstraction is the concept of hiding complex implementation details and showing only the essential features of an object.\n2. **Purpose:** To simplify interaction with objects by focusing on high-level operations rather than implementation details.\n3. **Implementation:** Achieved through abstract classes and methods, interfaces, and high-level class design in Python.\n4. **Benefits:**\n\t* Simplified interaction with objects\n\t* Improved modularity\n\t* Easier maintenance and extension\n\n### Comparison of Encapsulation and Abstraction\n\n| Concept | Definition | Purpose | Implementation |\n| --- | --- | --- | --- |\n| Encapsulation | Bundling data and methods | Protect internal state | Private and protected members |\n| Abstraction | Hiding complex implementation details | Simplify interaction | Abstract classes and methods, interfaces |\n\nIn conclusion, encapsulation and abstraction are essential concepts in Python that enable developers to create robust, maintainable, and scalable software systems. By understanding and applying these concepts, developers can design and implement classes, objects, and interfaces that are modular, flexible, and easy to maintain."
  },
  "slides": [
    [
      {
        "title": "Introduction to OOPs Concepts",
        "content": "Object-Oriented Programming (OOP) is a fundamental concept in programming that empowers developers to build modular, maintainable, and scalable applications.",
        "code": ""
      },
      {
        "title": "Classes and Objects",
        "content": "A class is a user-defined template for creating objects. It bundles data and functions together, making it easier to manage and use them. An object is an instance of a class, and multiple instances of an object type can be created.",
        "code": "class Car {\n    constructor(brand, model, year) {\n        this.brand = brand;\n        this.model = model;\n        this.year = year;\n    }\n}\n\nlet myCar = new Car('Toyota', 'Corolla', 2015);"
      },
      {
        "title": "Key Concepts",
        "content": "The core OOP principles include classes, objects, inheritance, encapsulation, polymorphism, and abstraction.",
        "code": ""
      },
      {
        "title": "Classes",
        "content": "A class is a blueprint or a template that defines the properties and behavior of an object.",
        "code": "class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    greet() {\n        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n    }\n}"
      },
      {
        "title": "Objects",
        "content": "An object is an instance of a class, and has its own set of attributes (data) and methods (functions).",
        "code": "let person = new Person('John Doe', 30);\nperson.greet();"
      },
      {
        "title": "Inheritance",
        "content": "Inheritance is the mechanism by which one class can inherit the properties and behavior of another class.",
        "code": "class Employee extends Person {\n    constructor(name, age, salary) {\n        super(name, age);\n        this.salary = salary;\n    }\n\n    getSalary() {\n        return this.salary;\n    }\n}"
      },
      {
        "title": "Encapsulation",
        "content": "Encapsulation is the concept of hiding the implementation details of an object from the outside world, and only exposing the necessary information through public methods.",
        "code": "class BankAccount {\n    constructor(accountNumber, balance) {\n        this.accountNumber = accountNumber;\n        this.balance = balance;\n    }\n\n    getBalance() {\n        return this.balance;\n    }\n\n    deposit(amount) {\n        this.balance += amount;\n    }\n}"
      },
      {
        "title": "Polymorphism",
        "content": "Polymorphism is the ability of an object to take on multiple forms, depending on the context in which it is used.",
        "code": "class Shape {\n    area() {}\n}\n\nclass Square extends Shape {\n    constructor(side) {\n        super();\n        this.side = side;\n    }\n\n    area() {\n        return this.side * this.side;\n    }\n}\n\nclass Circle extends Shape {\n    constructor(radius) {\n        super();\n        this.radius = radius;\n    }\n\n    area() {\n        return Math.PI * this.radius * this.radius;\n    }\n}"
      },
      {
        "title": "Abstraction",
        "content": "Abstraction is the concept of showing only the necessary information to the outside world, while hiding the internal implementation details.",
        "code": "class CoffeeMachine {\n    constructor() {\n        this.waterTemp = 0;\n    }\n\n    makeCoffee() {\n        this.boilWater();\n        this.mixCoffee();\n    }\n\n    boilWater() {\n        // internal implementation\n        this.waterTemp = 100;\n    }\n\n    mixCoffee() {\n        // internal implementation\n        console.log('Coffee is ready');\n    }\n}"
      },
      {
        "title": "Benefits of OOP",
        "content": "The benefits of OOP include modularity, reusability, easier maintenance, and improved readability.",
        "code": ""
      },
      {
        "title": "Modularity",
        "content": "OOP allows for the creation of self-contained modules of code that can be easily reused and maintained.",
        "code": ""
      },
      {
        "title": "Reusability",
        "content": "OOP enables the creation of reusable code, which can be used to build multiple applications.",
        "code": ""
      },
      {
        "title": "Easier Maintenance",
        "content": "OOP makes it easier to modify and maintain code, as changes can be made at the class or object level without affecting other parts of the program.",
        "code": ""
      },
      {
        "title": "Improved Readability",
        "content": "OOP promotes readability by organizing code into logical units, making it easier to understand and follow.",
        "code": ""
      }
    ],
    [
      {
        "title": "Introduction to Classes and Objects in Python",
        "content": "Python is an object-oriented programming language that supports the concept of classes and objects. A class is a user-defined data type that consists of data members and member functions, which can be accessed and used by creating an instance of that class.",
        "code": ""
      },
      {
        "title": "Class Definition",
        "content": "A class in Python is defined using the 'class' keyword followed by the name of the class. The class definition includes the attributes and methods of the class.",
        "code": "class Car:\n    def __init__(self, color, model, year):\n        self.color = color\n        self.model = model\n        self.year = year"
      },
      {
        "title": "Object Creation",
        "content": "An object is created by instantiating a class. This is done by calling the class name followed by parentheses containing the required arguments.",
        "code": "my_car = Car('red', 'Toyota', 2022)\nprint(my_car.color)\nprint(my_car.model)\nprint(my_car.year)"
      },
      {
        "title": "Inheritance",
        "content": "Inheritance is a fundamental concept in object-oriented programming (OOP) that allows a class (called a child or derived class) to inherit attributes and methods from another class (called a parent or base class).",
        "code": "class ElectricCar(Car):\n    def __init__(self, color, model, year, battery_capacity):\n        super().__init__(color, model, year)\n        self.battery_capacity = battery_capacity"
      },
      {
        "title": "Polymorphism",
        "content": "Polymorphism is the ability of an object to take on multiple forms. This can be achieved through method overriding or method overloading.",
        "code": "class Shape:\n    def area(self):\n        pass\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    def area(self):\n        return self.side ** 2"
      },
      {
        "title": "Encapsulation",
        "content": "Encapsulation is the concept of hiding the implementation details of an object from the outside world and only exposing the necessary information through public methods.",
        "code": "class BankAccount:\n    def __init__(self, account_number, balance):\n        self.__account_number = account_number\n        self.__balance = balance\n    def get_balance(self):\n        return self.__balance"
      },
      {
        "title": "Example Use Cases",
        "content": "Example use cases include creating a class to represent a car with attributes like color, model, year, and methods like start(), stop(), accelerate(), etc. Another example is creating a class to represent a bank account with attributes like account number, balance, and methods like deposit(), withdraw(), get_balance(), etc.",
        "code": "class Car:\n    def __init__(self, color, model, year):\n        self.color = color\n        self.model = model\n        self.year = year\n    def start(self):\n        return 'The car is starting'\n    def stop(self):\n        return 'The car is stopping'"
      }
    ]
  ],
  "lecture": [
    "**Introduction to OOPs Concepts**\n=====================================\n\nWelcome, students! Today, we're going to explore one of the fundamental concepts in programming: Object-Oriented Programming (OOP). OOP is a powerful paradigm that enables developers to build modular, maintainable, and scalable applications. It's a way of thinking about programming that focuses on organizing and structuring code around objects and their interactions.\n\nTo illustrate this concept, let's consider a real-world example. Imagine you're building a simulation of a city. You have different types of objects, such as cars, buildings, and people, each with their own properties and behaviors. Using OOP, you can create classes that represent these objects, and then instantiate them to create multiple objects with unique characteristics.\n\nFor instance, you could create a `Car` class with attributes like `color`, `model`, and `year`, and methods like `start()` and `stop()`. Then, you could create multiple `Car` objects, each with its own values for these attributes. This approach makes it easy to manage and extend your code, as you can simply modify the `Car` class to add new features or behaviors.\n\n**Classes and Objects**\n=====================\n\nNow, let's dive deeper into the concepts of classes and objects. A class is a user-defined template for creating objects. It bundles data and functions together, making it easier to manage and use them. An object, on the other hand, is an instance of a class, and multiple instances of an object type can be created.\n\nTo illustrate this, let's consider a `Car` class:\n```python\nclass Car:\n    def __init__(self, color, model, year):\n        self.color = color\n        self.model = model\n        self.year = year\n```\nIn this example, `Car` is a class that has attributes like `color`, `model`, and `year`. We can create multiple objects from this class, each with its own values for these attributes:\n```python\nmy_car = Car('red', 'Toyota', 2022)\nyour_car = Car('blue', 'Honda', 2019)\n```\nNotice how we've created two separate objects, `my_car` and `your_car`, each with its own unique characteristics.\n\n**Key Concepts**\n==============\n\nNow that we've covered classes and objects, let's discuss some key concepts in OOP:\n\n*   **Inheritance**: This is the mechanism by which one class can inherit the properties and behavior of another class.\n*   **Encapsulation**: This is the concept of hiding the implementation details of an object from the outside world and only exposing the necessary information through public methods.\n*   **Polymorphism**: This is the ability of an object to take on multiple forms, depending on the context in which it is used.\n*   **Abstraction**: This is the concept of showing only the necessary information to the outside world, while hiding the internal implementation details.\n\nThese concepts are essential to understanding OOP, and we'll explore each of them in more detail as we progress through the course.\n\n**Classes**\n==========\n\nA class is a blueprint or a template that defines the properties and behavior of an object. It's essentially a design pattern or a template that defines the characteristics of an object.\n\nLet's consider an example:\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greet(self):\n        print(f\"Hello, my name is {self.name} and I am {self.age} years old.\")\n```\nIn this example, `Person` is a class that has attributes like `name` and `age`, and a method called `greet()`. We can create multiple objects from this class, each with its own values for these attributes:\n```python\njohn = Person('John Doe', 30)\njane = Person('Jane Doe', 25)\n\njohn.greet()  # Output: Hello, my name is John Doe and I am 30 years old.\njane.greet()  # Output: Hello, my name is Jane Doe and I am 25 years old.\n```\nNotice how we've created two separate objects, `john` and `jane`, each with its own unique characteristics.\n\n**Objects**\n==========\n\nAn object is an instance of a class, and has its own set of attributes (data) and methods (functions). Objects are the runtime entities that are created from a class.\n\nLet's consider an example:\n```python\nclass Car:\n    def __init__(self, color, model, year):\n        self.color = color\n        self.model = model\n        self.year = year\n\nmy_car = Car('red', 'Toyota', 2022)\nprint(my_car.color)  # Output: red\nprint(my_car.model)  # Output: Toyota\nprint(my_car.year)  # Output: 2022\n```\nIn this example, `my_car` is an object that is an instance of the `Car` class. It has attributes like `color`, `model`, and `year`, which are accessed using dot notation.\n\n**Inheritance**\n==============\n\nInheritance is the mechanism by which one class can inherit the properties and behavior of another class. This allows for code reuse and facilitates the creation of a hierarchy of classes.\n\nLet's consider an example:\n```python\nclass Employee:\n    def __init__(self, name, age, salary):\n        self.name = name\n        self.age = age\n        self.salary = salary\n\n    def display_details(self):\n        print(f\"Name: {self.name}, Age: {self.age}, Salary: {self.salary}\")\n\nclass Manager(Employee):\n    def __init__(self, name, age, salary, department):\n        super().__init__(name, age, salary)\n        self.department = department\n\n    def display_details(self):\n        super().display_details()\n        print(f\"Department: {self.department}\")\n\nmanager = Manager('John Doe', 30, 50000, 'Sales')\nmanager.display_details()\n# Output:\n# Name: John Doe, Age: 30, Salary: 50000\n# Department: Sales\n```\nIn this example, the `Manager` class inherits the properties and behavior of the `Employee` class using inheritance. The `Manager` class also adds a new attribute called `department` and overrides the `display_details()` method to include the department.\n\n**Encapsulation**\n==============\n\nEncapsulation is the concept of hiding the implementation details of an object from the outside world and only exposing the necessary information through public methods. This helps to protect the internal state of an object from external interference and misuse.\n\nLet's consider an example:\n```python\nclass BankAccount:\n    def __init__(self, account_number, balance):\n        self.__account_number = account_number\n        self.__balance = balance\n\n    def get_balance(self):\n        return self.__balance\n\n    def deposit(self, amount):\n        if amount > 0:\n            self.__balance += amount\n            print(f\"Deposited {amount}. Current balance is {self.__balance}\")\n        else:\n            print(\"Invalid deposit amount\")\n\naccount = BankAccount('1234567890', 1000)\nprint(account.get_balance())  # Output: 1000\naccount.deposit(500)  # Output: Deposited 500. Current balance is 1500\n```\nIn this example, the `BankAccount` class encapsulates the `account_number` and `balance` attributes, making them private using double underscore notation. The class provides public methods like `get_balance()` and `deposit()` to access and modify the internal state of the object.\n\n**Polymorphism**\n==============\n\nPolymorphism is the ability of an object to take on multiple forms, depending on the context in which it is used. This can be achieved through method overriding or method overloading.\n\nLet's consider an example:\n```python\nclass Shape:\n    def area(self):\n        pass\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n\n    def area(self):\n        return self.side ** 2\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14 * self.radius ** 2\n\nsquare = Square(4)\ncircle = Circle(5)\n\nprint(square.area())  # Output: 16\nprint(circle.area())  # Output: 78.5\n```\nIn this example, the `Square` and `Circle` classes override the `area()` method of the `Shape` class, providing their own implementation of the method. This allows objects of different classes to be treated as objects of a common superclass, demonstrating polymorphism.\n\n**Abstraction**\n============\n\nAbstraction is the concept of showing only the necessary information to the outside world, while hiding the internal implementation details. This helps to reduce complexity and improve modularity in software design.\n\nLet's consider an example:\n```python\nclass CoffeeMachine:\n    def __init__(self):\n        self.__water_temp = 0\n\n    def make_coffee(self):\n        self.__boil_water()\n        self.__mix_coffee()\n\n    def __boil_water(self):\n        # internal implementation\n        self.__water_temp = 100\n\n    def __mix_coffee(self):\n        # internal implementation\n        print(\"Coffee is ready\")\n\nmachine = CoffeeMachine()\nmachine.make_coffee()  # Output: Coffee is ready\n```\nIn this example, the `CoffeeMachine` class abstracts the internal implementation details of making coffee, such as boiling water and mixing coffee. The `make_coffee()` method provides a simple interface for users to make coffee, without exposing the internal complexity of the process.\n\n**Benefits of OOP**\n==================\n\nNow that we've explored the key concepts of OOP, let's discuss some of the benefits of using OOP in software design:\n\n*   **Modularity**: OOP allows for the creation of self-contained modules of code that can be easily reused and maintained.\n*   **Reusability**: OOP enables the creation of reusable code, which can be used to build multiple applications.\n*   **Easier Maintenance**: OOP makes it easier to modify and maintain code, as changes can be made at the class or object level without affecting other parts of the program.\n*   **Improved Readability**: OOP promotes readability by organizing code into logical units, making it easier to understand and follow.\n\nBy using OOP principles, developers can create software systems that are more modular, reusable, and maintainable, leading to improved productivity and reduced development time.\n\n**Modularity**\n============\n\nModularity is one of the key benefits of OOP. By breaking down a large system into smaller, independent modules, developers can create software that is more flexible, scalable, and maintainable.\n\nLet's consider an example:\n```python\nclass PaymentGateway:\n    def process_payment(self, amount):\n        # internal implementation\n        print(f\"Payment of {amount} processed\")\n\nclass PaymentProcessor:\n    def __init__(self, gateway):\n        self.gateway = gateway\n\n    def process_payment(self, amount):\n        self.gateway.process_payment(amount)\n\ngateway = PaymentGateway()\nprocessor = PaymentProcessor(gateway)\nprocessor.process_payment(100)  # Output: Payment of 100 processed\n```\nIn this example, the `PaymentGateway` class is a modular component that encapsulates the payment processing logic. The `PaymentProcessor` class uses the `PaymentGateway` class to process payments, demonstrating modularity and reusability.\n\n**Reusability**\n============\n\nReusability is another key benefit of OOP. By creating reusable code, developers can reduce development time and improve productivity.\n\nLet's consider an example:\n```python\nclass Vehicle:\n    def __init__(self, brand, model):\n        self.brand = brand\n        self.model = model\n\n    def display_details(self):\n        print(f\"Brand: {self.brand}, Model: {self.model}\")\n\nclass Car(Vehicle):\n    def __init__(self, brand, model, year):\n        super().__init__(brand, model)\n        self.year = year\n\n    def display_details(self):\n        super().display_details()\n        print(f\"Year: {self.year}\")\n\nclass Truck(Vehicle):\n    def __init__(self, brand, model, capacity):\n        super().__init__(brand, model)\n        self.capacity = capacity\n\n    def display_details(self):\n        super().display_details()\n        print(f\"Capacity: {self.capacity}\")\n\ncar = Car('Toyota', 'Corolla', 2022)\ntruck = Truck('Ford', 'F-150', 2)\n\ncar.display_details()\n# Output:\n# Brand: Toyota, Model: Corolla\n# Year: 2022\n\ntruck.display_details()\n# Output:\n# Brand: Ford, Model: F-150\n# Capacity: 2\n```\nIn this example, the `Vehicle` class is a reusable component that provides a basic implementation of a vehicle. The `Car` and `Truck` classes inherit from the `Vehicle` class, adding their own specific attributes and methods. This demonstrates reusability and modularity in OOP.\n\n**Easier Maintenance**\n==================\n\nEasier maintenance is another key benefit of OOP. By organizing code into logical units, developers can modify and maintain code more easily, without affecting other parts of the program.\n\nLet's consider an example:\n```python\nclass Employee:\n    def __init__(self, name, age, salary):\n        self.name = name\n        self.age = age\n        self.salary = salary\n\n    def display_details(self):\n        print(f\"Name: {self.name}, Age: {self.age}, Salary: {self.salary}\")\n\nclass Manager(Employee):\n    def __init__(self, name, age, salary, department):\n        super().__init__(name, age, salary)\n        self.department = department\n\n    def display_details(self):\n        super().display_details()\n        print(f\"Department: {self.department}\")\n\nemployee = Employee('John Doe', 30, 50000)\nmanager = Manager('Jane Doe', 35, 70000, 'Sales')\n\nemployee.display_details()\n# Output:\n# Name: John Doe, Age: 30, Salary: 50000\n\nmanager.display_details()\n# Output:\n# Name: Jane Doe, Age: 35, Salary: 70000\n# Department: Sales\n```\nIn this example, the `Employee` class is a modular component that encapsulates the employee details. The `Manager` class inherits from the `Employee` class, adding its own specific attributes and methods. This demonstrates easier maintenance and modularity in OOP.\n\n**Improved Readability**\n=====================\n\nImproved readability is another key benefit of OOP. By organizing code into logical units, developers can create software that is easier to understand and follow.\n\nLet's consider an example:\n```python\nclass BankAccount:\n    def __init__(self, account_number, balance):\n        self.__account_number = account_number\n        self.__balance = balance\n\n    def get_balance(self):\n        return self.__balance\n\n    def deposit(self, amount):\n        if amount > 0:\n            self.__balance += amount\n            print(f\"Deposited {amount}. Current balance is {self.__balance}\")\n        else:\n            print(\"Invalid deposit amount\")\n\nclass Customer:\n    def __init__(self, name, account):\n        self.name = name\n        self.account = account\n\n    def display_details(self):\n        print(f\"Name: {self.name}\")\n        print(f\"Account Number: {self.account._BankAccount__account_number}\")\n        print(f\"Balance: {self.account.get_balance()}\")\n\naccount = BankAccount('1234567890', 1000)\ncustomer = Customer('John Doe', account)\n\ncustomer.display_details()\n# Output:\n# Name: John Doe\n# Account Number: 1234567890\n# Balance: 1000\n```\nIn this example, the `BankAccount` class is a modular component that encapsulates the account details. The `Customer` class uses the `BankAccount` class to display customer details, demonstrating improved readability and modularity in OOP.\n\n**Introduction to Classes and Objects in Python**\n=====================================================\n\nPython is an object-oriented programming language that supports the concept of classes and objects. A class is a user-defined data type that consists of data members and member functions, which can be accessed and used by creating an instance of that class.\n\nLet's consider an example:\n```python\nclass Car:\n    def __init__(self, color, model, year):\n        self.color = color\n        self.model = model\n        self.year = year\n\nmy_car = Car('red', 'Toyota', 2022)\nprint(my_car.color)  # Output: red\nprint(my_car.model)  # Output: Toyota\nprint(my_car.year)  # Output: 2022\n```\nIn this example, `Car` is a class that has attributes like `color`, `model`, and `year`. We create an object `my_car` from the `Car` class and access its attributes using dot notation.\n\n**Class Definition**\n=====================\n\nA class in Python is defined using the `class` keyword followed by the name of the class. The class definition includes the attributes and methods of the class.\n\nLet's consider an example:\n```python\nclass Car:\n    def __init__(self, color, model, year):\n        self.color = color\n        self.model = model\n        self.year = year\n\n    def start(self):\n        print(\"The car is starting\")\n\n    def stop(self):\n        print(\"The car is stopping\")\n```\nIn this example, `Car` is a class that has attributes like `color`, `model`, and `year`, and methods like `start()` and `stop()`.\n\n**Object Creation**\n==================\n\nAn object is created by instantiating a class. This is done by calling the class name followed by parentheses containing the required arguments.\n\nLet's consider an example:\n```python\nmy_car = Car('red', 'Toyota', 2022)\nprint(my_car.color)  # Output: red\nprint(my_car.model)  # Output: Toyota\nprint(my_car.year)  # Output: 2022\n```\nIn this example, we create an object `my_car` from the `Car` class and access its attributes using dot notation.\n\n**Inheritance**\n==============\n\nInheritance is a fundamental concept in object-oriented programming (OOP) that allows a class (called a child or derived class) to inherit attributes and methods from another class (called a parent or base class).\n\nLet's consider an example:\n```python\nclass ElectricCar(Car):\n    def __init__(self, color, model, year, battery_capacity):\n        super().__init__(color, model, year)\n        self.battery_capacity = battery_capacity\n\n    def charge(self):\n        print(\"The car is charging\")\n```\nIn this example, `ElectricCar` is a child class that inherits attributes and methods from the `Car` class. The `ElectricCar` class also adds its own attributes and methods, such as `battery_capacity` and `charge()`.\n\n**Polymorphism**\n==============\n\nPolymorphism is the ability of an object to take on multiple forms. This can be achieved through method overriding or method overloading.\n\nLet's consider an example:\n```python\nclass Shape:\n    def area(self):\n        pass\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n\n    def area(self):\n        return self.side ** 2\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14 * self.radius ** 2\n\nsquare = Square(4)\ncircle = Circle(5)\n\nprint(square.area())  # Output: 16\nprint(circle.area())  # Output: 78.5\n```\nIn this example, `Square` and `Circle` are classes that inherit from the `Shape` class. The `area()` method is overridden in each class to provide a specific implementation.\n\n**Encapsulation**\n==============\n\nEncapsulation is the concept of hiding the implementation details of an object from the outside world and only exposing the necessary information through public methods.\n\nLet's consider an example:\n```python\nclass BankAccount:\n    def __init__(self, account_number, balance):\n        self.__account_number = account_number\n        self.__balance = balance\n\n    def get_balance(self):\n        return self.__balance\n\n    def deposit(self, amount):\n        if amount > 0:\n            self.__balance += amount\n            print(f\"Deposited {amount}. Current balance is {self.__balance}\")\n        else:\n            print(\"Invalid deposit amount\")\n\naccount = BankAccount('1234567890', 1000)\nprint(account.get_balance())  # Output: 1000\naccount.deposit(500)  # Output: Deposited 500. Current balance is 1500\n```\nIn this example, the `BankAccount` class encapsulates the account details, such as `account_number` and `balance`. The class provides public methods like `get_balance()` and `deposit()` to access and modify the account details.\n\n**Example Use Cases**\n=====================\n\nHere are some example use cases for OOP in Python:\n\n*   **Banking System**: Create a `BankAccount` class to represent a bank account, with attributes like `account_number`, `balance`, and methods like `deposit()`, `withdraw()`, and `get_balance()`.\n*   **E-commerce Platform**: Create a `Product` class to represent a product, with attributes like `name`, `price`, and `description`, and methods like `add_to_cart()` and `remove_from_cart()`.\n*   **Game Development**: Create a `Player` class to represent a player, with attributes like `name`, `score`, and methods like `move()` and `jump()`.\n\nThese are just a few examples of how OOP can be applied in real-world scenarios. By using OOP principles, developers can create software that is more modular, reusable, and maintainable.",
    "**Introduction to OOPs Concepts**\n=====================================\n\nWelcome, students, to today's lecture on Object-Oriented Programming (OOP) concepts in Python. OOP is a fundamental concept in programming that empowers developers to build modular, maintainable, and scalable applications. In this lecture, we will explore the core principles of OOP, including classes, objects, inheritance, encapsulation, polymorphism, and abstraction. We will also discuss the benefits of OOP and how it can be applied in real-world scenarios.\n\nTo start, let's consider a real-world example. Imagine you are building a simulation of a car racing game. You would need to create multiple cars with different attributes, such as color, model, and year. Without OOP, you would have to create separate variables and functions for each car, which would be tedious and prone to errors. With OOP, you can create a `Car` class that encapsulates the attributes and behavior of a car, making it easier to manage and maintain.\n\n**Classes and Objects**\n=======================\n\nA class is a user-defined template for creating objects. It bundles data and functions together, making it easier to manage and use them. An object is an instance of a class, and multiple instances of an object type can be created. Think of a class as a blueprint for a car, and an object as a specific car that is created from that blueprint.\n\nFor example, consider the following code:\n```python\nclass Car:\n    def __init__(self, color, model, year):\n        self.color = color\n        self.model = model\n        self.year = year\n\nmy_car = Car('red', 'Toyota', 2022)\nprint(my_car.color)\nprint(my_car.model)\nprint(my_car.year)\n```\nIn this example, we define a `Car` class with attributes `color`, `model`, and `year`. We then create an object `my_car` from the `Car` class and print out its attributes.\n\n**Key Concepts**\n================\n\nThe core OOP principles include:\n\n*   Classes: A class is a blueprint or a template that defines the properties and behavior of an object.\n*   Objects: An object is an instance of a class, and has its own set of attributes (data) and methods (functions).\n*   Inheritance: Inheritance is the mechanism by which one class can inherit the properties and behavior of another class.\n*   Encapsulation: Encapsulation is the concept of hiding the implementation details of an object from the outside world, and only exposing the necessary information through public methods.\n*   Polymorphism: Polymorphism is the ability of an object to take on multiple forms, depending on the context in which it is used.\n*   Abstraction: Abstraction is the concept of showing only the necessary information to the outside world, while hiding the internal implementation details.\n\nThese principles work together to enable developers to create complex systems that are modular, maintainable, and scalable.\n\n**Classes**\n==========\n\nA class is a blueprint or a template that defines the properties and behavior of an object. It is defined using the `class` keyword followed by the name of the class. The class definition includes the attributes and methods of the class.\n\nFor example:\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greet(self):\n        print(f\"Hello, my name is {self.name} and I am {self.age} years old.\")\n```\nIn this example, we define a `Person` class with attributes `name` and `age`, and a method `greet` that prints out a greeting message.\n\n**Objects**\n==========\n\nAn object is an instance of a class, and has its own set of attributes (data) and methods (functions). An object is created by instantiating a class, which is done by calling the class name followed by parentheses containing the required arguments.\n\nFor example:\n```python\nperson = Person('John Doe', 30)\nperson.greet()\n```\nIn this example, we create an object `person` from the `Person` class and call the `greet` method.\n\n**Inheritance**\n==============\n\nInheritance is the mechanism by which one class can inherit the properties and behavior of another class. The child class inherits all the attributes and methods of the parent class and can also add new attributes and methods or override the ones inherited from the parent class.\n\nFor example:\n```python\nclass Employee(Person):\n    def __init__(self, name, age, salary):\n        super().__init__(name, age)\n        self.salary = salary\n\n    def get_salary(self):\n        return self.salary\n```\nIn this example, we define an `Employee` class that inherits from the `Person` class. The `Employee` class adds a new attribute `salary` and a method `get_salary`.\n\n**Encapsulation**\n==============\n\nEncapsulation is the concept of hiding the implementation details of an object from the outside world, and only exposing the necessary information through public methods. This helps to prevent data corruption and misuse.\n\nFor example:\n```python\nclass BankAccount:\n    def __init__(self, account_number, balance):\n        self.__account_number = account_number\n        self.__balance = balance\n\n    def get_balance(self):\n        return self.__balance\n\n    def deposit(self, amount):\n        self.__balance += amount\n```\nIn this example, we define a `BankAccount` class that encapsulates the account number and balance. The account number and balance are private attributes, and we provide public methods `get_balance` and `deposit` to access and modify them.\n\n**Polymorphism**\n==============\n\nPolymorphism is the ability of an object to take on multiple forms, depending on the context in which it is used. This can be achieved through method overriding or method overloading.\n\nFor example:\n```python\nclass Shape:\n    def area(self):\n        pass\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n\n    def area(self):\n        return self.side ** 2\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14 * self.radius ** 2\n```\nIn this example, we define a `Shape` class with a method `area`. We then define two subclasses `Square` and `Circle` that override the `area` method.\n\n**Abstraction**\n==============\n\nAbstraction is the concept of showing only the necessary information to the outside world, while hiding the internal implementation details. This helps to reduce complexity and improve modularity.\n\nFor example:\n```python\nclass CoffeeMachine:\n    def __init__(self):\n        self.water_temp = 0\n\n    def make_coffee(self):\n        self.boil_water()\n        self.mix_coffee()\n\n    def boil_water(self):\n        # internal implementation\n        self.water_temp = 100\n\n    def mix_coffee(self):\n        # internal implementation\n        print('Coffee is ready')\n```\nIn this example, we define a `CoffeeMachine` class that abstracts the process of making coffee. The `make_coffee` method hides the internal implementation details of boiling water and mixing coffee.\n\n**Benefits of OOP**\n====================\n\nThe benefits of OOP include:\n\n*   Modularity: OOP allows for the creation of self-contained modules of code that can be easily reused and maintained.\n*   Reusability: OOP enables the creation of reusable code, which can be used to build multiple applications.\n*   Easier maintenance: OOP makes it easier to modify and maintain code, as changes can be made at the class or object level without affecting other parts of the program.\n*   Improved readability: OOP promotes readability by organizing code into logical units, making it easier to understand and follow.\n\n**Modularity**\n==============\n\nOOP allows for the creation of self-contained modules of code that can be easily reused and maintained. This is achieved through the use of classes and objects, which encapsulate data and behavior.\n\nFor example, consider a banking system that consists of multiple modules, such as account management, transaction processing, and security. Each module can be implemented as a separate class, making it easier to maintain and update the system.\n\n**Reusability**\n==============\n\nOOP enables the creation of reusable code, which can be used to build multiple applications. This is achieved through the use of inheritance and polymorphism, which allow developers to create classes that can be reused in different contexts.\n\nFor example, consider a game development framework that provides a set of reusable classes for creating game objects, such as characters, vehicles, and weapons. These classes can be reused to build multiple games, reducing development time and improving productivity.\n\n**Easier Maintenance**\n=====================\n\nOOP makes it easier to modify and maintain code, as changes can be made at the class or object level without affecting other parts of the program. This is achieved through the use of encapsulation and abstraction, which hide internal implementation details and expose only the necessary information.\n\nFor example, consider a web application that consists of multiple modules, such as user authentication, payment processing, and content management. If a change is made to the user authentication module, it will not affect the other modules, making it easier to maintain and update the application.\n\n**Improved Readability**\n=====================\n\nOOP promotes readability by organizing code into logical units, making it easier to understand and follow. This is achieved through the use of classes and objects, which encapsulate data and behavior.\n\nFor example, consider a complex system that consists of multiple components, such as database management, network communication, and user interface. OOP can help to organize the code into logical units, making it easier to understand and maintain the system.\n\n**Example Use Cases**\n=====================\n\nHere are some example use cases for OOP:\n\n*   Creating a class to represent a car with attributes like color, model, year, and methods like start(), stop(), accelerate(), etc.\n*   Creating a class to represent a bank account with attributes like account number, balance, and methods like deposit(), withdraw(), get_balance(), etc.\n*   Creating a class to represent a game character with attributes like name, health, and methods like attack(), defend(), move(), etc.\n\nThese are just a few examples of how OOP can be applied in real-world scenarios. The key is to identify the objects and their relationships, and to use OOP principles to create modular, maintainable, and scalable code.\n\n**Conclusion**\n==========\n\nIn conclusion, OOP is a powerful programming paradigm that enables developers to create modular, maintainable, and scalable code. The core principles of OOP, including classes, objects, inheritance, encapsulation, polymorphism, and abstraction, work together to provide a robust framework for building complex systems. By applying OOP principles, developers can create reusable code, improve readability, and reduce maintenance costs. Whether you are building a simple script or a complex system, OOP is an essential tool to have in your programming toolkit."
  ]
}
